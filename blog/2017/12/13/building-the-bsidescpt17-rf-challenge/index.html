<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>building the bsidescpt17 rf challenge | #!/bin/note
</title>
<meta name=keywords content>
<meta name=description content="In this post I want to talk a little about the BSides Cape Town 2017 RFCat challenge and how I went about trying to build a challenge for it. Unfortunately I was not able to able to attend the conference itself, but still had the privilege to contribute in some way!">
<meta name=author content="Leon Jacobs">
<link rel=canonical href=https://leonjza.github.io/blog/2017/12/13/building-the-bsidescpt17-rf-challenge/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.5e2b4101351c21e906f398ae96901791830f58d430f96f2659dab7eaef7b3cb7.css integrity="sha256-XitBATUcIekG85iulpAXkYMPWNQw+W8mWdq36u97PLc=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://leonjza.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://leonjza.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://leonjza.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://leonjza.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://leonjza.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-44457032-2','auto'),ga('send','pageview'))</script><meta property="og:title" content="building the bsidescpt17 rf challenge">
<meta property="og:description" content="In this post I want to talk a little about the BSides Cape Town 2017 RFCat challenge and how I went about trying to build a challenge for it. Unfortunately I was not able to able to attend the conference itself, but still had the privilege to contribute in some way!">
<meta property="og:type" content="article">
<meta property="og:url" content="https://leonjza.github.io/blog/2017/12/13/building-the-bsidescpt17-rf-challenge/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2017-12-13T15:26:28+02:00">
<meta property="article:modified_time" content="2017-12-13T15:26:28+02:00"><meta property="og:site_name" content="#!/bin/note
">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="building the bsidescpt17 rf challenge">
<meta name=twitter:description content="In this post I want to talk a little about the BSides Cape Town 2017 RFCat challenge and how I went about trying to build a challenge for it. Unfortunately I was not able to able to attend the conference itself, but still had the privilege to contribute in some way!">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://leonjza.github.io/posts/"},{"@type":"ListItem","position":3,"name":"building the bsidescpt17 rf challenge","item":"https://leonjza.github.io/blog/2017/12/13/building-the-bsidescpt17-rf-challenge/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"building the bsidescpt17 rf challenge","name":"building the bsidescpt17 rf challenge","description":"In this post I want to talk a little about the BSides Cape Town 2017 RFCat challenge and how I went about trying to build a challenge for it. Unfortunately I was not able to able to attend the conference itself, but still had the privilege to contribute in some way!\n","keywords":[],"articleBody":"In this post I want to talk a little about the BSides Cape Town 2017 RFCat challenge and how I went about trying to build a challenge for it. Unfortunately I was not able to able to attend the conference itself, but still had the privilege to contribute in some way!\nThe first question you may have could be: “But why RFCat?”. Truthfully, some people that are way better at this hacking thing than me (and that were also primarily responsible for this years BSides badge hardware) came up with this idea: “Wouldn’t it be cool to have a cc1111 chip on the badges?”. The cc1111 chip is RFCat compatible, so naturally this would be the goto firmware to use for the chip. With this in mind, I got invited by @elasticninja to see if I would be interested in building an RFCat based challenge and without hesitation agreed! So there we were.\n  the hardware Taking a quick look at the actual hardware used, the badge itself was composed of two separate physical badges which included a black “flux capacitor” badge and a red “rf badge”. The flux capacitor badge sported an 2AL3B ESP chip that gave the badge wifi capabilities amongst others cool things.\n  The power bank used was estimated to give at least a full days power to the badge allowing for people to play with and hack away without needing a recharge too often.\n  The power bank itself was wired to a USB cable, letting you unplug it and charge the power bank easily. There were also two buttons soldered on to the back of the badge.\nFor the purposes of this post though, we will only focus on the red RF badge with the cc1111 chip soldered on.\n  The RF badge (as already mentioned previously) had a cc1111, RFCat compatible chip, a USB port and a button (no idea what that did haha).\n  The back of the badge was not that interesting.\nNow, unfortunately due to time constraints I was not able to get my hands on one of these badges before the conference and as such had to make another plan to get an environment up and running that would mimic the badge hardware as close as possible. Thankfully, sourcing some Yardstick One’s was relatively easy due to awesome hacker friends ;)\nchallenge ideas Getting to the point where you want to build a challenge, in my limited experience anyways, I believe that it is important for oneself to set out some high level goals to help you first of all, actually achieve your goals and secondly, keep you focussed in a direction without falling victim to the squirrel effect. In my case, I settled on the following goals:\n Low barrier of entry. Not knowing everything there is to know about RF should not hinder your ability to play (and win) the challenge. When you get a badge, you must have something working already. Even if crippled in its “factory default” state, it should be enough to at least have some fun. It should be possible to replicate, adapt and hack at later even after the con is over.  As you can see, these are very high level goals without much details, but it was enough for me to get started and reflect on should I lose track of what I am trying to do. When talking to Mike about what he had in mind in terms of the challenge and the logistics thereof, it was explained that a hardware box would be used as the goal to unlock using the RFCat based challenge. In essence, once a player “wins”, a small bit of python code would be used to unlock a magnetic lock or something similar, thereby allowing you to retrieve the prize. At the conference, this box also included a lock picking challenge!\n  After some time pondering ideas, I figured that for the challenge itself, it may be necessary for clients to talk to a “server”. The server needs the ability to receive messages from clients, process them and be authoritative in terms of who has progressed to which state of the game. At the same time I realised that it might be cool for the badges to be able to talk to each other using a similar medium. An idea that has been discussed at the office a few times now (albeit in a slightly different form).\nSo, I settled on the idea of having a broadcast-like chat system for the RF badges, and a server using a similar communications medium to be used for challenges. In order to “reveal” this challenge though, I figured it might be cool to have a working implementation of this broadcast-like chat system, whereby badge owners could partake in this RF based chat network by simply starting the client and being in range. The implementation given with the badge would say use a different modulation/syncword to the challenge server, there in lies some exploratory/clue finding to finally “connect” to the challenge server.\nbuilding blocks for the broadcast-like chat system Before I could do anything interesting with the broadcast idea though, I had to step back a few steps and get the two Yardstick One’s I had to “talk to each other”. Something that sounds super simple in theory (and it actually is), but when trying it gave me a few hours of grey hairs. Previously I have only been able to send messages and receive/replay other messages.\nUsing my host workstation, I had a Yardstick One \u0026 RFCat fired up in research mode, and another similar setup in a VMWare based virtual machine with another Yardstick One connected using USB passthrough mode to the VM. This setup allowed me to easily play with the send/receive ideas between the Yardsticks and test various things.\n  I tried quite a few things to be honest. Making sure I use the same frequency, modulation and baud rate on both ends of the transmission seemed obvious but just didn’t get me a way to reliably transfer data between the two Yardsticks. I would prepare hex encoded bytes to send with RFsend() on the one end, and try and receive them again using RFRecv() on the other end but just couldn’t reliably get transmissions to flow. In fact, all I got was noise. Using the discover() method, one could remove some of the noise filtering automatically applied by RFCat (lowball mode) to try and discover more signals, but this too failed me. Eventually I toggled the IdentSyncWord flag in the discover() method and realised that I never set a sync word to begin with. Well… one call to setMdmSyncWord() later and could finally reliably transfer frames between the two Yardstick Ones!\n  With the ability to transfer frames reliably, it was time to write some scripts to make this easier. A simple send.py and receive.py would suffice. All they need to do is setup the radios by configuring the frequency, sync word, baud rate and modulation in use. Then, simply encode and send / decode on receive.\n  Those scripts looked as follows:\n# send.py import binascii import sys import rflib # get the message from the command line message = ' '.join(sys.argv[1:]) print('Sending: {0}'.format(message)) message = binascii.hexlify(message) print('Message hex encoded: {0}'.format(message)) # setup the radio d = rflib.RfCat() d.setFreq(868000000) d.setMdmSyncWord(0x1985) d.setMdmModulation(rflib.MOD_2FSK) d.setMdmDRate(9600) print('Sending...') d.RFxmit(data=message, repeat=50) print('Done!') # receive.py import binascii import sys import rflib # setup the radio d = rflib.RfCat() d.setFreq(868000000) d.setMdmSyncWord(0x1985) d.setMdmModulation(rflib.MOD_2FSK) d.setMdmDRate(9600) print('Waiting for new messages...') while not rflib.keystop(): try: pkt, _ = d.RFrecv(timeout=1000) decoded_pkt = binascii.unhexlify(pkt) print(decoded_pkt) except (rflib.ChipconUsbTimeoutException, TypeError): pass transitioning to a working chat system The next challenge was to translate this into something that could be used as a chat client. I would like to start a script, and have the script accept input to send using RFCat. The chat client must be able to send and receive from the same script, using a single cc1111. A key thing to remember is that the cc1111 only works in half-duplex mode. That means that you can either be transmitting or receiving, not both at the same time. Before building something, I considered that the chat client would have a few interesting problems to solve:\n As we know, a client can’t send and receive at the same time so the default should be to always be in a receiving mode and only change when something should be sent. It is possible for frames to go missing or be incomplete so a retransmission strategy should be implemented. Anyone that uses the same frequency, syncword and modulation would be able to ‘tune’ into the chat, so no privacy should be expected :P  With these challenges in mind, the first thing I tried to solve was the fact that the radios were half-duplex and required a way to change state when messages were to be sent. After some testing, I settled on having a singleton class instance that would be shared between two threads. One thread responsible for sending data and another responsible for receiving, both monitoring the state of the radio. The state class (aptly called RadioState) would have a state property indicating the radios current state which could either be “send” or “receive”. From a threading perspective, the logic flowed something like this:\n Both threads would have an infinite loop checking the current state of the radio. Both threads would only continue with their respective logic (send/receive) if the radio was in the state required for that specific thread. The receiving thread would basically have a blocking call to RFrecv() that would wait for 1 second for a frame. Once the timeout is reached (or a valid frame is received) a check is done using the RadioState class to see if a state change is required. If a state change is required, change the actual state and return to the start of the infinite loop within the thread. The sending thread should now detect that the state has changed and proceed to transmit frames. Once done, return the state to “receive” causing the listening thread to resume frame captures. Rinse and repeat.  Implementing this was relatively easy given the time I spent considering ways to handle the half-duplex problem. In the end, an abstract of the chat client logic based on the class methods was as follows:\nclass RadioState(object): def __init__(self) def get_state(self) def set_receive_state(self) def is_receive_state(self) def set_send_state(self) def is_send_state(self) def want_state_change(self) def change_state_to(self, new_state) def change_state(self) def set_message_to_send(self, message_data) def get_message_to_send(self) class ListenThread(threading.Thread): def __init__(self, radio_state, *args, **kwargs) def run(self) def should_stop(self) def listen_for_packet(self) def check_for_state_change(self) class SendThread(threading.Thread): def __init__(self, radio_state, *args, **kwargs) def run(self) def should_stop(self) def reverse_state_to_receive(self) if __name__ == '__main__': state = RadioState() # prep and start 2 threads. one to listen, and one to send listen_thread = ListenThread(radio_state=state) send_thread = SendThread(radio_state=state) listen_thread.start() send_thread.start() while True: message = raw_input('[{}] message '.format(handle)) message = message.strip() # queue a new message send! state.set_message_to_send(message_data=message) # stop the threads listen_thread.stop = True send_thread.stop = True With the basic logic in place and working, I realised while testing that I would be sending messages (by simply typing them and hitting ENTER) much faster than the send, state-change, receive, state-change, send logic could complete. On top of that, the problem where messages would not necessarily reach the other end (or be incomplete) occurred much more than I had initially expected. So, a few more tweaks were needed.\nimproving the chat experience The fact that I was sending messages too fast for the client to process was something not too hard to solve. My original implementation could only set one message that should be sent, so to improve this, I changed the logic a little to instead populate a “message queue” (basically a python list) in the RadioState class. Now, when messages are being sent, they would be popped off the queue one after the other until the queue was empty. Only then would the state change back to receive be issued. What was nice about this change was that I could pop on more message into the queue as the sending thread was processing messages, only popping off the last one that was just sent. Great!\ndef queue_new_message(self, message_data): parts = [message_data[i:i + 50] \\ for i in range(0, len(message_data), 50)] for part in parts: self.message_queue.append( binascii.hexlify(self.name + ': ' + part) \\ .ljust(MAX_PACKET_LEN, '0')) def get_messages_from_queue(self): message_count = len(self.message_queue) if message_count  0: return [self.message_queue.pop(0) for _ in xrange(message_count)] return None This considerably improved the overall experience of the chat client. Messages would now flow a lot more fluently and be sent as expected. However, there was still one big issue. Message frames would not reliably end up on the other end. Blame interference, magic or someones mood on the other side of the globe, it was a problem that had to be dealt with.\nTo tackle the transmission reliability problem and given that I was playing against a bit of time, I decided to simply add some retransmission logic to the client. A simple loop to send the same frame three times seemed to drastically improve things. On top of that, I also noticed that the makePktFLEN() method could be used to specify the expected amount of bytes in a frame allowing the receiving end to be more clever about the frames it would receive. Tweaking the packet length number landed me on a scientifically and statistically proven™ number of 150 that was the sweet spot to reliably send / receive frames (not really I sucked the number out of my thumb). If you looked closely at the last code snippet, you may have noticed that I ended up actually padding hex encoded data frames with 0’s up to the size of MAX_PACKET_LEN which is the 150 I just mentioned.\nSo, two new bits of logic was added. The frame retransmission in the sending thread and a simple duplication check in the receiving thread (as there may be 3 duplicate frames ending up in chat clients). The gist of these changes were implemented as follows:\n# receiving thread def listen_for_packet(self): try: pkt, _ = d.RFrecv(timeout=1000) decoded_pkt = binascii.unhexlify(pkt).strip() # skip if we have already received this message if decoded_pkt in self.received_messages: return # print the message we got! print('{}'.format(decoded_pkt)) except (rflib.ChipconUsbTimeoutException, TypeError): pass # sending thread def run(self): while True: # get the pending messages to send messages_to_send = self.state.get_messages_from_queue() # send the messages for message_data in messages_to_send: for _ in range(3): d.RFxmit(data=message_data, repeat=1) # change back to the receiving state self.reverse_state_to_receive() These optimisations greatly improved the overall speed and reliability of the chat clients. Although not perfect, it was good enough for now. An example run of the chat client can be seen here:\nWriting this was a lot of fun, but now it was time to take a look at the challenge server it self.\nthe challenge server For the challenge server I was going to use the same “transport” that was just built for the chat clients. The difference though was that the modulation and sync word was different for it, so you have to figure that out. The challenge server would broadcast messages every 30 seconds that would both serve as a hint as well as help those searching for signal to find it. If you did not have kit for sniffing, some clues were also tweeted to get you going. Anyways, the challenge server was in fact just a modified chat client that would respond to specific messages. Changing the syncword, baud rate and modulation would have “connected” you to the challenge server network.\nGiven that there was more than one puzzle to solve on the challenge server network, I needed to write a little bit of game logic to keep track of who was at what stage of the game, as well as to know what the next hint/step should be. I have never done something like this, so practically everything I tried felt dirty or just failed.\nUltimately, I ended up with two new classes for the game. One for controlling and remembering the state of players that have connected and or interacted with the game server, and another for the actual game logic. The player state class called ChallengePlayers had a thread that would periodically serialise and save the object to disk in case the challenge server crashed and needed to be restored. The game logic itself was part of the GameLogic class. Messages received in the listening thread would be parsed and sent off to a new instance of GameLogic, whereby the return of the process_move() method would be used to update the current progress of the player.\nWell, “How were players identified?”, you may ask. Honestly, by whatever identifier they wanted to use. The original idea was to have the badges provide their WIFI MAC addresses to be used for identification, but time never really allowed for that. So it resulted in the player identification (and obvious spoofing capability) being player controlled. No biggie.\nFrom a challenge server perspective though, messages (aka: decoded frames) that were sent were parsed as follows:\n Hex decode a frame and validate that it is in fact a valid frame. With the decoded string value, attempt to split the string by :’s so that the user identifier is stripped and the rest of the message is separate. Yes, if your ‘name’ had a : you would break it. The user identifier from the previous method was used to determine the current state of the player, as well as have a timestamp with the last time a valid command was sent to the challenge server. The players current state as well as message payload parsed in a previous step is then sent to a new instance of the GameLogic.process_move() method for further processing. Depending on the return value of process_move(), update the player’s state and send any responses if needed.  A sample of what process_move() looked like within the GameLogic class:\ndef process_move(self): # first, newly connected players simply get a entry # in the games state. They should not have an existing # state and therefore are just recorded. if not self.player_state: return self._new_player_connected() if 'status' in self.message.lower(): return self._get_player_status() if any(x in self.message.lower() for x in ['88 miles an hour', 'eighty-eight miles an hour']): return self._update_stage_one() if 'unlock' in self.message.lower(): return self._update_stage_two() # if we had no idea what to do, default to nothing print('GameLogic can\\'t do anything with this message: {0}'.format(self.message)) return False, None, None The only part that was missing from my perspective now was to add the necessary code to finally unlock the challenge box once you have trigged the unlock method within the GameLogic class.\nprogressing through the challenge So assuming you managed to connect to the challenge server, progressing through the challenge to finally unlock the challenge box would have flowed as follows:\n Connect to the challenge server after modifying the provided chat clients RFCat configuration parameters such as the syncword, buad rate and modulation. Once connected, a message would be sent which looked like this: \"Welcome ! The temporal displacement occurred at exactly 1:20 AM and zero seconds! I just cant remember how fast we went...\". Solving the riddle in the broadcasted hint meant that you had to send the words “88 miles an hour” or “eighty-eight miles an hour”. This would have progressed you to stage 2. The challenge server would periodically broadcast a hint for the next stage, which would have showed up as follows: \"hint:LwlVBRFIQwscAQFOAAYCCwkDG1cPSE8dEwYGRRcaTREGGhpPAggLBA1PDwESSVQLSAUHAwACUwAbTggCGBYBEgcQUjIEVRxJLgQeEgoGGg4eQFlIEk8fBwccAAkACg0aUx4AHApC\". The fact that the hint starts with… 'hint' should have been a… hint ;) Attempting to base64 decode the string should result in unreadable gook being spewed out. A hint as to the fact that it may be encrypted was supposed to be shared, so during the challenge a simple XOR function was tweeted which revealed the method as well as the key used. The key was \"fourth dimensionally!\". Downloading the sample XOR code, a small modification was needed to decrypt the hint, which was as simple as modifying the decrypt method to take the argument passed onto the command line as the string to decrypt. Successful decryption should have given you the string: \"If we could somehow... harness this lightning; channel it into the Flux Capacitor, it just might work.\". This string was yet another riddle, but also required another hint to understand the format the challenge server was expecting. Unfortunately, I am unsure how this was shared at the con, but the hint should have revealed that the final payload needed to be in the format of unlock::1.21 gigawatts\". So in other words, unlock:ExwQAEVSEUpbXEUJGg4OGQAYGAo= if your username was user1. Sending this final payload would have moved you to the final stage, and finally unlock the the challenge box! A confirmation message would have been sent such as: “user1 has progressed to stage 2. The box should unlock!”  Solving the challenge itself, from both a client and the servers perspective would have looked something like this:\n20/20 hindsight I learned a lot while building this. Not just technically but also time management and all of those little “soft skills” needed to pull something like this off. If I had to do this again, I would probably try and make the actual challenges a little smoother (and maybe make more sense). I would also freaking google my idea first, so that I don’t come across similar ideas that have already be implemented! Finally, I would have loved to spend more time on improving the communications protocol used by the chat clients to make it faster and more reliable.\nthe code If you want to play with the code, its all available in a simple Github gist here: https://gist.github.com/leonjza/341b850f131e7078508ce2cb7ec23cdc.\nHave fun!\n","wordCount":"3617","inLanguage":"en","datePublished":"2017-12-13T15:26:28+02:00","dateModified":"2017-12-13T15:26:28+02:00","author":{"@type":"Person","name":"Leon Jacobs"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://leonjza.github.io/blog/2017/12/13/building-the-bsidescpt17-rf-challenge/"},"publisher":{"@type":"Organization","name":"#!/bin/note\n","logo":{"@type":"ImageObject","url":"https://leonjza.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://leonjza.github.io accesskey=h title="#!/bin/note
 (Alt + H)">#!/bin/note
</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://leonjza.github.io/about/ title="About Me">
<span>About Me</span>
</a>
</li>
<li>
<a href=https://leonjza.github.io/archives title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=https://leonjza.github.io/categories title=Categories>
<span>Categories</span>
</a>
</li>
<li>
<a href=https://leonjza.github.io/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://leonjza.github.io>Home</a>&nbsp;»&nbsp;<a href=https://leonjza.github.io/posts/>Posts</a></div>
<h1 class=post-title>
building the bsidescpt17 rf challenge
</h1>
<div class=post-meta>December 13, 2017&nbsp;·&nbsp;17 min&nbsp;·&nbsp;Leon Jacobs&nbsp;|&nbsp;<a href=https://github.com/leonjza/leonjza.github.io/tree/source/content/posts/2017-12-13-building-the-bsidescpt17-rfchallenge.markdown rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#the-hardware aria-label="the hardware">the hardware</a></li>
<li>
<a href=#challenge-ideas aria-label="challenge ideas">challenge ideas</a></li>
<li>
<a href=#building-blocks-for-the-broadcast-like-chat-system aria-label="building blocks for the broadcast-like chat system">building blocks for the broadcast-like chat system</a></li>
<li>
<a href=#transitioning-to-a-working-chat-system aria-label="transitioning to a working chat system">transitioning to a working chat system</a></li>
<li>
<a href=#improving-the-chat-experience aria-label="improving the chat experience">improving the chat experience</a></li>
<li>
<a href=#the-challenge-server aria-label="the challenge server">the challenge server</a></li>
<li>
<a href=#progressing-through-the-challenge aria-label="progressing through the challenge">progressing through the challenge</a></li>
<li>
<a href=#2020-hindsight aria-label="20/20 hindsight">20/20 hindsight</a></li>
<li>
<a href=#the-code aria-label="the code">the code</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p>In this post I want to talk a little about the BSides Cape Town 2017 RFCat challenge and how I went about trying to build a challenge for it. Unfortunately I was not able to able to attend the conference itself, but still had the privilege to contribute in some way!</p>
<p>The first question you may have could be: &ldquo;But why RFCat?&rdquo;. Truthfully, some people that are way better at this hacking thing than me (and that were also primarily responsible for this years BSides badge hardware) came up with this idea: &ldquo;Wouldn&rsquo;t it be cool to have a cc1111 chip on the badges?&rdquo;. The cc1111 chip is <a href=https://github.com/atlas0fd00m/rfcat>RFCat</a> compatible, so naturally this would be the goto firmware to use for the chip. With this in mind, I got invited by <a href=https://twitter.com/elasticninja>@elasticninja</a> to see if I would be interested in building an RFCat based challenge and without hesitation agreed! So there we were.</p>
<figure>
<img loading=lazy src=/images/bsides17badge/cc1111.jpg>
</figure>
<h1 id=the-hardware>the hardware<a hidden class=anchor aria-hidden=true href=#the-hardware>#</a></h1>
<p>Taking a quick look at the actual hardware used, the badge itself was composed of two separate physical badges which included a black &ldquo;flux capacitor&rdquo; badge and a red &ldquo;rf badge&rdquo;. The flux capacitor badge sported an 2AL3B ESP chip that gave the badge wifi capabilities amongst others cool things.</p>
<figure>
<img loading=lazy src=/images/bsides17badge/flux-capacitor-front.jpg>
</figure>
<p>The power bank used was estimated to give at least a full days power to the badge allowing for people to play with and hack away without needing a recharge too often.</p>
<figure>
<img loading=lazy src=/images/bsides17badge/flux-capacitor-back.jpg>
</figure>
<p>The power bank itself was wired to a USB cable, letting you unplug it and charge the power bank easily. There were also two buttons soldered on to the back of the badge.</p>
<p>For the purposes of this post though, we will only focus on the red RF badge with the cc1111 chip soldered on.</p>
<figure>
<img loading=lazy src=/images/bsides17badge/rfbadge-front.jpg>
</figure>
<p>The RF badge (as already mentioned previously) had a cc1111, RFCat compatible chip, a USB port and a button (no idea what that did haha).</p>
<figure>
<img loading=lazy src=/images/bsides17badge/rfbadge-back.jpg>
</figure>
<p>The back of the badge was not that interesting.</p>
<p>Now, unfortunately due to time constraints I was not able to get my hands on one of these badges before the conference and as such had to make another plan to get an environment up and running that would mimic the badge hardware as close as possible. Thankfully, sourcing some <a href=https://greatscottgadgets.com/yardstickone/>Yardstick One&rsquo;s</a> was relatively easy due to awesome hacker friends ;)</p>
<h1 id=challenge-ideas>challenge ideas<a hidden class=anchor aria-hidden=true href=#challenge-ideas>#</a></h1>
<p>Getting to the point where you want to build a challenge, in my limited experience anyways, I believe that it is important for oneself to set out some high level goals to help you first of all, actually achieve your goals and secondly, keep you focussed in a direction without falling victim to the squirrel effect. In my case, I settled on the following goals:</p>
<ul>
<li>Low barrier of entry. Not knowing everything there is to know about RF should not hinder your ability to play (and win) the challenge.</li>
<li>When you get a badge, you must have something working already. Even if crippled in its &ldquo;factory default&rdquo; state, it should be enough to at least have some fun.</li>
<li>It should be possible to replicate, adapt and hack at later even after the con is over.</li>
</ul>
<p>As you can see, these are very high level goals without much details, but it was enough for me to get started and reflect on should I lose track of what I am trying to do. When talking to Mike about what he had in mind in terms of the challenge and the logistics thereof, it was explained that a hardware box would be used as the goal to unlock using the RFCat based challenge. In essence, once a player &ldquo;wins&rdquo;, a small bit of python code would be used to unlock a magnetic lock or something similar, thereby allowing you to retrieve the prize. At the conference, this box also included a lock picking challenge!</p>
<figure>
<img loading=lazy src=/images/bsides17badge/plutonium.jpg>
</figure>
<p>After some time pondering ideas, I figured that for the challenge itself, it may be necessary for clients to talk to a &ldquo;server&rdquo;. The server needs the ability to receive messages from clients, process them and be authoritative in terms of who has progressed to which state of the game. At the same time I realised that it might be cool for the badges to be able to talk to each other using a similar medium. An idea that has been discussed at the office a few times now (albeit in a slightly different form).</p>
<p>So, I settled on the idea of having a broadcast-like chat system for the RF badges, and a server using a similar communications medium to be used for challenges. In order to &ldquo;reveal&rdquo; this challenge though, I figured it might be cool to have a working implementation of this broadcast-like chat system, whereby badge owners could partake in this RF based chat network by simply starting the client and being in range. The implementation given with the badge would say use a different modulation/syncword to the challenge server, there in lies some exploratory/clue finding to finally &ldquo;connect&rdquo; to the challenge server.</p>
<h1 id=building-blocks-for-the-broadcast-like-chat-system>building blocks for the broadcast-like chat system<a hidden class=anchor aria-hidden=true href=#building-blocks-for-the-broadcast-like-chat-system>#</a></h1>
<p>Before I could do anything interesting with the broadcast idea though, I had to step back a few steps and get the two Yardstick One&rsquo;s I had to &ldquo;talk to each other&rdquo;. Something that sounds super simple in theory (and it actually is), but when trying it gave me a few hours of grey hairs. Previously I have only been able to send messages and receive/replay other messages.</p>
<p>Using my host workstation, I had a Yardstick One & RFCat fired up in research mode, and another similar setup in a VMWare based virtual machine with another Yardstick One connected using USB passthrough mode to the VM. This setup allowed me to easily play with the send/receive ideas between the Yardsticks and test various things.</p>
<figure>
<img loading=lazy src=/images/bsides17badge/yardsticks.jpg>
</figure>
<p>I tried quite a few things to be honest. Making sure I use the same frequency, modulation and baud rate on both ends of the transmission seemed obvious but just didn&rsquo;t get me a way to reliably transfer data between the two Yardsticks. I would prepare hex encoded bytes to send with <code>RFsend()</code> on the one end, and try and receive them again using <code>RFRecv()</code> on the other end but just couldn&rsquo;t reliably get transmissions to flow. In fact, all I got was noise. Using the <code>discover()</code> method, one could remove some of the noise filtering automatically applied by RFCat (lowball mode) to try and discover more signals, but this too failed me. Eventually I toggled the <a href=https://github.com/atlas0fd00m/rfcat/blob/19bc9b057390a5c8a101395a0874fd728e30b63b/rflib/chipcon_nic.py#L1426>IdentSyncWord</a> flag in the discover() method and realised that I never set a sync word to begin with. Well&mldr; one call to <code>setMdmSyncWord()</code> later and could finally reliably transfer frames between the two Yardstick Ones!</p>
<figure>
<img loading=lazy src=/images/bsides17badge/rf-researchmode-edit.png>
</figure>
<p>With the ability to transfer frames reliably, it was time to write some scripts to make this easier. A simple <code>send.py</code> and <code>receive.py</code> would suffice. All they need to do is setup the radios by configuring the frequency, sync word, baud rate and modulation in use. Then, simply encode and send / decode on receive.</p>
<figure>
<img loading=lazy src=/images/bsides17badge/send-receive.png>
</figure>
<p>Those scripts looked as follows:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># send.py</span>

<span style=color:#f92672>import</span> binascii
<span style=color:#f92672>import</span> sys
<span style=color:#f92672>import</span> rflib

<span style=color:#75715e># get the message from the command line</span>
message <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39; &#39;</span><span style=color:#f92672>.</span>join(sys<span style=color:#f92672>.</span>argv[<span style=color:#ae81ff>1</span>:])
print(<span style=color:#e6db74>&#39;Sending: </span><span style=color:#e6db74>{0}</span><span style=color:#e6db74>&#39;</span><span style=color:#f92672>.</span>format(message))
message <span style=color:#f92672>=</span> binascii<span style=color:#f92672>.</span>hexlify(message)
print(<span style=color:#e6db74>&#39;Message hex encoded: </span><span style=color:#e6db74>{0}</span><span style=color:#e6db74>&#39;</span><span style=color:#f92672>.</span>format(message))

<span style=color:#75715e># setup the radio</span>
d <span style=color:#f92672>=</span> rflib<span style=color:#f92672>.</span>RfCat()
d<span style=color:#f92672>.</span>setFreq(<span style=color:#ae81ff>868000000</span>)
d<span style=color:#f92672>.</span>setMdmSyncWord(<span style=color:#ae81ff>0x1985</span>)
d<span style=color:#f92672>.</span>setMdmModulation(rflib<span style=color:#f92672>.</span>MOD_2FSK)
d<span style=color:#f92672>.</span>setMdmDRate(<span style=color:#ae81ff>9600</span>)

print(<span style=color:#e6db74>&#39;Sending...&#39;</span>)
d<span style=color:#f92672>.</span>RFxmit(data<span style=color:#f92672>=</span>message, repeat<span style=color:#f92672>=</span><span style=color:#ae81ff>50</span>)
print(<span style=color:#e6db74>&#39;Done!&#39;</span>)
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># receive.py</span>

<span style=color:#f92672>import</span> binascii
<span style=color:#f92672>import</span> sys
<span style=color:#f92672>import</span> rflib

<span style=color:#75715e># setup the radio</span>
d <span style=color:#f92672>=</span> rflib<span style=color:#f92672>.</span>RfCat()
d<span style=color:#f92672>.</span>setFreq(<span style=color:#ae81ff>868000000</span>)
d<span style=color:#f92672>.</span>setMdmSyncWord(<span style=color:#ae81ff>0x1985</span>)
d<span style=color:#f92672>.</span>setMdmModulation(rflib<span style=color:#f92672>.</span>MOD_2FSK)
d<span style=color:#f92672>.</span>setMdmDRate(<span style=color:#ae81ff>9600</span>)

print(<span style=color:#e6db74>&#39;Waiting for new messages...&#39;</span>)

<span style=color:#66d9ef>while</span> <span style=color:#f92672>not</span> rflib<span style=color:#f92672>.</span>keystop():
    <span style=color:#66d9ef>try</span>:
        pkt, _ <span style=color:#f92672>=</span> d<span style=color:#f92672>.</span>RFrecv(timeout<span style=color:#f92672>=</span><span style=color:#ae81ff>1000</span>)
        decoded_pkt <span style=color:#f92672>=</span> binascii<span style=color:#f92672>.</span>unhexlify(pkt)

        print(decoded_pkt)

    <span style=color:#66d9ef>except</span> (rflib<span style=color:#f92672>.</span>ChipconUsbTimeoutException, <span style=color:#a6e22e>TypeError</span>):
        <span style=color:#66d9ef>pass</span>
</code></pre></div><h1 id=transitioning-to-a-working-chat-system>transitioning to a working chat system<a hidden class=anchor aria-hidden=true href=#transitioning-to-a-working-chat-system>#</a></h1>
<p>The next challenge was to translate this into something that could be used as a chat client. I would like to start a script, and have the script accept input to send using RFCat. The chat client must be able to send and receive from the same script, using a single cc1111. A key thing to remember is that the cc1111 only works in half-duplex mode. That means that you can either be transmitting or receiving, not both at the same time. Before building something, I considered that the chat client would have a few interesting problems to solve:</p>
<ul>
<li>As we know, a client can&rsquo;t send and receive at the same time so the default should be to always be in a receiving mode and only change when something should be sent.</li>
<li>It is possible for frames to go missing or be incomplete so a retransmission strategy should be implemented.</li>
<li>Anyone that uses the same frequency, syncword and modulation would be able to &lsquo;tune&rsquo; into the chat, so no privacy should be expected :P</li>
</ul>
<p>With these challenges in mind, the first thing I tried to solve was the fact that the radios were half-duplex and required a way to change state when messages were to be sent. After some testing, I settled on having a singleton class instance that would be shared between two threads. One thread responsible for sending data and another responsible for receiving, both monitoring the state of the radio. The state class (aptly called <code>RadioState</code>) would have a state property indicating the radios current state which could either be &ldquo;send&rdquo; or &ldquo;receive&rdquo;. From a threading perspective, the logic flowed something like this:</p>
<ul>
<li>Both threads would have an infinite loop checking the current state of the radio.</li>
<li>Both threads would only continue with their respective logic (send/receive) if the radio was in the state required for that specific thread.</li>
<li>The receiving thread would basically have a blocking call to <code>RFrecv()</code> that would wait for 1 second for a frame.</li>
<li>Once the timeout is reached (or a valid frame is received) a check is done using the <code>RadioState</code> class to see if a state change is required.</li>
<li>If a state change is required, change the actual state and return to the start of the infinite loop within the thread.</li>
<li>The sending thread should now detect that the state has changed and proceed to transmit frames. Once done, return the state to &ldquo;receive&rdquo; causing the listening thread to resume frame captures.</li>
<li>Rinse and repeat.</li>
</ul>
<p>Implementing this was relatively easy given the time I spent considering ways to handle the half-duplex problem. In the end, an abstract of the chat client logic based on the class methods was as follows:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RadioState</span>(object):
    <span style=color:#66d9ef>def</span> __init__(self)
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_state</span>(self)
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>set_receive_state</span>(self)
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_receive_state</span>(self)
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>set_send_state</span>(self)
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_send_state</span>(self)
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>want_state_change</span>(self)
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>change_state_to</span>(self, new_state)
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>change_state</span>(self)
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>set_message_to_send</span>(self, message_data)
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_message_to_send</span>(self)


<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ListenThread</span>(threading<span style=color:#f92672>.</span>Thread):
    <span style=color:#66d9ef>def</span> __init__(self, radio_state, <span style=color:#f92672>*</span>args, <span style=color:#f92672>**</span>kwargs)
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run</span>(self)
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>should_stop</span>(self)
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>listen_for_packet</span>(self)
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>check_for_state_change</span>(self)


<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SendThread</span>(threading<span style=color:#f92672>.</span>Thread):
    <span style=color:#66d9ef>def</span> __init__(self, radio_state, <span style=color:#f92672>*</span>args, <span style=color:#f92672>**</span>kwargs)
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run</span>(self)
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>should_stop</span>(self)
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>reverse_state_to_receive</span>(self)


<span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:

    state <span style=color:#f92672>=</span> RadioState()

    <span style=color:#75715e># prep and start 2 threads. one to listen, and one to send</span>
    listen_thread <span style=color:#f92672>=</span> ListenThread(radio_state<span style=color:#f92672>=</span>state)
    send_thread <span style=color:#f92672>=</span> SendThread(radio_state<span style=color:#f92672>=</span>state)
    listen_thread<span style=color:#f92672>.</span>start()
    send_thread<span style=color:#f92672>.</span>start()

    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
        message <span style=color:#f92672>=</span> raw_input(<span style=color:#e6db74>&#39;[</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>] message&gt; &#39;</span><span style=color:#f92672>.</span>format(handle))
        message <span style=color:#f92672>=</span> message<span style=color:#f92672>.</span>strip()

        <span style=color:#75715e># queue a new message send!</span>
        state<span style=color:#f92672>.</span>set_message_to_send(message_data<span style=color:#f92672>=</span>message)

    <span style=color:#75715e># stop the threads</span>
    listen_thread<span style=color:#f92672>.</span>stop <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
    send_thread<span style=color:#f92672>.</span>stop <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</code></pre></div><p>With the basic logic in place and working, I realised while testing that I would be sending messages (by simply typing them and hitting ENTER) much faster than the send, state-change, receive, state-change, send logic could complete. On top of that, the problem where messages would not necessarily reach the other end (or be incomplete) occurred much more than I had initially expected. So, a few more tweaks were needed.</p>
<h1 id=improving-the-chat-experience>improving the chat experience<a hidden class=anchor aria-hidden=true href=#improving-the-chat-experience>#</a></h1>
<p>The fact that I was sending messages too fast for the client to process was something not too hard to solve. My original implementation could only set one message that should be sent, so to improve this, I changed the logic a little to instead populate a &ldquo;message queue&rdquo; (basically a python list) in the <code>RadioState</code> class. Now, when messages are being sent, they would be popped off the queue one after the other until the queue was empty. Only then would the state change back to receive be issued. What was nice about this change was that I could pop on more message into the queue as the sending thread was processing messages, only popping off the last one that was just sent. Great!</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>queue_new_message</span>(self, message_data):
    parts <span style=color:#f92672>=</span> [message_data[i:i <span style=color:#f92672>+</span> <span style=color:#ae81ff>50</span>] \
        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>0</span>, len(message_data), <span style=color:#ae81ff>50</span>)]

    <span style=color:#66d9ef>for</span> part <span style=color:#f92672>in</span> parts:
        self<span style=color:#f92672>.</span>message_queue<span style=color:#f92672>.</span>append(
            binascii<span style=color:#f92672>.</span>hexlify(self<span style=color:#f92672>.</span>name <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;: &#39;</span> <span style=color:#f92672>+</span> part) \
            <span style=color:#f92672>.</span>ljust(MAX_PACKET_LEN, <span style=color:#e6db74>&#39;0&#39;</span>))

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_messages_from_queue</span>(self):
    message_count <span style=color:#f92672>=</span> len(self<span style=color:#f92672>.</span>message_queue)

    <span style=color:#66d9ef>if</span> message_count <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>:
        <span style=color:#66d9ef>return</span> [self<span style=color:#f92672>.</span>message_queue<span style=color:#f92672>.</span>pop(<span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> xrange(message_count)]

    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>None</span>
</code></pre></div><p>This considerably improved the overall experience of the chat client. Messages would now flow a lot more fluently and be sent as expected. However, there was still one big issue. Message frames would not reliably end up on the other end. Blame interference, magic or someones mood on the other side of the globe, it was a problem that had to be dealt with.</p>
<p>To tackle the transmission reliability problem and given that I was playing against a bit of time, I decided to simply add some retransmission logic to the client. A simple loop to send the same frame three times seemed to <em>drastically</em> improve things. On top of that, I also noticed that the <code>makePktFLEN()</code> method could be used to specify the expected amount of bytes in a frame allowing the receiving end to be more clever about the frames it would receive. Tweaking the packet length number landed me on a scientifically and statistically proven™ number of 150 that was the sweet spot to reliably send / receive frames (not really I sucked the number out of my thumb). If you looked closely at the last code snippet, you may have noticed that I ended up actually padding hex encoded data frames with 0&rsquo;s up to the size of  <code>MAX_PACKET_LEN</code> which is the 150 I just mentioned.</p>
<p>So, two new bits of logic was added. The frame retransmission in the sending thread and a simple duplication check in the receiving thread (as there may be 3 duplicate frames ending up in chat clients). The gist of these changes were implemented as follows:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># receiving thread</span>

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>listen_for_packet</span>(self):

    <span style=color:#66d9ef>try</span>:
        pkt, _ <span style=color:#f92672>=</span> d<span style=color:#f92672>.</span>RFrecv(timeout<span style=color:#f92672>=</span><span style=color:#ae81ff>1000</span>)
        decoded_pkt <span style=color:#f92672>=</span> binascii<span style=color:#f92672>.</span>unhexlify(pkt)<span style=color:#f92672>.</span>strip()

        <span style=color:#75715e># skip if we have already received this message</span>
        <span style=color:#66d9ef>if</span> decoded_pkt <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>received_messages:
            <span style=color:#66d9ef>return</span>

        <span style=color:#75715e># print the message we got!</span>
        print(<span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#39;</span><span style=color:#f92672>.</span>format(decoded_pkt))

    <span style=color:#66d9ef>except</span> (rflib<span style=color:#f92672>.</span>ChipconUsbTimeoutException, <span style=color:#a6e22e>TypeError</span>):
        <span style=color:#66d9ef>pass</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># sending thread</span>

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run</span>(self):

    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:

        <span style=color:#75715e># get the pending messages to send</span>
        messages_to_send <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>state<span style=color:#f92672>.</span>get_messages_from_queue()

        <span style=color:#75715e># send the messages</span>
        <span style=color:#66d9ef>for</span> message_data <span style=color:#f92672>in</span> messages_to_send:
            <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>3</span>):
                d<span style=color:#f92672>.</span>RFxmit(data<span style=color:#f92672>=</span>message_data, repeat<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)

        <span style=color:#75715e># change back to the receiving state</span>
        self<span style=color:#f92672>.</span>reverse_state_to_receive()
</code></pre></div><p>These optimisations greatly improved the overall speed and reliability of the chat clients. Although not perfect, it was good enough for now. An example run of the chat client can be seen here:</p>
<p></p>
<p>Writing this was a lot of fun, but now it was time to take a look at the challenge server it self.</p>
<h1 id=the-challenge-server>the challenge server<a hidden class=anchor aria-hidden=true href=#the-challenge-server>#</a></h1>
<p>For the challenge server I was going to use the same &ldquo;transport&rdquo; that was just built for the chat clients. The difference though was that the modulation and sync word was different for it, so you have to figure that out. The challenge server would broadcast messages every 30 seconds that would both serve as a hint as well as help those searching for signal to find it. If you did not have kit for sniffing, some clues were also <a href=https://twitter.com/elasticninja/status/936952633125953537>tweeted</a> to get you going. Anyways, the challenge server was in fact just a modified chat client that would respond to specific messages. Changing the syncword, baud rate and modulation would have &ldquo;connected&rdquo; you to the challenge server network.</p>
<p>Given that there was more than one puzzle to solve on the challenge server network, I needed to write a little bit of game logic to keep track of who was at what stage of the game, as well as to know what the next hint/step should be. I have never done something like this, so practically everything I tried felt dirty or just failed.</p>
<p>Ultimately, I ended up with two new classes for the game. One for controlling and remembering the state of players that have connected and or interacted with the game server, and another for the actual game logic. The player state class called <code>ChallengePlayers</code> had a thread that would periodically serialise and save the object to disk in case the challenge server crashed and needed to be restored. The game logic itself was part of the <code>GameLogic</code> class. Messages received in the listening thread would be parsed and sent off to a new instance of <code>GameLogic</code>, whereby the return of the <code>process_move()</code> method would be used to update the current progress of the player.</p>
<p>Well, &ldquo;How were players identified?&rdquo;, you may ask. Honestly, by whatever identifier they wanted to use. The original idea was to have the badges provide their WIFI MAC addresses to be used for identification, but time never really allowed for that. So it resulted in the player identification (and obvious spoofing capability) being player controlled. No biggie.</p>
<p>From a challenge server perspective though, messages (aka: decoded frames) that were sent were parsed as follows:</p>
<ul>
<li>Hex decode a frame and validate that it is in fact a valid frame.</li>
<li>With the decoded string value, attempt to split the string by <code>:</code>&rsquo;s so that the user identifier is stripped and the rest of the message is separate. Yes, if your &lsquo;name&rsquo; had a <code>:</code> you would break it.</li>
<li>The user identifier from the previous method was used to determine the current state of the player, as well as have a timestamp with the last time a valid command was sent to the challenge server.</li>
<li>The players current state as well as message payload parsed in a previous step is then sent to a new instance of the <code>GameLogic.process_move()</code> method for further processing.</li>
<li>Depending on the return value of <code>process_move()</code>, update the player&rsquo;s state and send any responses if needed.</li>
</ul>
<p>A sample of what <code>process_move()</code> looked like within the <code>GameLogic</code> class:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>process_move</span>(self):
    <span style=color:#75715e># first, newly connected players simply get a entry</span>
    <span style=color:#75715e># in the games state. They should not have an existing</span>
    <span style=color:#75715e># state and therefore are just recorded.</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> self<span style=color:#f92672>.</span>player_state:
        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>_new_player_connected()

    <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#39;status&#39;</span> <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>message<span style=color:#f92672>.</span>lower():
        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>_get_player_status()

    <span style=color:#66d9ef>if</span> any(x <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>message<span style=color:#f92672>.</span>lower() <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> [<span style=color:#e6db74>&#39;88 miles an hour&#39;</span>, <span style=color:#e6db74>&#39;eighty-eight miles an hour&#39;</span>]):
        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>_update_stage_one()

    <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#39;unlock&#39;</span> <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>message<span style=color:#f92672>.</span>lower():
        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>_update_stage_two()

    <span style=color:#75715e># if we had no idea what to do, default to nothing</span>
    print(<span style=color:#e6db74>&#39;GameLogic can</span><span style=color:#ae81ff>\&#39;</span><span style=color:#e6db74>t do anything with this message: </span><span style=color:#e6db74>{0}</span><span style=color:#e6db74>&#39;</span><span style=color:#f92672>.</span>format(self<span style=color:#f92672>.</span>message))

    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>, <span style=color:#66d9ef>None</span>, <span style=color:#66d9ef>None</span>
</code></pre></div><p>The only part that was missing from my perspective now was to add the necessary code to finally unlock the challenge box once you have trigged the unlock method within the <code>GameLogic</code> class.</p>
<h1 id=progressing-through-the-challenge>progressing through the challenge<a hidden class=anchor aria-hidden=true href=#progressing-through-the-challenge>#</a></h1>
<p>So assuming you managed to connect to the challenge server, progressing through the challenge to finally unlock the challenge box would have flowed as follows:</p>
<ul>
<li>Connect to the challenge server after modifying the provided chat clients RFCat configuration parameters such as the syncword, buad rate and modulation.</li>
<li>Once connected, a message would be sent which looked like this: <code>"Welcome &lt;your user_name>! The temporal displacement occurred at exactly 1:20 AM and zero seconds! I just cant remember how fast we went..."</code>.</li>
<li>Solving the riddle in the broadcasted hint meant that you had to send the words &ldquo;88 miles an hour&rdquo; or &ldquo;eighty-eight miles an hour&rdquo;. This would have progressed you to stage 2.</li>
<li>The challenge server would periodically broadcast a hint for the next stage, which would have showed up as follows: <code>"hint:LwlVBRFIQwscAQFOAAYCCwkDG1cPSE8dEwYGRRcaTREGGhpPAggLBA1PDwESSVQLSAUHAwACUwAbTggCGBYBEgcQUjIEVRxJLgQeEgoGGg4eQFlIEk8fBwccAAkACg0aUx4AHApC"</code>. The fact that the hint starts with&mldr; <code>'hint'</code> should have been a&mldr; hint ;)</li>
<li>Attempting to base64 decode the string should result in unreadable gook being spewed out. A hint as to the fact that it may be encrypted was supposed to be shared, so during the challenge a simple XOR function was <a href=https://twitter.com/elasticninja/status/936933352690606080>tweeted</a> which revealed the method as well as the key used. The key was <code>"fourth dimensionally!"</code>.</li>
<li>Downloading the sample XOR code, a small modification was needed to decrypt the hint, which was as simple as modifying the decrypt method to take the argument passed onto the command line as the string to decrypt. Successful decryption should have given you the string: <code>"If we could somehow... harness this lightning; channel it into the Flux Capacitor, it just might work."</code>.</li>
<li>This string was yet another riddle, but also required another hint to understand the format the challenge server was expecting. Unfortunately, I am unsure how this was shared at the con, but the hint should have revealed that the final payload needed to be in the format of <code>unlock:&lt;xor'd & base64encoded string "&lt;your_user>:1.21 gigawatts"></code>. So in other words, <code>unlock:ExwQAEVSEUpbXEUJGg4OGQAYGAo=</code> if your username was <code>user1</code>.</li>
<li>Sending this final payload would have moved you to the final stage, and finally unlock the the challenge box! A confirmation message would have been sent such as: &ldquo;user1 has progressed to stage 2. The box should unlock!&rdquo;</li>
</ul>
<p>Solving the challenge itself, from both a client and the servers perspective would have looked something like this:</p>
<p></p>
<h1 id=2020-hindsight>20/20 hindsight<a hidden class=anchor aria-hidden=true href=#2020-hindsight>#</a></h1>
<p>I learned a lot while building this. Not just technically but also time management and all of those little &ldquo;soft skills&rdquo; needed to pull something like this off. If I had to do this again, I would probably try and make the actual challenges a little smoother (and maybe make more sense). I would also freaking google my idea first, so that I don&rsquo;t come across similar ideas that have already be implemented! Finally, I would have loved to spend more time on improving the communications protocol used by the chat clients to make it faster and more reliable.</p>
<h1 id=the-code>the code<a hidden class=anchor aria-hidden=true href=#the-code>#</a></h1>
<p>If you want to play with the code, its all available in a simple Github gist here: https://gist.github.com/leonjza/341b850f131e7078508ce2cb7ec23cdc.</p>
<p>Have fun!</p>
</div>
<footer class=post-footer>
<nav class=paginav>
<a class=prev href=https://leonjza.github.io/blog/2018/03/03/microcorruption-tutorial/>
<span class=title>« Prev Page</span>
<br>
<span>microcorruption - tutorial</span>
</a>
<a class=next href=https://leonjza.github.io/blog/2017/07/11/objection-runtime-mobile-exploration/>
<span class=title>Next Page »</span>
<br>
<span>objection - runtime mobile exploration</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share building the bsidescpt17 rf challenge on twitter" href="https://twitter.com/intent/tweet/?text=building%20the%20bsidescpt17%20rf%20challenge&url=https%3a%2f%2fleonjza.github.io%2fblog%2f2017%2f12%2f13%2fbuilding-the-bsidescpt17-rf-challenge%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share building the bsidescpt17 rf challenge on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fleonjza.github.io%2fblog%2f2017%2f12%2f13%2fbuilding-the-bsidescpt17-rf-challenge%2f&title=building%20the%20bsidescpt17%20rf%20challenge&summary=building%20the%20bsidescpt17%20rf%20challenge&source=https%3a%2f%2fleonjza.github.io%2fblog%2f2017%2f12%2f13%2fbuilding-the-bsidescpt17-rf-challenge%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share building the bsidescpt17 rf challenge on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fleonjza.github.io%2fblog%2f2017%2f12%2f13%2fbuilding-the-bsidescpt17-rf-challenge%2f&title=building%20the%20bsidescpt17%20rf%20challenge"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share building the bsidescpt17 rf challenge on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fleonjza.github.io%2fblog%2f2017%2f12%2f13%2fbuilding-the-bsidescpt17-rf-challenge%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share building the bsidescpt17 rf challenge on whatsapp" href="https://api.whatsapp.com/send?text=building%20the%20bsidescpt17%20rf%20challenge%20-%20https%3a%2f%2fleonjza.github.io%2fblog%2f2017%2f12%2f13%2fbuilding-the-bsidescpt17-rf-challenge%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share building the bsidescpt17 rf challenge on telegram" href="https://telegram.me/share/url?text=building%20the%20bsidescpt17%20rf%20challenge&url=https%3a%2f%2fleonjza.github.io%2fblog%2f2017%2f12%2f13%2fbuilding-the-bsidescpt17-rf-challenge%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>@leonjza</span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>